function getSource() {
    return '' +
    '<table><tbody>\n' +
        '<tr>\n' +
            '<td><a name=1>1</a></td>\n' +
            '<td>Z8530 Programming Guide</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2>2</a></td>\n' +
            '<td>Alan Cox</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3>3</a></td>\n' +
            '<td>Oct 15, 2007</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4>4</a></td>\n' +
            '<td>Explaining wireless 802.11 networking in the Linux kernel</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5>5</a></td>\n' +
            '<td>2007-2009</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6>6</a></td>\n' +
            '<td>Johannes Berg</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7>7</a></td>\n' +
            '<td>This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=8>8</a></td>\n' +
            '<td>This documentation is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=9>9</a></td>\n' +
            '<td>You should have received a copy of the GNU General Public License along with this documentation; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=10>10</a></td>\n' +
            '<td>For more details see the file COPYING in the source distribution of Linux.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=11>11</a></td>\n' +
            '<td>These books attempt to give a description of the various subsystems that play a role in 802.11 wireless networking in Linux. Since these books are for kernel developers they attempts to document the structures and functions used in the kernel as well as giving a higher-level overview.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=12>12</a></td>\n' +
            '<td>The reader is expected to be familiar with the 802.11 standard as published by the IEEE in 802.11-2007 (or possibly later versions). References to this standard will be given as "802.11-2007 8.1.5".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=13>13</a></td>\n' +
            '<td>Device registration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=14>14</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Device registration !Finclude/net/cfg80211.h ieee80211_band !Finclude/net/cfg80211.h ieee80211_channel_flags !Finclude/net/cfg80211.h ieee80211_channel !Finclude/net/cfg80211.h ieee80211_rate_flags !Finclude/net/cfg80211.h ieee80211_rate !Finclude/net/cfg80211.h ieee80211_sta_ht_cap !Finclude/net/cfg80211.h ieee80211_supported_band !Finclude/net/cfg80211.h cfg80211_signal_type !Finclude/net/cfg80211.h wiphy_params_flags !Finclude/net/cfg80211.h wiphy_flags !Finclude/net/cfg80211.h wiphy !Finclude/net/cfg80211.h wireless_dev !Finclude/net/cfg80211.h wiphy_new !Finclude/net/cfg80211.h wiphy_register !Finclude/net/cfg80211.h wiphy_unregister !Finclude/net/cfg80211.h wiphy_free !Finclude/net/cfg80211.h wiphy_name !Finclude/net/cfg80211.h wiphy_dev !Finclude/net/cfg80211.h wiphy_priv !Finclude/net/cfg80211.h priv_to_wiphy !Finclude/net/cfg80211.h set_wiphy_dev !Finclude/net/cfg80211.h wdev_priv</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=15>15</a></td>\n' +
            '<td>Actions and configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=16>16</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Actions and configuration !Finclude/net/cfg80211.h cfg80211_ops !Finclude/net/cfg80211.h vif_params !Finclude/net/cfg80211.h key_params !Finclude/net/cfg80211.h survey_info_flags !Finclude/net/cfg80211.h survey_info !Finclude/net/cfg80211.h cfg80211_beacon_data !Finclude/net/cfg80211.h cfg80211_ap_settings !Finclude/net/cfg80211.h station_parameters !Finclude/net/cfg80211.h station_info_flags !Finclude/net/cfg80211.h rate_info_flags !Finclude/net/cfg80211.h rate_info !Finclude/net/cfg80211.h station_info !Finclude/net/cfg80211.h monitor_flags !Finclude/net/cfg80211.h mpath_info_flags !Finclude/net/cfg80211.h mpath_info !Finclude/net/cfg80211.h bss_parameters !Finclude/net/cfg80211.h ieee80211_txq_params !Finclude/net/cfg80211.h cfg80211_crypto_settings !Finclude/net/cfg80211.h cfg80211_auth_request !Finclude/net/cfg80211.h cfg80211_assoc_request !Finclude/net/cfg80211.h cfg80211_deauth_request !Finclude/net/cfg80211.h cfg80211_disassoc_request !Finclude/net/cfg80211.h cfg80211_ibss_params !Finclude/net/cfg80211.h cfg80211_connect_params !Finclude/net/cfg80211.h cfg80211_pmksa !Finclude/net/cfg80211.h cfg80211_rx_mlme_mgmt !Finclude/net/cfg80211.h cfg80211_auth_timeout !Finclude/net/cfg80211.h cfg80211_rx_assoc_resp !Finclude/net/cfg80211.h cfg80211_assoc_timeout !Finclude/net/cfg80211.h cfg80211_tx_mlme_mgmt !Finclude/net/cfg80211.h cfg80211_ibss_joined !Finclude/net/cfg80211.h cfg80211_connect_result !Finclude/net/cfg80211.h cfg80211_roamed !Finclude/net/cfg80211.h cfg80211_disconnected !Finclude/net/cfg80211.h cfg80211_ready_on_channel !Finclude/net/cfg80211.h cfg80211_remain_on_channel_expired !Finclude/net/cfg80211.h cfg80211_new_sta !Finclude/net/cfg80211.h cfg80211_rx_mgmt !Finclude/net/cfg80211.h cfg80211_mgmt_tx_status !Finclude/net/cfg80211.h cfg80211_cqm_rssi_notify !Finclude/net/cfg80211.h cfg80211_cqm_pktloss_notify !Finclude/net/cfg80211.h cfg80211_michael_mic_failure</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=17>17</a></td>\n' +
            '<td>Scanning and BSS list handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=18>18</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Scanning and BSS list handling !Finclude/net/cfg80211.h cfg80211_ssid !Finclude/net/cfg80211.h cfg80211_scan_request !Finclude/net/cfg80211.h cfg80211_scan_done !Finclude/net/cfg80211.h cfg80211_bss !Finclude/net/cfg80211.h cfg80211_inform_bss_width_frame !Finclude/net/cfg80211.h cfg80211_inform_bss_width !Finclude/net/cfg80211.h cfg80211_unlink_bss !Finclude/net/cfg80211.h cfg80211_find_ie !Finclude/net/cfg80211.h ieee80211_bss_get_ie</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=19>19</a></td>\n' +
            '<td>Utility functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=20>20</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Utility functions !Finclude/net/cfg80211.h ieee80211_channel_to_frequency !Finclude/net/cfg80211.h ieee80211_frequency_to_channel !Finclude/net/cfg80211.h ieee80211_get_channel !Finclude/net/cfg80211.h ieee80211_get_response_rate !Finclude/net/cfg80211.h ieee80211_hdrlen !Finclude/net/cfg80211.h ieee80211_get_hdrlen_from_skb !Finclude/net/cfg80211.h ieee80211_radiotap_iterator</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=21>21</a></td>\n' +
            '<td>Data path helpers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=22>22</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Data path helpers !Finclude/net/cfg80211.h ieee80211_data_to_8023 !Finclude/net/cfg80211.h ieee80211_data_from_8023 !Finclude/net/cfg80211.h ieee80211_amsdu_to_8023s !Finclude/net/cfg80211.h cfg80211_classify8021d</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=23>23</a></td>\n' +
            '<td>Regulatory enforcement infrastructure</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=24>24</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Regulatory enforcement infrastructure !Finclude/net/cfg80211.h regulatory_hint !Finclude/net/cfg80211.h wiphy_apply_custom_regulatory !Finclude/net/cfg80211.h freq_reg_info</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=25>25</a></td>\n' +
            '<td>RFkill integration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=26>26</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h RFkill integration !Finclude/net/cfg80211.h wiphy_rfkill_set_hw_state !Finclude/net/cfg80211.h wiphy_rfkill_start_polling !Finclude/net/cfg80211.h wiphy_rfkill_stop_polling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=27>27</a></td>\n' +
            '<td>Test mode</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=28>28</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Test mode !Finclude/net/cfg80211.h cfg80211_testmode_alloc_reply_skb !Finclude/net/cfg80211.h cfg80211_testmode_reply !Finclude/net/cfg80211.h cfg80211_testmode_alloc_event_skb !Finclude/net/cfg80211.h cfg80211_testmode_event</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=29>29</a></td>\n' +
            '<td>You should read and understand the information contained within this part of the book while implementing a driver. In some chapters, advanced usage is noted, that may be skipped at first.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=30>30</a></td>\n' +
            '<td>This part of the book only covers station and monitor mode functionality, additional information required to implement the other modes is covered in the second part of the book.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=31>31</a></td>\n' +
            '<td>Basic hardware handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=32>32</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=33>33</a></td>\n' +
            '<td>This chapter shall contain information on getting a hw struct allocated and registered with mac80211.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=34>34</a></td>\n' +
            '<td>Since it is required to allocate rates/modes before registering a hw struct, this chapter shall also contain information on setting up the rate/mode structs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=35>35</a></td>\n' +
            '<td>Additionally, some discussion about the callbacks and the general programming model should be in here, including the definition of ieee80211_ops which will be referred to a lot.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=36>36</a></td>\n' +
            '<td>Finally, a discussion of hardware capabilities should be done with references to other parts of the book.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=37>37</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_hw !Finclude/net/mac80211.h ieee80211_hw_flags !Finclude/net/mac80211.h SET_IEEE80211_DEV !Finclude/net/mac80211.h SET_IEEE80211_PERM_ADDR !Finclude/net/mac80211.h ieee80211_ops !Finclude/net/mac80211.h ieee80211_alloc_hw !Finclude/net/mac80211.h ieee80211_register_hw !Finclude/net/mac80211.h ieee80211_unregister_hw !Finclude/net/mac80211.h ieee80211_free_hw</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=38>38</a></td>\n' +
            '<td>PHY configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=39>39</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=40>40</a></td>\n' +
            '<td>This chapter should describe PHY handling including start/stop callbacks and the various structures used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=41>41</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_conf !Finclude/net/mac80211.h ieee80211_conf_flags</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=42>42</a></td>\n' +
            '<td>Virtual interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=43>43</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=44>44</a></td>\n' +
            '<td>This chapter should describe virtual interface basics that are relevant to the driver (VLANs, MGMT etc are not.) It should explain the use of the add_iface/remove_iface callbacks as well as the interface configuration callbacks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=45>45</a></td>\n' +
            '<td>Things related to AP mode should be discussed there.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=46>46</a></td>\n' +
            '<td>Things related to supporting multiple interfaces should be in the appropriate chapter, a BIG FAT note should be here about this though and the recommendation to allow only a single interface in STA mode at first!</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=47>47</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_vif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=48>48</a></td>\n' +
            '<td>Receive and transmit processing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=49>49</a></td>\n' +
            '<td>what should be here</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=50>50</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=51>51</a></td>\n' +
            '<td>This should describe the receive and transmit paths in mac80211/the drivers as well as transmit status handling.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=52>52</a></td>\n' +
            '<td>Frame format</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=53>53</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Frame format</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=54>54</a></td>\n' +
            '<td>Packet alignment</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=55>55</a></td>\n' +
            '<td>!Pnet/mac80211/rx.c Packet alignment</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=56>56</a></td>\n' +
            '<td>Calling into mac80211 from interrupts</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=57>57</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Calling mac80211 from interrupts</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=58>58</a></td>\n' +
            '<td>functions/definitions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=59>59</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_rx_status !Finclude/net/mac80211.h mac80211_rx_flags !Finclude/net/mac80211.h mac80211_tx_info_flags !Finclude/net/mac80211.h mac80211_tx_control_flags !Finclude/net/mac80211.h mac80211_rate_control_flags !Finclude/net/mac80211.h ieee80211_tx_rate !Finclude/net/mac80211.h ieee80211_tx_info !Finclude/net/mac80211.h ieee80211_tx_info_clear_status !Finclude/net/mac80211.h ieee80211_rx !Finclude/net/mac80211.h ieee80211_rx_ni !Finclude/net/mac80211.h ieee80211_rx_irqsafe !Finclude/net/mac80211.h ieee80211_tx_status !Finclude/net/mac80211.h ieee80211_tx_status_ni !Finclude/net/mac80211.h ieee80211_tx_status_irqsafe !Finclude/net/mac80211.h ieee80211_rts_get !Finclude/net/mac80211.h ieee80211_rts_duration !Finclude/net/mac80211.h ieee80211_ctstoself_get !Finclude/net/mac80211.h ieee80211_ctstoself_duration !Finclude/net/mac80211.h ieee80211_generic_frame_duration !Finclude/net/mac80211.h ieee80211_wake_queue !Finclude/net/mac80211.h ieee80211_stop_queue !Finclude/net/mac80211.h ieee80211_wake_queues !Finclude/net/mac80211.h ieee80211_stop_queues !Finclude/net/mac80211.h ieee80211_queue_stopped</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=60>60</a></td>\n' +
            '<td>Frame filtering</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=61>61</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Frame filtering !Finclude/net/mac80211.h ieee80211_filter_flags</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=62>62</a></td>\n' +
            '<td>The mac80211 workqueue</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=63>63</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h mac80211 workqueue !Finclude/net/mac80211.h ieee80211_queue_work !Finclude/net/mac80211.h ieee80211_queue_delayed_work</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=64>64</a></td>\n' +
            '<td>Information contained within this part of the book is of interest only for advanced interaction of mac80211 with drivers to exploit more hardware capabilities and improve performance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=65>65</a></td>\n' +
            '<td>LED support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=66>66</a></td>\n' +
            '<td>Mac80211 supports various ways of blinking LEDs. Wherever possible, device LEDs should be exposed as LED class devices and hooked up to the appropriate trigger, which will then be triggered appropriately by mac80211.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=67>67</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_get_tx_led_name !Finclude/net/mac80211.h ieee80211_get_rx_led_name !Finclude/net/mac80211.h ieee80211_get_assoc_led_name !Finclude/net/mac80211.h ieee80211_get_radio_led_name !Finclude/net/mac80211.h ieee80211_tpt_blink !Finclude/net/mac80211.h ieee80211_tpt_led_trigger_flags !Finclude/net/mac80211.h ieee80211_create_tpt_led_trigger</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=68>68</a></td>\n' +
            '<td>Hardware crypto acceleration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=69>69</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Hardware crypto acceleration !Finclude/net/mac80211.h set_key_cmd !Finclude/net/mac80211.h ieee80211_key_conf !Finclude/net/mac80211.h ieee80211_key_flags !Finclude/net/mac80211.h ieee80211_get_tkip_p1k !Finclude/net/mac80211.h ieee80211_get_tkip_p1k_iv !Finclude/net/mac80211.h ieee80211_get_tkip_p2k</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=70>70</a></td>\n' +
            '<td>Powersave support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=71>71</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Powersave support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=72>72</a></td>\n' +
            '<td>Beacon filter support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=73>73</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Beacon filter support !Finclude/net/mac80211.h ieee80211_beacon_loss</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=74>74</a></td>\n' +
            '<td>Multiple queues and QoS support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=75>75</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=76>76</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_tx_queue_params</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=77>77</a></td>\n' +
            '<td>Access point mode support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=78>78</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=79>79</a></td>\n' +
            '<td>Some parts of the if_conf should be discussed here instead</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=80>80</a></td>\n' +
            '<td>Insert notes about VLAN interfaces with hw crypto here or in the hw crypto chapter.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=81>81</a></td>\n' +
            '<td>support for powersaving clients</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=82>82</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h AP support for powersaving clients</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=83>83</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_get_buffered_bc !Finclude/net/mac80211.h ieee80211_beacon_get !Finclude/net/mac80211.h ieee80211_sta_eosp !Finclude/net/mac80211.h ieee80211_frame_release_type !Finclude/net/mac80211.h ieee80211_sta_ps_transition !Finclude/net/mac80211.h ieee80211_sta_ps_transition_ni !Finclude/net/mac80211.h ieee80211_sta_set_buffered !Finclude/net/mac80211.h ieee80211_sta_block_awake</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=84>84</a></td>\n' +
            '<td>Supporting multiple virtual interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=85>85</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=86>86</a></td>\n' +
            '<td>Note: WDS with identical MAC address should almost always be OK</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=87>87</a></td>\n' +
            '<td>Insert notes about having multiple virtual interfaces with different MAC addresses here, note which configurations are supported by mac80211, add notes about supporting hw crypto with it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=88>88</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_iterate_active_interfaces !Finclude/net/mac80211.h ieee80211_iterate_active_interfaces_atomic</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=89>89</a></td>\n' +
            '<td>Station handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=90>90</a></td>\n' +
            '<td>TODO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=91>91</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_sta !Finclude/net/mac80211.h sta_notify_cmd !Finclude/net/mac80211.h ieee80211_find_sta !Finclude/net/mac80211.h ieee80211_find_sta_by_ifaddr</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=92>92</a></td>\n' +
            '<td>Hardware scan offload</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=93>93</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=94>94</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_scan_completed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=95>95</a></td>\n' +
            '<td>Aggregation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=96>96</a></td>\n' +
            '<td>TX A-MPDU aggregation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=97>97</a></td>\n' +
            '<td>!Pnet/mac80211/agg-tx.c TX A-MPDU aggregation !Cnet/mac80211/agg-tx.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=98>98</a></td>\n' +
            '<td>RX A-MPDU aggregation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=99>99</a></td>\n' +
            '<td>!Pnet/mac80211/agg-rx.c RX A-MPDU aggregation !Cnet/mac80211/agg-rx.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=100>100</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_ampdu_mlme_action</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=101>101</a></td>\n' +
            '<td>Spatial Multiplexing Powersave (SMPS)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=102>102</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Spatial multiplexing power save !Finclude/net/mac80211.h ieee80211_request_smps !Finclude/net/mac80211.h ieee80211_smps_mode</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=103>103</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=104>104</a></td>\n' +
            '<td>This part of the book describes the rate control algorithm interface and how it relates to mac80211 and drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=105>105</a></td>\n' +
            '<td>Rate Control API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=106>106</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=107>107</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_start_tx_ba_session !Finclude/net/mac80211.h ieee80211_start_tx_ba_cb_irqsafe !Finclude/net/mac80211.h ieee80211_stop_tx_ba_session !Finclude/net/mac80211.h ieee80211_stop_tx_ba_cb_irqsafe !Finclude/net/mac80211.h ieee80211_rate_control_changed !Finclude/net/mac80211.h ieee80211_tx_rate_control !Finclude/net/mac80211.h rate_control_send_low</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=108>108</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=109>109</a></td>\n' +
            '<td>This part of the book describes mac80211 internals.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=110>110</a></td>\n' +
            '<td>Key handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=111>111</a></td>\n' +
            '<td>Key handling basics</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=112>112</a></td>\n' +
            '<td>!Pnet/mac80211/key.c Key handling basics</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=113>113</a></td>\n' +
            '<td>MORE TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=114>114</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=115>115</a></td>\n' +
            '<td>Receive processing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=116>116</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=117>117</a></td>\n' +
            '<td>Transmit processing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=118>118</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=119>119</a></td>\n' +
            '<td>Station info handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=120>120</a></td>\n' +
            '<td>Programming information</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=121>121</a></td>\n' +
            '<td>!Fnet/mac80211/sta_info.h sta_info !Fnet/mac80211/sta_info.h ieee80211_sta_info_flags</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=122>122</a></td>\n' +
            '<td>STA information lifetime rules</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=123>123</a></td>\n' +
            '<td>!Pnet/mac80211/sta_info.c STA information lifetime rules</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=124>124</a></td>\n' +
            '<td>Aggregation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=125>125</a></td>\n' +
            '<td>!Fnet/mac80211/sta_info.h sta_ampdu_mlme !Fnet/mac80211/sta_info.h tid_ampdu_tx !Fnet/mac80211/sta_info.h tid_ampdu_rx</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=126>126</a></td>\n' +
            '<td>Synchronisation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=127>127</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=128>128</a></td>\n' +
            '<td>Locking, lots of RCU</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=129>129</a></td>\n' +
            '<td>Explaining wireless 802.11 networking in the Linux kernel</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=130>130</a></td>\n' +
            '<td>2007-2009</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=131>131</a></td>\n' +
            '<td>Johannes Berg</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=132>132</a></td>\n' +
            '<td>This documentation is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=133>133</a></td>\n' +
            '<td>This documentation is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=134>134</a></td>\n' +
            '<td>You should have received a copy of the GNU General Public License along with this documentation; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=135>135</a></td>\n' +
            '<td>For more details see the file COPYING in the source distribution of Linux.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=136>136</a></td>\n' +
            '<td>These books attempt to give a description of the various subsystems that play a role in 802.11 wireless networking in Linux. Since these books are for kernel developers they attempts to document the structures and functions used in the kernel as well as giving a higher-level overview.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=137>137</a></td>\n' +
            '<td>The reader is expected to be familiar with the 802.11 standard as published by the IEEE in 802.11-2007 (or possibly later versions). References to this standard will be given as "802.11-2007 8.1.5".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=138>138</a></td>\n' +
            '<td>Device registration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=139>139</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Device registration !Finclude/net/cfg80211.h ieee80211_band !Finclude/net/cfg80211.h ieee80211_channel_flags !Finclude/net/cfg80211.h ieee80211_channel !Finclude/net/cfg80211.h ieee80211_rate_flags !Finclude/net/cfg80211.h ieee80211_rate !Finclude/net/cfg80211.h ieee80211_sta_ht_cap !Finclude/net/cfg80211.h ieee80211_supported_band !Finclude/net/cfg80211.h cfg80211_signal_type !Finclude/net/cfg80211.h wiphy_params_flags !Finclude/net/cfg80211.h wiphy_flags !Finclude/net/cfg80211.h wiphy !Finclude/net/cfg80211.h wireless_dev !Finclude/net/cfg80211.h wiphy_new !Finclude/net/cfg80211.h wiphy_register !Finclude/net/cfg80211.h wiphy_unregister !Finclude/net/cfg80211.h wiphy_free !Finclude/net/cfg80211.h wiphy_name !Finclude/net/cfg80211.h wiphy_dev !Finclude/net/cfg80211.h wiphy_priv !Finclude/net/cfg80211.h priv_to_wiphy !Finclude/net/cfg80211.h set_wiphy_dev !Finclude/net/cfg80211.h wdev_priv</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=140>140</a></td>\n' +
            '<td>Actions and configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=141>141</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Actions and configuration !Finclude/net/cfg80211.h cfg80211_ops !Finclude/net/cfg80211.h vif_params !Finclude/net/cfg80211.h key_params !Finclude/net/cfg80211.h survey_info_flags !Finclude/net/cfg80211.h survey_info !Finclude/net/cfg80211.h cfg80211_beacon_data !Finclude/net/cfg80211.h cfg80211_ap_settings !Finclude/net/cfg80211.h station_parameters !Finclude/net/cfg80211.h station_info_flags !Finclude/net/cfg80211.h rate_info_flags !Finclude/net/cfg80211.h rate_info !Finclude/net/cfg80211.h station_info !Finclude/net/cfg80211.h monitor_flags !Finclude/net/cfg80211.h mpath_info_flags !Finclude/net/cfg80211.h mpath_info !Finclude/net/cfg80211.h bss_parameters !Finclude/net/cfg80211.h ieee80211_txq_params !Finclude/net/cfg80211.h cfg80211_crypto_settings !Finclude/net/cfg80211.h cfg80211_auth_request !Finclude/net/cfg80211.h cfg80211_assoc_request !Finclude/net/cfg80211.h cfg80211_deauth_request !Finclude/net/cfg80211.h cfg80211_disassoc_request !Finclude/net/cfg80211.h cfg80211_ibss_params !Finclude/net/cfg80211.h cfg80211_connect_params !Finclude/net/cfg80211.h cfg80211_pmksa !Finclude/net/cfg80211.h cfg80211_rx_mlme_mgmt !Finclude/net/cfg80211.h cfg80211_auth_timeout !Finclude/net/cfg80211.h cfg80211_rx_assoc_resp !Finclude/net/cfg80211.h cfg80211_assoc_timeout !Finclude/net/cfg80211.h cfg80211_tx_mlme_mgmt !Finclude/net/cfg80211.h cfg80211_ibss_joined !Finclude/net/cfg80211.h cfg80211_connect_result !Finclude/net/cfg80211.h cfg80211_roamed !Finclude/net/cfg80211.h cfg80211_disconnected !Finclude/net/cfg80211.h cfg80211_ready_on_channel !Finclude/net/cfg80211.h cfg80211_remain_on_channel_expired !Finclude/net/cfg80211.h cfg80211_new_sta !Finclude/net/cfg80211.h cfg80211_rx_mgmt !Finclude/net/cfg80211.h cfg80211_mgmt_tx_status !Finclude/net/cfg80211.h cfg80211_cqm_rssi_notify !Finclude/net/cfg80211.h cfg80211_cqm_pktloss_notify !Finclude/net/cfg80211.h cfg80211_michael_mic_failure</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=142>142</a></td>\n' +
            '<td>Scanning and BSS list handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=143>143</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Scanning and BSS list handling !Finclude/net/cfg80211.h cfg80211_ssid !Finclude/net/cfg80211.h cfg80211_scan_request !Finclude/net/cfg80211.h cfg80211_scan_done !Finclude/net/cfg80211.h cfg80211_bss !Finclude/net/cfg80211.h cfg80211_inform_bss_width_frame !Finclude/net/cfg80211.h cfg80211_inform_bss_width !Finclude/net/cfg80211.h cfg80211_unlink_bss !Finclude/net/cfg80211.h cfg80211_find_ie !Finclude/net/cfg80211.h ieee80211_bss_get_ie</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=144>144</a></td>\n' +
            '<td>Utility functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=145>145</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Utility functions !Finclude/net/cfg80211.h ieee80211_channel_to_frequency !Finclude/net/cfg80211.h ieee80211_frequency_to_channel !Finclude/net/cfg80211.h ieee80211_get_channel !Finclude/net/cfg80211.h ieee80211_get_response_rate !Finclude/net/cfg80211.h ieee80211_hdrlen !Finclude/net/cfg80211.h ieee80211_get_hdrlen_from_skb !Finclude/net/cfg80211.h ieee80211_radiotap_iterator</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=146>146</a></td>\n' +
            '<td>Data path helpers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=147>147</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Data path helpers !Finclude/net/cfg80211.h ieee80211_data_to_8023 !Finclude/net/cfg80211.h ieee80211_data_from_8023 !Finclude/net/cfg80211.h ieee80211_amsdu_to_8023s !Finclude/net/cfg80211.h cfg80211_classify8021d</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=148>148</a></td>\n' +
            '<td>Regulatory enforcement infrastructure</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=149>149</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Regulatory enforcement infrastructure !Finclude/net/cfg80211.h regulatory_hint !Finclude/net/cfg80211.h wiphy_apply_custom_regulatory !Finclude/net/cfg80211.h freq_reg_info</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=150>150</a></td>\n' +
            '<td>RFkill integration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=151>151</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h RFkill integration !Finclude/net/cfg80211.h wiphy_rfkill_set_hw_state !Finclude/net/cfg80211.h wiphy_rfkill_start_polling !Finclude/net/cfg80211.h wiphy_rfkill_stop_polling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=152>152</a></td>\n' +
            '<td>Test mode</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=153>153</a></td>\n' +
            '<td>!Pinclude/net/cfg80211.h Test mode !Finclude/net/cfg80211.h cfg80211_testmode_alloc_reply_skb !Finclude/net/cfg80211.h cfg80211_testmode_reply !Finclude/net/cfg80211.h cfg80211_testmode_alloc_event_skb !Finclude/net/cfg80211.h cfg80211_testmode_event</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=154>154</a></td>\n' +
            '<td>You should read and understand the information contained within this part of the book while implementing a driver. In some chapters, advanced usage is noted, that may be skipped at first.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=155>155</a></td>\n' +
            '<td>This part of the book only covers station and monitor mode functionality, additional information required to implement the other modes is covered in the second part of the book.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=156>156</a></td>\n' +
            '<td>Basic hardware handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=157>157</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=158>158</a></td>\n' +
            '<td>This chapter shall contain information on getting a hw struct allocated and registered with mac80211.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=159>159</a></td>\n' +
            '<td>Since it is required to allocate rates/modes before registering a hw struct, this chapter shall also contain information on setting up the rate/mode structs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=160>160</a></td>\n' +
            '<td>Additionally, some discussion about the callbacks and the general programming model should be in here, including the definition of ieee80211_ops which will be referred to a lot.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=161>161</a></td>\n' +
            '<td>Finally, a discussion of hardware capabilities should be done with references to other parts of the book.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=162>162</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_hw !Finclude/net/mac80211.h ieee80211_hw_flags !Finclude/net/mac80211.h SET_IEEE80211_DEV !Finclude/net/mac80211.h SET_IEEE80211_PERM_ADDR !Finclude/net/mac80211.h ieee80211_ops !Finclude/net/mac80211.h ieee80211_alloc_hw !Finclude/net/mac80211.h ieee80211_register_hw !Finclude/net/mac80211.h ieee80211_unregister_hw !Finclude/net/mac80211.h ieee80211_free_hw</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=163>163</a></td>\n' +
            '<td>PHY configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=164>164</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=165>165</a></td>\n' +
            '<td>This chapter should describe PHY handling including start/stop callbacks and the various structures used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=166>166</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_conf !Finclude/net/mac80211.h ieee80211_conf_flags</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=167>167</a></td>\n' +
            '<td>Virtual interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=168>168</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=169>169</a></td>\n' +
            '<td>This chapter should describe virtual interface basics that are relevant to the driver (VLANs, MGMT etc are not.) It should explain the use of the add_iface/remove_iface callbacks as well as the interface configuration callbacks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=170>170</a></td>\n' +
            '<td>Things related to AP mode should be discussed there.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=171>171</a></td>\n' +
            '<td>Things related to supporting multiple interfaces should be in the appropriate chapter, a BIG FAT note should be here about this though and the recommendation to allow only a single interface in STA mode at first!</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=172>172</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_vif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=173>173</a></td>\n' +
            '<td>Receive and transmit processing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=174>174</a></td>\n' +
            '<td>what should be here</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=175>175</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=176>176</a></td>\n' +
            '<td>This should describe the receive and transmit paths in mac80211/the drivers as well as transmit status handling.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=177>177</a></td>\n' +
            '<td>Frame format</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=178>178</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Frame format</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=179>179</a></td>\n' +
            '<td>Packet alignment</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=180>180</a></td>\n' +
            '<td>!Pnet/mac80211/rx.c Packet alignment</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=181>181</a></td>\n' +
            '<td>Calling into mac80211 from interrupts</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=182>182</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Calling mac80211 from interrupts</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=183>183</a></td>\n' +
            '<td>functions/definitions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=184>184</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_rx_status !Finclude/net/mac80211.h mac80211_rx_flags !Finclude/net/mac80211.h mac80211_tx_info_flags !Finclude/net/mac80211.h mac80211_tx_control_flags !Finclude/net/mac80211.h mac80211_rate_control_flags !Finclude/net/mac80211.h ieee80211_tx_rate !Finclude/net/mac80211.h ieee80211_tx_info !Finclude/net/mac80211.h ieee80211_tx_info_clear_status !Finclude/net/mac80211.h ieee80211_rx !Finclude/net/mac80211.h ieee80211_rx_ni !Finclude/net/mac80211.h ieee80211_rx_irqsafe !Finclude/net/mac80211.h ieee80211_tx_status !Finclude/net/mac80211.h ieee80211_tx_status_ni !Finclude/net/mac80211.h ieee80211_tx_status_irqsafe !Finclude/net/mac80211.h ieee80211_rts_get !Finclude/net/mac80211.h ieee80211_rts_duration !Finclude/net/mac80211.h ieee80211_ctstoself_get !Finclude/net/mac80211.h ieee80211_ctstoself_duration !Finclude/net/mac80211.h ieee80211_generic_frame_duration !Finclude/net/mac80211.h ieee80211_wake_queue !Finclude/net/mac80211.h ieee80211_stop_queue !Finclude/net/mac80211.h ieee80211_wake_queues !Finclude/net/mac80211.h ieee80211_stop_queues !Finclude/net/mac80211.h ieee80211_queue_stopped</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=185>185</a></td>\n' +
            '<td>Frame filtering</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=186>186</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Frame filtering !Finclude/net/mac80211.h ieee80211_filter_flags</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=187>187</a></td>\n' +
            '<td>The mac80211 workqueue</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=188>188</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h mac80211 workqueue !Finclude/net/mac80211.h ieee80211_queue_work !Finclude/net/mac80211.h ieee80211_queue_delayed_work</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=189>189</a></td>\n' +
            '<td>Information contained within this part of the book is of interest only for advanced interaction of mac80211 with drivers to exploit more hardware capabilities and improve performance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=190>190</a></td>\n' +
            '<td>LED support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=191>191</a></td>\n' +
            '<td>Mac80211 supports various ways of blinking LEDs. Wherever possible, device LEDs should be exposed as LED class devices and hooked up to the appropriate trigger, which will then be triggered appropriately by mac80211.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=192>192</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_get_tx_led_name !Finclude/net/mac80211.h ieee80211_get_rx_led_name !Finclude/net/mac80211.h ieee80211_get_assoc_led_name !Finclude/net/mac80211.h ieee80211_get_radio_led_name !Finclude/net/mac80211.h ieee80211_tpt_blink !Finclude/net/mac80211.h ieee80211_tpt_led_trigger_flags !Finclude/net/mac80211.h ieee80211_create_tpt_led_trigger</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=193>193</a></td>\n' +
            '<td>Hardware crypto acceleration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=194>194</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Hardware crypto acceleration !Finclude/net/mac80211.h set_key_cmd !Finclude/net/mac80211.h ieee80211_key_conf !Finclude/net/mac80211.h ieee80211_key_flags !Finclude/net/mac80211.h ieee80211_get_tkip_p1k !Finclude/net/mac80211.h ieee80211_get_tkip_p1k_iv !Finclude/net/mac80211.h ieee80211_get_tkip_p2k</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=195>195</a></td>\n' +
            '<td>Powersave support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=196>196</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Powersave support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=197>197</a></td>\n' +
            '<td>Beacon filter support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=198>198</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Beacon filter support !Finclude/net/mac80211.h ieee80211_beacon_loss</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=199>199</a></td>\n' +
            '<td>Multiple queues and QoS support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=200>200</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=201>201</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_tx_queue_params</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=202>202</a></td>\n' +
            '<td>Access point mode support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=203>203</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=204>204</a></td>\n' +
            '<td>Some parts of the if_conf should be discussed here instead</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=205>205</a></td>\n' +
            '<td>Insert notes about VLAN interfaces with hw crypto here or in the hw crypto chapter.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=206>206</a></td>\n' +
            '<td>support for powersaving clients</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=207>207</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h AP support for powersaving clients</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=208>208</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_get_buffered_bc !Finclude/net/mac80211.h ieee80211_beacon_get !Finclude/net/mac80211.h ieee80211_sta_eosp !Finclude/net/mac80211.h ieee80211_frame_release_type !Finclude/net/mac80211.h ieee80211_sta_ps_transition !Finclude/net/mac80211.h ieee80211_sta_ps_transition_ni !Finclude/net/mac80211.h ieee80211_sta_set_buffered !Finclude/net/mac80211.h ieee80211_sta_block_awake</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=209>209</a></td>\n' +
            '<td>Supporting multiple virtual interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=210>210</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=211>211</a></td>\n' +
            '<td>Note: WDS with identical MAC address should almost always be OK</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=212>212</a></td>\n' +
            '<td>Insert notes about having multiple virtual interfaces with different MAC addresses here, note which configurations are supported by mac80211, add notes about supporting hw crypto with it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=213>213</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_iterate_active_interfaces !Finclude/net/mac80211.h ieee80211_iterate_active_interfaces_atomic</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=214>214</a></td>\n' +
            '<td>Station handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=215>215</a></td>\n' +
            '<td>TODO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=216>216</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_sta !Finclude/net/mac80211.h sta_notify_cmd !Finclude/net/mac80211.h ieee80211_find_sta !Finclude/net/mac80211.h ieee80211_find_sta_by_ifaddr</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=217>217</a></td>\n' +
            '<td>Hardware scan offload</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=218>218</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=219>219</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_scan_completed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=220>220</a></td>\n' +
            '<td>Aggregation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=221>221</a></td>\n' +
            '<td>TX A-MPDU aggregation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=222>222</a></td>\n' +
            '<td>!Pnet/mac80211/agg-tx.c TX A-MPDU aggregation !Cnet/mac80211/agg-tx.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=223>223</a></td>\n' +
            '<td>RX A-MPDU aggregation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=224>224</a></td>\n' +
            '<td>!Pnet/mac80211/agg-rx.c RX A-MPDU aggregation !Cnet/mac80211/agg-rx.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=225>225</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_ampdu_mlme_action</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=226>226</a></td>\n' +
            '<td>Spatial Multiplexing Powersave (SMPS)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=227>227</a></td>\n' +
            '<td>!Pinclude/net/mac80211.h Spatial multiplexing power save !Finclude/net/mac80211.h ieee80211_request_smps !Finclude/net/mac80211.h ieee80211_smps_mode</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=228>228</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=229>229</a></td>\n' +
            '<td>This part of the book describes the rate control algorithm interface and how it relates to mac80211 and drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=230>230</a></td>\n' +
            '<td>Rate Control API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=231>231</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=232>232</a></td>\n' +
            '<td>!Finclude/net/mac80211.h ieee80211_start_tx_ba_session !Finclude/net/mac80211.h ieee80211_start_tx_ba_cb_irqsafe !Finclude/net/mac80211.h ieee80211_stop_tx_ba_session !Finclude/net/mac80211.h ieee80211_stop_tx_ba_cb_irqsafe !Finclude/net/mac80211.h ieee80211_rate_control_changed !Finclude/net/mac80211.h ieee80211_tx_rate_control !Finclude/net/mac80211.h rate_control_send_low</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=233>233</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=234>234</a></td>\n' +
            '<td>This part of the book describes mac80211 internals.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=235>235</a></td>\n' +
            '<td>Key handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=236>236</a></td>\n' +
            '<td>Key handling basics</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=237>237</a></td>\n' +
            '<td>!Pnet/mac80211/key.c Key handling basics</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=238>238</a></td>\n' +
            '<td>MORE TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=239>239</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=240>240</a></td>\n' +
            '<td>Receive processing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=241>241</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=242>242</a></td>\n' +
            '<td>Transmit processing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=243>243</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=244>244</a></td>\n' +
            '<td>Station info handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=245>245</a></td>\n' +
            '<td>Programming information</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=246>246</a></td>\n' +
            '<td>!Fnet/mac80211/sta_info.h sta_info !Fnet/mac80211/sta_info.h ieee80211_sta_info_flags</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=247>247</a></td>\n' +
            '<td>STA information lifetime rules</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=248>248</a></td>\n' +
            '<td>!Pnet/mac80211/sta_info.c STA information lifetime rules</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=249>249</a></td>\n' +
            '<td>Aggregation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=250>250</a></td>\n' +
            '<td>!Fnet/mac80211/sta_info.h sta_ampdu_mlme !Fnet/mac80211/sta_info.h tid_ampdu_tx !Fnet/mac80211/sta_info.h tid_ampdu_rx</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=251>251</a></td>\n' +
            '<td>Synchronisation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=252>252</a></td>\n' +
            '<td>TBD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=253>253</a></td>\n' +
            '<td>Locking, lots of RCU</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=254>254</a></td>\n' +
            '<td>Management of Cards and Devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=255>255</a></td>\n' +
            '<td>Card Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=256>256</a></td>\n' +
            '<td>!Esound/core/init.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=257>257</a></td>\n' +
            '<td>Device Components</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=258>258</a></td>\n' +
            '<td>!Esound/core/device.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=259>259</a></td>\n' +
            '<td>Module requests and Device File Entries</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=260>260</a></td>\n' +
            '<td>!Esound/core/sound.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=261>261</a></td>\n' +
            '<td>Memory Management Helpers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=262>262</a></td>\n' +
            '<td>!Esound/core/memory.c !Esound/core/memalloc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=263>263</a></td>\n' +
            '<td>PCM API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=264>264</a></td>\n' +
            '<td>PCM Core</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=265>265</a></td>\n' +
            '<td>!Esound/core/pcm.c !Esound/core/pcm_lib.c !Esound/core/pcm_native.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=266>266</a></td>\n' +
            '<td>PCM Format Helpers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=267>267</a></td>\n' +
            '<td>!Esound/core/pcm_misc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=268>268</a></td>\n' +
            '<td>PCM Memory Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=269>269</a></td>\n' +
            '<td>!Esound/core/pcm_memory.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=270>270</a></td>\n' +
            '<td>Control/Mixer API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=271>271</a></td>\n' +
            '<td>General Control Interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=272>272</a></td>\n' +
            '<td>!Esound/core/control.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=273>273</a></td>\n' +
            '<td>AC97 Codec API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=274>274</a></td>\n' +
            '<td>!Esound/pci/ac97/ac97_codec.c !Esound/pci/ac97/ac97_pcm.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=275>275</a></td>\n' +
            '<td>Virtual Master Control API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=276>276</a></td>\n' +
            '<td>!Esound/core/vmaster.c !Iinclude/sound/control.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=277>277</a></td>\n' +
            '<td>MIDI API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=278>278</a></td>\n' +
            '<td>Raw MIDI API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=279>279</a></td>\n' +
            '<td>!Esound/core/rawmidi.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=280>280</a></td>\n' +
            '<td>MPU401-UART API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=281>281</a></td>\n' +
            '<td>!Esound/drivers/mpu401/mpu401_uart.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=282>282</a></td>\n' +
            '<td>Proc Info API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=283>283</a></td>\n' +
            '<td>Proc Info Interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=284>284</a></td>\n' +
            '<td>!Esound/core/info.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=285>285</a></td>\n' +
            '<td>Miscellaneous Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=286>286</a></td>\n' +
            '<td>Hardware-Dependent Devices API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=287>287</a></td>\n' +
            '<td>!Esound/core/hwdep.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=288>288</a></td>\n' +
            '<td>Jack Abstraction Layer API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=289>289</a></td>\n' +
            '<td>!Esound/core/jack.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=290>290</a></td>\n' +
            '<td>ISA DMA Helpers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=291>291</a></td>\n' +
            '<td>!Esound/core/isadma.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=292>292</a></td>\n' +
            '<td>Other Helper Macros</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=293>293</a></td>\n' +
            '<td>!Iinclude/sound/core.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=294>294</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=295>295</a></td>\n' +
            '<td>debugobjects is a generic infrastructure to track the life time of kernel objects and validate the operations on those.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=296>296</a></td>\n' +
            '<td>debugobjects is useful to check for the following error patterns:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=297>297</a></td>\n' +
            '<td>    Activation of uninitialized objects</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=298>298</a></td>\n' +
            '<td>    Initialization of active objects</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=299>299</a></td>\n' +
            '<td>    Usage of freed/destroyed objects</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=300>300</a></td>\n' +
            '<td>debugobjects is not changing the data structure of the real object so it can be compiled in with a minimal runtime impact and enabled on demand with a kernel command line option.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=301>301</a></td>\n' +
            '<td>Howto use debugobjects</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=302>302</a></td>\n' +
            '<td>A kernel subsystem needs to provide a data structure which describes the object type and add calls into the debug code at appropriate places. The data structure to describe the object type needs at minimum the name of the object type. Optional functions can and should be provided to fixup detected problems so the kernel can continue to work and the debug information can be retrieved from a live system instead of hard core debugging with serial consoles and stack trace transcripts from the monitor.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=303>303</a></td>\n' +
            '<td>The debug calls provided by debugobjects are:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=304>304</a></td>\n' +
            '<td>    debug_object_init</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=305>305</a></td>\n' +
            '<td>    debug_object_init_on_stack</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=306>306</a></td>\n' +
            '<td>    debug_object_activate</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=307>307</a></td>\n' +
            '<td>    debug_object_deactivate</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=308>308</a></td>\n' +
            '<td>    debug_object_destroy</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=309>309</a></td>\n' +
            '<td>    debug_object_free</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=310>310</a></td>\n' +
            '<td>    debug_object_assert_init</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=311>311</a></td>\n' +
            '<td>Each of these functions takes the address of the real object and a pointer to the object type specific debug description structure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=312>312</a></td>\n' +
            '<td>Each detected error is reported in the statistics and a limited number of errors are printk' + "'" + 'ed including a full stack trace.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=313>313</a></td>\n' +
            '<td>The statistics are available via /sys/kernel/debug/debug_objects/stats. They provide information about the number of warnings and the number of successful fixups along with information about the usage of the internal tracking objects and the state of the internal tracking objects pool.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=314>314</a></td>\n' +
            '<td>Debug functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=315>315</a></td>\n' +
            '<td>Debug object function reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=316>316</a></td>\n' +
            '<td>!Elib/debugobjects.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=317>317</a></td>\n' +
            '<td>debug_object_init</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=318>318</a></td>\n' +
            '<td>This function is called whenever the initialization function of a real object is called.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=319>319</a></td>\n' +
            '<td>When the real object is already tracked by debugobjects it is checked, whether the object can be initialized. Initializing is not allowed for active and destroyed objects. When debugobjects detects an error, then it calls the fixup_init function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real initialization of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=320>320</a></td>\n' +
            '<td>When the real object is not yet tracked by debugobjects, debugobjects allocates a tracker object for the real object and sets the tracker object state to ODEBUG_STATE_INIT. It verifies that the object is not on the callers stack. If it is on the callers stack then a limited number of warnings including a full stack trace is printk' + "'" + 'ed. The calling code must use debug_object_init_on_stack() and remove the object before leaving the function which allocated it. See next section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=321>321</a></td>\n' +
            '<td>debug_object_init_on_stack</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=322>322</a></td>\n' +
            '<td>This function is called whenever the initialization function of a real object which resides on the stack is called.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=323>323</a></td>\n' +
            '<td>When the real object is already tracked by debugobjects it is checked, whether the object can be initialized. Initializing is not allowed for active and destroyed objects. When debugobjects detects an error, then it calls the fixup_init function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real initialization of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=324>324</a></td>\n' +
            '<td>When the real object is not yet tracked by debugobjects debugobjects allocates a tracker object for the real object and sets the tracker object state to ODEBUG_STATE_INIT. It verifies that the object is on the callers stack.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=325>325</a></td>\n' +
            '<td>An object which is on the stack must be removed from the tracker by calling debug_object_free() before the function which allocates the object returns. Otherwise we keep track of stale objects.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=326>326</a></td>\n' +
            '<td>debug_object_activate</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=327>327</a></td>\n' +
            '<td>This function is called whenever the activation function of a real object is called.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=328>328</a></td>\n' +
            '<td>When the real object is already tracked by debugobjects it is checked, whether the object can be activated. Activating is not allowed for active and destroyed objects. When debugobjects detects an error, then it calls the fixup_activate function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real activation of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=329>329</a></td>\n' +
            '<td>When the real object is not yet tracked by debugobjects then the fixup_activate function is called if available. This is necessary to allow the legitimate activation of statically allocated and initialized objects. The fixup function checks whether the object is valid and calls the debug_objects_init() function to initialize the tracking of this object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=330>330</a></td>\n' +
            '<td>When the activation is legitimate, then the state of the associated tracker object is set to ODEBUG_STATE_ACTIVE.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=331>331</a></td>\n' +
            '<td>debug_object_deactivate</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=332>332</a></td>\n' +
            '<td>This function is called whenever the deactivation function of a real object is called.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=333>333</a></td>\n' +
            '<td>When the real object is tracked by debugobjects it is checked, whether the object can be deactivated. Deactivating is not allowed for untracked or destroyed objects.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=334>334</a></td>\n' +
            '<td>When the deactivation is legitimate, then the state of the associated tracker object is set to ODEBUG_STATE_INACTIVE.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=335>335</a></td>\n' +
            '<td>debug_object_destroy</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=336>336</a></td>\n' +
            '<td>This function is called to mark an object destroyed. This is useful to prevent the usage of invalid objects, which are still available in memory: either statically allocated objects or objects which are freed later.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=337>337</a></td>\n' +
            '<td>When the real object is tracked by debugobjects it is checked, whether the object can be destroyed. Destruction is not allowed for active and destroyed objects. When debugobjects detects an error, then it calls the fixup_destroy function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real destruction of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=338>338</a></td>\n' +
            '<td>When the destruction is legitimate, then the state of the associated tracker object is set to ODEBUG_STATE_DESTROYED.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=339>339</a></td>\n' +
            '<td>debug_object_free</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=340>340</a></td>\n' +
            '<td>This function is called before an object is freed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=341>341</a></td>\n' +
            '<td>When the real object is tracked by debugobjects it is checked, whether the object can be freed. Free is not allowed for active objects. When debugobjects detects an error, then it calls the fixup_free function of the object type description structure if provided by the caller. The fixup function can correct the problem before the real free of the object happens. E.g. it can deactivate an active object in order to prevent damage to the subsystem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=342>342</a></td>\n' +
            '<td>Note that debug_object_free removes the object from the tracker. Later usage of the object is detected by the other debug checks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=343>343</a></td>\n' +
            '<td>debug_object_assert_init</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=344>344</a></td>\n' +
            '<td>This function is called to assert that an object has been initialized.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=345>345</a></td>\n' +
            '<td>When the real object is not tracked by debugobjects, it calls fixup_assert_init of the object type description structure provided by the caller, with the hardcoded object state ODEBUG_NOT_AVAILABLE. The fixup function can correct the problem by calling debug_object_init and other specific initializing functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=346>346</a></td>\n' +
            '<td>When the real object is already tracked by debugobjects it is ignored.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=347>347</a></td>\n' +
            '<td>Fixup functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=348>348</a></td>\n' +
            '<td>Debug object type description structure</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=349>349</a></td>\n' +
            '<td>!Iinclude/linux/debugobjects.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=350>350</a></td>\n' +
            '<td>fixup_init</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=351>351</a></td>\n' +
            '<td>This function is called from the debug code whenever a problem in debug_object_init is detected. The function takes the address of the object and the state which is currently recorded in the tracker.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=352>352</a></td>\n' +
            '<td>Called from debug_object_init when the object state is:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=353>353</a></td>\n' +
            '<td>    ODEBUG_STATE_ACTIVE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=354>354</a></td>\n' +
            '<td>The function returns 1 when the fixup was successful, otherwise 0. The return value is used to update the statistics.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=355>355</a></td>\n' +
            '<td>Note, that the function needs to call the debug_object_init() function again, after the damage has been repaired in order to keep the state consistent.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=356>356</a></td>\n' +
            '<td>fixup_activate</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=357>357</a></td>\n' +
            '<td>This function is called from the debug code whenever a problem in debug_object_activate is detected.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=358>358</a></td>\n' +
            '<td>Called from debug_object_activate when the object state is:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=359>359</a></td>\n' +
            '<td>    ODEBUG_STATE_NOTAVAILABLE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=360>360</a></td>\n' +
            '<td>    ODEBUG_STATE_ACTIVE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=361>361</a></td>\n' +
            '<td>The function returns 1 when the fixup was successful, otherwise 0. The return value is used to update the statistics.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=362>362</a></td>\n' +
            '<td>Note that the function needs to call the debug_object_activate() function again after the damage has been repaired in order to keep the state consistent.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=363>363</a></td>\n' +
            '<td>The activation of statically initialized objects is a special case. When debug_object_activate() has no tracked object for this object address then fixup_activate() is called with object state ODEBUG_STATE_NOTAVAILABLE. The fixup function needs to check whether this is a legitimate case of a statically initialized object or not. In case it is it calls debug_object_init() and debug_object_activate() to make the object known to the tracker and marked active. In this case the function should return 0 because this is not a real fixup.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=364>364</a></td>\n' +
            '<td>fixup_destroy</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=365>365</a></td>\n' +
            '<td>This function is called from the debug code whenever a problem in debug_object_destroy is detected.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=366>366</a></td>\n' +
            '<td>Called from debug_object_destroy when the object state is:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=367>367</a></td>\n' +
            '<td>    ODEBUG_STATE_ACTIVE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=368>368</a></td>\n' +
            '<td>The function returns 1 when the fixup was successful, otherwise 0. The return value is used to update the statistics.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=369>369</a></td>\n' +
            '<td>fixup_free</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=370>370</a></td>\n' +
            '<td>This function is called from the debug code whenever a problem in debug_object_free is detected. Further it can be called from the debug checks in kfree/vfree, when an active object is detected from the debug_check_no_obj_freed() sanity checks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=371>371</a></td>\n' +
            '<td>Called from debug_object_free() or debug_check_no_obj_freed() when the object state is:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=372>372</a></td>\n' +
            '<td>    ODEBUG_STATE_ACTIVE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=373>373</a></td>\n' +
            '<td>The function returns 1 when the fixup was successful, otherwise 0. The return value is used to update the statistics.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=374>374</a></td>\n' +
            '<td>fixup_assert_init</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=375>375</a></td>\n' +
            '<td>This function is called from the debug code whenever a problem in debug_object_assert_init is detected.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=376>376</a></td>\n' +
            '<td>Called from debug_object_assert_init() with a hardcoded state ODEBUG_STATE_NOTAVAILABLE when the object is not found in the debug bucket.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=377>377</a></td>\n' +
            '<td>The function returns 1 when the fixup was successful, otherwise 0. The return value is used to update the statistics.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=378>378</a></td>\n' +
            '<td>Note, this function should make sure debug_object_init() is called before returning.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=379>379</a></td>\n' +
            '<td>The handling of statically initialized objects is a special case. The fixup function should check if this is a legitimate case of a statically initialized object or not. In this case only debug_object_init() should be called to make the object known to the tracker. Then the function should return 0 because this is not a real fixup.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=380>380</a></td>\n' +
            '<td>Known Bugs And Assumptions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=381>381</a></td>\n' +
            '<td>None (knock on wood).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=382>382</a></td>\n' +
            '<td>Driver Basics</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=383>383</a></td>\n' +
            '<td>Driver Entry and Exit points</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=384>384</a></td>\n' +
            '<td>!Iinclude/linux/init.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=385>385</a></td>\n' +
            '<td>Atomic and pointer manipulation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=386>386</a></td>\n' +
            '<td>!Iarch/x86/include/asm/atomic.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=387>387</a></td>\n' +
            '<td>Delaying, scheduling, and timer routines</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=388>388</a></td>\n' +
            '<td>!Iinclude/linux/sched.h !Ekernel/sched/core.c !Ikernel/sched/cpupri.c !Ikernel/sched/fair.c !Iinclude/linux/completion.h !Ekernel/timer.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=389>389</a></td>\n' +
            '<td>Wait queues and Wake events</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=390>390</a></td>\n' +
            '<td>!Iinclude/linux/wait.h !Ekernel/sched/wait.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=391>391</a></td>\n' +
            '<td>High-resolution timers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=392>392</a></td>\n' +
            '<td>!Iinclude/linux/ktime.h !Iinclude/linux/hrtimer.h !Ekernel/hrtimer.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=393>393</a></td>\n' +
            '<td>Workqueues and Kevents</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=394>394</a></td>\n' +
            '<td>!Ekernel/workqueue.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=395>395</a></td>\n' +
            '<td>Internal Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=396>396</a></td>\n' +
            '<td>!Ikernel/exit.c !Ikernel/signal.c !Iinclude/linux/kthread.h !Ekernel/kthread.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=397>397</a></td>\n' +
            '<td>Kernel objects manipulation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=398>398</a></td>\n' +
            '<td>!Elib/kobject.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=399>399</a></td>\n' +
            '<td>Kernel utility functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=400>400</a></td>\n' +
            '<td>!Iinclude/linux/kernel.h !Ekernel/printk/printk.c !Ekernel/panic.c !Ekernel/sys.c !Ekernel/rcu/srcu.c !Ekernel/rcu/tree.c !Ekernel/rcu/tree_plugin.h !Ekernel/rcu/update.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=401>401</a></td>\n' +
            '<td>Device Resource Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=402>402</a></td>\n' +
            '<td>!Edrivers/base/devres.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=403>403</a></td>\n' +
            '<td>Device drivers infrastructure</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=404>404</a></td>\n' +
            '<td>The Basic Device Driver-Model Structures</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=405>405</a></td>\n' +
            '<td>!Iinclude/linux/device.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=406>406</a></td>\n' +
            '<td>Device Drivers Base</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=407>407</a></td>\n' +
            '<td>!Idrivers/base/init.c !Edrivers/base/driver.c !Edrivers/base/core.c !Edrivers/base/syscore.c !Edrivers/base/class.c !Idrivers/base/node.c !Edrivers/base/firmware_class.c !Edrivers/base/transport_class.c !Edrivers/base/dd.c !Iinclude/linux/platform_device.h !Edrivers/base/platform.c !Edrivers/base/bus.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=408>408</a></td>\n' +
            '<td>Device Drivers DMA Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=409>409</a></td>\n' +
            '<td>!Edrivers/base/dma-buf.c !Edrivers/base/reservation.c !Iinclude/linux/reservation.h !Edrivers/base/dma-coherent.c !Edrivers/base/dma-mapping.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=410>410</a></td>\n' +
            '<td>Device Drivers Power Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=411>411</a></td>\n' +
            '<td>!Edrivers/base/power/main.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=412>412</a></td>\n' +
            '<td>Device Drivers ACPI Support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=413>413</a></td>\n' +
            '<td>!Edrivers/acpi/scan.c !Idrivers/acpi/scan.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=414>414</a></td>\n' +
            '<td>Device drivers PnP support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=415>415</a></td>\n' +
            '<td>!Idrivers/pnp/core.c !Edrivers/pnp/card.c !Idrivers/pnp/driver.c !Edrivers/pnp/manager.c !Edrivers/pnp/support.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=416>416</a></td>\n' +
            '<td>Userspace IO devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=417>417</a></td>\n' +
            '<td>!Edrivers/uio/uio.c !Iinclude/linux/uio_driver.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=418>418</a></td>\n' +
            '<td>Parallel Port Devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=419>419</a></td>\n' +
            '<td>!Iinclude/linux/parport.h !Edrivers/parport/ieee1284.c !Edrivers/parport/share.c !Idrivers/parport/daisy.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=420>420</a></td>\n' +
            '<td>Message-based devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=421>421</a></td>\n' +
            '<td>Fusion message devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=422>422</a></td>\n' +
            '<td>!Edrivers/message/fusion/mptbase.c !Idrivers/message/fusion/mptbase.c !Edrivers/message/fusion/mptscsih.c !Idrivers/message/fusion/mptscsih.c !Idrivers/message/fusion/mptctl.c !Idrivers/message/fusion/mptspi.c !Idrivers/message/fusion/mptfc.c !Idrivers/message/fusion/mptlan.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=423>423</a></td>\n' +
            '<td>I2O message devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=424>424</a></td>\n' +
            '<td>!Iinclude/linux/i2o.h !Idrivers/message/i2o/core.h !Edrivers/message/i2o/iop.c !Idrivers/message/i2o/iop.c !Idrivers/message/i2o/config-osm.c !Edrivers/message/i2o/exec-osm.c !Idrivers/message/i2o/exec-osm.c !Idrivers/message/i2o/bus-osm.c !Edrivers/message/i2o/device.c !Idrivers/message/i2o/device.c !Idrivers/message/i2o/driver.c !Idrivers/message/i2o/pci.c !Idrivers/message/i2o/i2o_block.c !Idrivers/message/i2o/i2o_scsi.c !Idrivers/message/i2o/i2o_proc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=425>425</a></td>\n' +
            '<td>Sound Devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=426>426</a></td>\n' +
            '<td>!Iinclude/sound/core.h !Esound/sound_core.c !Iinclude/sound/pcm.h !Esound/core/pcm.c !Esound/core/device.c !Esound/core/info.c !Esound/core/rawmidi.c !Esound/core/sound.c !Esound/core/memory.c !Esound/core/pcm_memory.c !Esound/core/init.c !Esound/core/isadma.c !Esound/core/control.c !Esound/core/pcm_lib.c !Esound/core/hwdep.c !Esound/core/pcm_native.c !Esound/core/memalloc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=427>427</a></td>\n' +
            '<td>16x50 UART Driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=428>428</a></td>\n' +
            '<td>!Edrivers/tty/serial/serial_core.c !Edrivers/tty/serial/8250/8250_core.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=429>429</a></td>\n' +
            '<td>Frame Buffer Library</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=430>430</a></td>\n' +
            '<td>The frame buffer drivers depend heavily on four data structures. These structures are declared in include/linux/fb.h. They are fb_info, fb_var_screeninfo, fb_fix_screeninfo and fb_monospecs. The last three can be made available to and from userland.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=431>431</a></td>\n' +
            '<td>fb_info defines the current state of a particular video card. Inside fb_info, there exists a fb_ops structure which is a collection of needed functions to make fbdev and fbcon work. fb_info is only visible to the kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=432>432</a></td>\n' +
            '<td>fb_var_screeninfo is used to describe the features of a video card that are user defined. With fb_var_screeninfo, things such as depth and the resolution may be defined.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=433>433</a></td>\n' +
            '<td>The next structure is fb_fix_screeninfo. This defines the properties of a card that are created when a mode is set and can' + "'" + 't be changed otherwise. A good example of this is the start of the frame buffer memory. This "locks" the address of the frame buffer memory, so that it cannot be changed or moved.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=434>434</a></td>\n' +
            '<td>The last structure is fb_monospecs. In the old API, there was little importance for fb_monospecs. This allowed for forbidden things such as setting a mode of 800x600 on a fix frequency monitor. With the new API, fb_monospecs prevents such things, and if used correctly, can prevent a monitor from being cooked. fb_monospecs will not be useful until kernels 2.5.x.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=435>435</a></td>\n' +
            '<td>Frame Buffer Memory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=436>436</a></td>\n' +
            '<td>!Edrivers/video/fbmem.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=437>437</a></td>\n' +
            '<td>Frame Buffer Colormap</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=438>438</a></td>\n' +
            '<td>!Edrivers/video/fbcmap.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=439>439</a></td>\n' +
            '<td>Frame Buffer Video Mode Database</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=440>440</a></td>\n' +
            '<td>!Idrivers/video/modedb.c !Edrivers/video/modedb.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=441>441</a></td>\n' +
            '<td>Frame Buffer Macintosh Video Mode Database</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=442>442</a></td>\n' +
            '<td>!Edrivers/video/macmodes.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=443>443</a></td>\n' +
            '<td>Frame Buffer Fonts</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=444>444</a></td>\n' +
            '<td>Refer to the file lib/fonts/fonts.c for more information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=445>445</a></td>\n' +
            '<td>Input Subsystem</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=446>446</a></td>\n' +
            '<td>Input core</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=447>447</a></td>\n' +
            '<td>!Iinclude/linux/input.h !Edrivers/input/input.c !Edrivers/input/ff-core.c !Edrivers/input/ff-memless.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=448>448</a></td>\n' +
            '<td>Multitouch Library</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=449>449</a></td>\n' +
            '<td>!Iinclude/linux/input/mt.h !Edrivers/input/input-mt.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=450>450</a></td>\n' +
            '<td>Polled input devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=451>451</a></td>\n' +
            '<td>!Iinclude/linux/input-polldev.h !Edrivers/input/input-polldev.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=452>452</a></td>\n' +
            '<td>Matrix keyboars/keypads</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=453>453</a></td>\n' +
            '<td>!Iinclude/linux/input/matrix_keypad.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=454>454</a></td>\n' +
            '<td>Sparse keymap support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=455>455</a></td>\n' +
            '<td>!Iinclude/linux/input/sparse-keymap.h !Edrivers/input/sparse-keymap.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=456>456</a></td>\n' +
            '<td>Serial Peripheral Interface (SPI)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=457>457</a></td>\n' +
            '<td>SPI is the "Serial Peripheral Interface", widely used with embedded systems because it is a simple and efficient interface: basically a multiplexed shift register. Its three signal wires hold a clock (SCK, often in the range of 1-20 MHz), a "Master Out, Slave In" (MOSI) data line, and a "Master In, Slave Out" (MISO) data line. SPI is a full duplex protocol; for each bit shifted out the MOSI line (one per clock) another is shifted in on the MISO line. Those bits are assembled into words of various sizes on the way to and from system memory. An additional chipselect line is usually active-low (nCS); four signals are normally used for each peripheral, plus sometimes an interrupt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=458>458</a></td>\n' +
            '<td>The SPI bus facilities listed here provide a generalized interface to declare SPI busses and devices, manage them according to the standard Linux driver model, and perform input/output operations. At this time, only "master" side interfaces are supported, where Linux talks to SPI peripherals and does not implement such a peripheral itself. (Interfaces to support implementing SPI slaves would necessarily look different.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=459>459</a></td>\n' +
            '<td>The programming interface is structured around two kinds of driver, and two kinds of device. A "Controller Driver" abstracts the controller hardware, which may be as simple as a set of GPIO pins or as complex as a pair of FIFOs connected to dual DMA engines on the other side of the SPI shift register (maximizing throughput). Such drivers bridge between whatever bus they sit on (often the platform bus) and SPI, and expose the SPI side of their device as a struct spi_master. SPI devices are children of that master, represented as a struct spi_device and manufactured from struct spi_board_info descriptors which are usually provided by board-specific initialization code. A struct spi_driver is called a "Protocol Driver", and is bound to a spi_device using normal driver model calls.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=460>460</a></td>\n' +
            '<td>The I/O model is a set of queued messages. Protocol drivers submit one or more struct spi_message objects, which are processed and completed asynchronously. (There are synchronous wrappers, however.) Messages are built from one or more struct spi_transfer objects, each of which wraps a full duplex SPI transfer. A variety of protocol tweaking options are needed, because different chips adopt very different policies for how they use the bits transferred with SPI.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=461>461</a></td>\n' +
            '<td>!Iinclude/linux/spi/spi.h !Fdrivers/spi/spi.c spi_register_board_info !Edrivers/spi/spi.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=462>462</a></td>\n' +
            '<td>I2C and SMBus Subsystem</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=463>463</a></td>\n' +
            '<td>I2C (or without fancy typography, "I2C") is an acronym for the "Inter-IC" bus, a simple bus protocol which is widely used where low data rate communications suffice. Since it' + "'" + 's also a licensed trademark, some vendors use another name (such as "Two-Wire Interface", TWI) for the same bus. I2C only needs two signals (SCL for clock, SDA for data), conserving board real estate and minimizing signal quality issues. Most I2C devices use seven bit addresses, and bus speeds of up to 400 kHz; there' + "'" + 's a high speed extension (3.4 MHz) that' + "'" + 's not yet found wide use. I2C is a multi-master bus; open drain signaling is used to arbitrate between masters, as well as to handshake and to synchronize clocks from slower clients.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=464>464</a></td>\n' +
            '<td>The Linux I2C programming interfaces support only the master side of bus interactions, not the slave side. The programming interface is structured around two kinds of driver, and two kinds of device. An I2C "Adapter Driver" abstracts the controller hardware; it binds to a physical device (perhaps a PCI device or platform_device) and exposes a struct i2c_adapter representing each I2C bus segment it manages. On each I2C bus segment will be I2C devices represented by a struct i2c_client. Those devices will be bound to a struct i2c_driver, which should follow the standard Linux driver model. (At this writing, a legacy model is more widely used.) There are functions to perform various I2C protocol operations; at this writing all such functions are usable only from task context.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=465>465</a></td>\n' +
            '<td>The System Management Bus (SMBus) is a sibling protocol. Most SMBus systems are also I2C conformant. The electrical constraints are tighter for SMBus, and it standardizes particular protocol messages and idioms. Controllers that support I2C can also support most SMBus operations, but SMBus controllers don' + "'" + 't support all the protocol options that an I2C controller will. There are functions to perform various SMBus protocol operations, either using I2C primitives or by issuing SMBus commands to i2c_adapter devices which don' + "'" + 't support those I2C operations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=466>466</a></td>\n' +
            '<td>!Iinclude/linux/i2c.h !Fdrivers/i2c/i2c-boardinfo.c i2c_register_board_info !Edrivers/i2c/i2c-core.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=467>467</a></td>\n' +
            '<td>High Speed Synchronous Serial Interface (HSI)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=468>468</a></td>\n' +
            '<td>High Speed Synchronous Serial Interface (HSI) is a serial interface mainly used for connecting application engines (APE) with cellular modem engines (CMT) in cellular handsets. HSI provides multiplexing for up to 16 logical channels, low-latency and full duplex communication.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=469>469</a></td>\n' +
            '<td>!Iinclude/linux/hsi/hsi.h !Edrivers/hsi/hsi.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=470>470</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=471>471</a></td>\n' +
            '<td>Linux provides an API which abstracts performing IO across all busses and devices, allowing device drivers to be written independently of bus type.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=472>472</a></td>\n' +
            '<td>Known Bugs And Assumptions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=473>473</a></td>\n' +
            '<td>None.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=474>474</a></td>\n' +
            '<td>Memory Mapped IO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=475>475</a></td>\n' +
            '<td>Getting Access to the Device</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=476>476</a></td>\n' +
            '<td>The most widely supported form of IO is memory mapped IO. That is, a part of the CPU' + "'" + 's address space is interpreted not as accesses to memory, but as accesses to a device. Some architectures define devices to be at a fixed address, but most have some method of discovering devices. The PCI bus walk is a good example of such a scheme. This document does not cover how to receive such an address, but assumes you are starting with one. Physical addresses are of type unsigned long.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=477>477</a></td>\n' +
            '<td>This address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ioremap. An address suitable for accessing the device will be returned to you.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=478>478</a></td>\n' +
            '<td>After you' + "'" + 've finished using the device (say, in your module' + "'" + 's exit routine), call iounmap in order to return the address space to the kernel. Most architectures allocate new address space each time you call ioremap, and they can run out unless you call iounmap.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=479>479</a></td>\n' +
            '<td>Accessing the device</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=480>480</a></td>\n' +
            '<td>The part of the interface most used by drivers is reading and writing memory-mapped registers on the device. Linux provides interfaces to read and write 8-bit, 16-bit, 32-bit and 64-bit quantities. Due to a historical accident, these are named byte, word, long and quad accesses. Both read and write accesses are supported; there is no prefetch support at this time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=481>481</a></td>\n' +
            '<td>The functions are named readb, readw, readl, readq, readb_relaxed, readw_relaxed, readl_relaxed, readq_relaxed, writeb, writew, writel and writeq.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=482>482</a></td>\n' +
            '<td>Some devices (such as framebuffers) would like to use larger transfers than 8 bytes at a time. For these devices, the memcpy_toio, memcpy_fromio and memset_io functions are provided. Do not use memset or memcpy on IO addresses; they are not guaranteed to copy data in order.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=483>483</a></td>\n' +
            '<td>The read and write functions are defined to be ordered. That is the compiler is not permitted to reorder the I/O sequence. When the ordering can be compiler optimised, you can use</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=484>484</a></td>\n' +
            '<td>    __readb and friends to indicate the relaxed ordering. Use this with care.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=485>485</a></td>\n' +
            '<td>While the basic functions are defined to be synchronous with respect to each other and ordered with respect to each other the busses the devices sit on may themselves have asynchronicity. In particular many authors are burned by the fact that PCI bus writes are posted asynchronously. A driver author must issue a read from the same device to ensure that writes have occurred in the specific cases the author cares. This kind of property cannot be hidden from driver writers in the API. In some cases, the read used to flush the device may be expected to fail (if the card is resetting, for example). In that case, the read should be done from config space, which is guaranteed to soft-fail if the card doesn' + "'" + 't respond.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=486>486</a></td>\n' +
            '<td>The following is an example of flushing a write to a device when the driver would like to ensure the write' + "'" + 's effects are visible prior to continuing execution.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=487>487</a></td>\n' +
            '<td>static inline void</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=488>488</a></td>\n' +
            '<td>qla1280_disable_intrs(struct scsi_qla_host *ha)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=489>489</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=490>490</a></td>\n' +
            '<td>    struct device_reg *reg;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=491>491</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=492>492</a></td>\n' +
            '<td>    reg = ha-&gt;iobase;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=493>493</a></td>\n' +
            '<td>    /* disable risc and host interrupts */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=494>494</a></td>\n' +
            '<td>    WRT_REG_WORD(&amp;reg-&gt;ictrl, 0);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=495>495</a></td>\n' +
            '<td>    /*</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=496>496</a></td>\n' +
            '<td>     * The following read will ensure that the above write</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=497>497</a></td>\n' +
            '<td>     * has been received by the device before we return from this</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=498>498</a></td>\n' +
            '<td>     * function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=499>499</a></td>\n' +
            '<td>     */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=500>500</a></td>\n' +
            '<td>    RD_REG_WORD(&amp;reg-&gt;ictrl);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=501>501</a></td>\n' +
            '<td>    ha-&gt;flags.ints_enabled = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=502>502</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=503>503</a></td>\n' +
            '<td>In addition to write posting, on some large multiprocessing systems (e.g. SGI Challenge, Origin and Altix machines) posted writes won' + "'" + 't be strongly ordered coming from different CPUs. Thus it' + "'" + 's important to properly protect parts of your driver that do memory-mapped writes with locks and use the mmiowb to make sure they arrive in the order intended. Issuing a regular readX</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=504>504</a></td>\n' +
            '<td>     will also ensure write ordering, but should only be used when the driver has to be sure that the write has actually arrived at the device (not that it' + "'" + 's simply ordered with respect to other writes), since a full readX is a relatively expensive operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=505>505</a></td>\n' +
            '<td>Generally, one should use mmiowb prior to releasing a spinlock that protects regions using writeb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=506>506</a></td>\n' +
            '<td>     or similar functions that aren' + "'" + 't surrounded by</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=507>507</a></td>\n' +
            '<td>    readb calls, which will ensure ordering and flushing. The following pseudocode illustrates what might occur if write ordering isn' + "'" + 't guaranteed via mmiowb or one of the readX functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=508>508</a></td>\n' +
            '<td>CPU A:  spin_lock_irqsave(&amp;dev_lock, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=509>509</a></td>\n' +
            '<td>CPU A:  ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=510>510</a></td>\n' +
            '<td>CPU A:  writel(newval, ring_ptr);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=511>511</a></td>\n' +
            '<td>CPU A:  spin_unlock_irqrestore(&amp;dev_lock, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=512>512</a></td>\n' +
            '<td>        ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=513>513</a></td>\n' +
            '<td>CPU B:  spin_lock_irqsave(&amp;dev_lock, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=514>514</a></td>\n' +
            '<td>CPU B:  writel(newval2, ring_ptr);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=515>515</a></td>\n' +
            '<td>CPU B:  ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=516>516</a></td>\n' +
            '<td>CPU B:  spin_unlock_irqrestore(&amp;dev_lock, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=517>517</a></td>\n' +
            '<td>In the case above, newval2 could be written to ring_ptr before newval. Fixing it is easy though:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=518>518</a></td>\n' +
            '<td>CPU A:  spin_lock_irqsave(&amp;dev_lock, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=519>519</a></td>\n' +
            '<td>CPU A:  ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=520>520</a></td>\n' +
            '<td>CPU A:  writel(newval, ring_ptr);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=521>521</a></td>\n' +
            '<td>CPU A:  mmiowb(); /* ensure no other writes beat us to the device */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=522>522</a></td>\n' +
            '<td>CPU A:  spin_unlock_irqrestore(&amp;dev_lock, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=523>523</a></td>\n' +
            '<td>        ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=524>524</a></td>\n' +
            '<td>CPU B:  spin_lock_irqsave(&amp;dev_lock, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=525>525</a></td>\n' +
            '<td>CPU B:  writel(newval2, ring_ptr);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=526>526</a></td>\n' +
            '<td>CPU B:  ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=527>527</a></td>\n' +
            '<td>CPU B:  mmiowb();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=528>528</a></td>\n' +
            '<td>CPU B:  spin_unlock_irqrestore(&amp;dev_lock, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=529>529</a></td>\n' +
            '<td>See tg3.c for a real world example of how to use mmiowb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=530>530</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=531>531</a></td>\n' +
            '<td>PCI ordering rules also guarantee that PIO read responses arrive after any outstanding DMA writes from that bus, since for some devices the result of a readb call may signal to the driver that a DMA transaction is complete. In many cases, however, the driver may want to indicate that the next readb call has no relation to any previous DMA writes performed by the device. The driver can use readb_relaxed for these cases, although only some platforms will honor the relaxed semantics. Using the relaxed read functions will provide significant performance benefits on platforms that support it. The qla2xxx driver provides examples of how to use readX_relaxed. In many cases, a majority of the driver' + "'" + 's readX calls can safely be converted to readX_relaxed calls, since only a few will indicate or depend on DMA completion.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=532>532</a></td>\n' +
            '<td>Port Space Accesses</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=533>533</a></td>\n' +
            '<td>Port Space Explained</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=534>534</a></td>\n' +
            '<td>Another form of IO commonly supported is Port Space. This is a range of addresses separate to the normal memory address space. Access to these addresses is generally not as fast as accesses to the memory mapped addresses, and it also has a potentially smaller address space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=535>535</a></td>\n' +
            '<td>Unlike memory mapped IO, no preparation is required to access port space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=536>536</a></td>\n' +
            '<td>Accessing Port Space</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=537>537</a></td>\n' +
            '<td>Accesses to this space are provided through a set of functions which allow 8-bit, 16-bit and 32-bit accesses; also known as byte, word and long. These functions are inb, inw, inl, outb, outw and outl.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=538>538</a></td>\n' +
            '<td>Some variants are provided for these functions. Some devices require that accesses to their ports are slowed down. This functionality is provided by appending a _p to the end of the function. There are also equivalents to memcpy. The ins and outs functions copy bytes, words or longs to the given port.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=539>539</a></td>\n' +
            '<td>Public Functions Provided</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=540>540</a></td>\n' +
            '<td>!Iarch/x86/include/asm/io.h !Elib/pci_iomap.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=541>541</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=542>542</a></td>\n' +
            '<td>The Linux DRM layer contains code intended to support the needs of complex graphics devices, usually containing programmable pipelines well suited to 3D graphics acceleration. Graphics drivers in the kernel may make use of DRM functions to make tasks like memory management, interrupt handling and DMA easier, and provide a uniform interface to applications.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=543>543</a></td>\n' +
            '<td>A note on versions: this guide covers features found in the DRM tree, including the TTM memory manager, output configuration and mode setting, and the new vblank internals, in addition to all the regular features found in current kernels.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=544>544</a></td>\n' +
            '<td>[Insert diagram of typical DRM stack here]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=545>545</a></td>\n' +
            '<td>DRM Internals</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=546>546</a></td>\n' +
            '<td>This chapter documents DRM internals relevant to driver authors and developers working to add support for the latest features to existing drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=547>547</a></td>\n' +
            '<td>First, we go over some typical driver initialization requirements, like setting up command buffers, creating an initial output configuration, and initializing core services. Subsequent sections cover core internals in more detail, providing implementation notes and examples.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=548>548</a></td>\n' +
            '<td>The DRM layer provides several services to graphics drivers, many of them driven by the application interfaces it provides through libdrm, the library that wraps most of the DRM ioctls. These include vblank event handling, memory management, output management, framebuffer management, command submission &amp; fencing, suspend/resume support, and DMA services.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=549>549</a></td>\n' +
            '<td>Driver Initialization</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=550>550</a></td>\n' +
            '<td>At the core of every DRM driver is a drm_driver structure. Drivers typically statically initialize a drm_driver structure, and then pass it to one of the drm_*_init() functions to register it with the DRM subsystem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=551>551</a></td>\n' +
            '<td>The drm_driver structure contains static information that describes the driver and features it supports, and pointers to methods that the DRM core will call to implement the DRM API. We will first go through the drm_driver static information fields, and will then describe individual operations in details as they get used in later sections.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=552>552</a></td>\n' +
            '<td>Driver Information</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=553>553</a></td>\n' +
            '<td>Driver Features</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=554>554</a></td>\n' +
            '<td>Drivers inform the DRM core about their requirements and supported features by setting appropriate flags in the driver_features field. Since those flags influence the DRM core behaviour since registration time, most of them must be set to registering the drm_driver instance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=555>555</a></td>\n' +
            '<td>u32 driver_features;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=556>556</a></td>\n' +
            '<td>DRIVER_USE_AGP</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=557>557</a></td>\n' +
            '<td>Driver uses AGP interface, the DRM core will manage AGP resources.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=558>558</a></td>\n' +
            '<td>DRIVER_REQUIRE_AGP</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=559>559</a></td>\n' +
            '<td>Driver needs AGP interface to function. AGP initialization failure will become a fatal error.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=560>560</a></td>\n' +
            '<td>DRIVER_PCI_DMA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=561>561</a></td>\n' +
            '<td>Driver is capable of PCI DMA, mapping of PCI DMA buffers to userspace will be enabled. Deprecated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=562>562</a></td>\n' +
            '<td>DRIVER_SG</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=563>563</a></td>\n' +
            '<td>Driver can perform scatter/gather DMA, allocation and mapping of scatter/gather buffers will be enabled. Deprecated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=564>564</a></td>\n' +
            '<td>DRIVER_HAVE_DMA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=565>565</a></td>\n' +
            '<td>Driver supports DMA, the userspace DMA API will be supported. Deprecated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=566>566</a></td>\n' +
            '<td>DRIVER_HAVE_IRQ; DRIVER_IRQ_SHARED</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=567>567</a></td>\n' +
            '<td>DRIVER_HAVE_IRQ indicates whether the driver has an IRQ handler managed by the DRM Core. The core will support simple IRQ handler installation when the flag is set. The installation process is described in ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=568>568</a></td>\n' +
            '<td>DRIVER_IRQ_SHARED indicates whether the device &amp; handler support shared IRQs (note that this is required of PCI drivers).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=569>569</a></td>\n' +
            '<td>DRIVER_GEM</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=570>570</a></td>\n' +
            '<td>Driver use the GEM memory manager.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=571>571</a></td>\n' +
            '<td>DRIVER_MODESET</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=572>572</a></td>\n' +
            '<td>Driver supports mode setting interfaces (KMS).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=573>573</a></td>\n' +
            '<td>DRIVER_PRIME</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=574>574</a></td>\n' +
            '<td>Driver implements DRM PRIME buffer sharing.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=575>575</a></td>\n' +
            '<td>DRIVER_RENDER</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=576>576</a></td>\n' +
            '<td>Driver supports dedicated render nodes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=577>577</a></td>\n' +
            '<td>Major, Minor and Patchlevel</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=578>578</a></td>\n' +
            '<td>int major; int minor; int patchlevel;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=579>579</a></td>\n' +
            '<td>The DRM core identifies driver versions by a major, minor and patch level triplet. The information is printed to the kernel log at initialization time and passed to userspace through the DRM_IOCTL_VERSION ioctl.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=580>580</a></td>\n' +
            '<td>The major and minor numbers are also used to verify the requested driver API version passed to DRM_IOCTL_SET_VERSION. When the driver API changes between minor versions, applications can call DRM_IOCTL_SET_VERSION to select a specific version of the API. If the requested major isn' + "'" + 't equal to the driver major, or the requested minor is larger than the driver minor, the DRM_IOCTL_SET_VERSION call will return an error. Otherwise the driver' + "'" + 's set_version() method will be called with the requested version.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=581>581</a></td>\n' +
            '<td>Name, Description and Date</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=582>582</a></td>\n' +
            '<td>char *name; char *desc; char *date;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=583>583</a></td>\n' +
            '<td>The driver name is printed to the kernel log at initialization time, used for IRQ registration and passed to userspace through DRM_IOCTL_VERSION.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=584>584</a></td>\n' +
            '<td>The driver description is a purely informative string passed to userspace through the DRM_IOCTL_VERSION ioctl and otherwise unused by the kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=585>585</a></td>\n' +
            '<td>The driver date, formatted as YYYYMMDD, is meant to identify the date of the latest modification to the driver. However, as most drivers fail to update it, its value is mostly useless. The DRM core prints it to the kernel log at initialization time and passes it to userspace through the DRM_IOCTL_VERSION ioctl.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=586>586</a></td>\n' +
            '<td>Driver Load</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=587>587</a></td>\n' +
            '<td>The load method is the driver and device initialization entry point. The method is responsible for allocating and initializing driver private data, specifying supported performance counters, performing resource allocation and mapping (e.g. acquiring clocks, mapping registers or allocating command buffers), initializing the memory manager (???), installing the IRQ handler (???), setting up vertical blanking handling (???), mode setting (???) and initial output configuration (???).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=588>588</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=589>589</a></td>\n' +
            '<td>If compatibility is a concern (e.g. with drivers converted over from User Mode Setting to Kernel Mode Setting), care must be taken to prevent device initialization and control that is incompatible with currently active userspace drivers. For instance, if user level mode setting drivers are in use, it would be problematic to perform output discovery &amp; configuration at load time. Likewise, if user-level drivers unaware of memory management are in use, memory management and command buffer setup may need to be omitted. These requirements are driver-specific, and care needs to be taken to keep both old and new applications and libraries working.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=590>590</a></td>\n' +
            '<td>int (*load) (struct drm_device *, unsigned long flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=591>591</a></td>\n' +
            '<td>The method takes two arguments, a pointer to the newly created drm_device and flags. The flags are used to pass the driver_data field of the device id corresponding to the device passed to drm_*_init(). Only PCI devices currently use this, USB and platform DRM drivers have their load method called with flags to 0.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=592>592</a></td>\n' +
            '<td>Driver Private &amp; Performance Counters</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=593>593</a></td>\n' +
            '<td>The driver private hangs off the main drm_device structure and can be used for tracking various device-specific bits of information, like register offsets, command buffer status, register state for suspend/resume, etc. At load time, a driver may simply allocate one and set drm_device.dev_priv appropriately; it should be freed and drm_device.dev_priv set to NULL when the driver is unloaded.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=594>594</a></td>\n' +
            '<td>DRM supports several counters which were used for rough performance characterization. This stat counter system is deprecated and should not be used. If performance monitoring is desired, the developer should investigate and potentially enhance the kernel perf and tracing infrastructure to export GPU related performance information for consumption by performance monitoring tools and applications.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=595>595</a></td>\n' +
            '<td>IRQ Registration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=596>596</a></td>\n' +
            '<td>The DRM core tries to facilitate IRQ handler registration and unregistration by providing drm_irq_install and drm_irq_uninstall functions. Those functions only support a single interrupt per device, devices that use more than one IRQs need to be handled manually.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=597>597</a></td>\n' +
            '<td>Managed IRQ Registration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=598>598</a></td>\n' +
            '<td>Both the drm_irq_install and drm_irq_uninstall functions get the device IRQ by calling drm_dev_to_irq. This inline function will call a bus-specific operation to retrieve the IRQ number. For platform devices, platform_get_irq(..., 0) is used to retrieve the IRQ number.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=599>599</a></td>\n' +
            '<td>drm_irq_install starts by calling the irq_preinstall driver operation. The operation is optional and must make sure that the interrupt will not get fired by clearing all pending interrupt flags or disabling the interrupt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=600>600</a></td>\n' +
            '<td>The IRQ will then be requested by a call to request_irq. If the DRIVER_IRQ_SHARED driver feature flag is set, a shared (IRQF_SHARED) IRQ handler will be requested.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=601>601</a></td>\n' +
            '<td>The IRQ handler function must be provided as the mandatory irq_handler driver operation. It will get passed directly to request_irq and thus has the same prototype as all IRQ handlers. It will get called with a pointer to the DRM device as the second argument.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=602>602</a></td>\n' +
            '<td>Finally the function calls the optional irq_postinstall driver operation. The operation usually enables interrupts (excluding the vblank interrupt, which is enabled separately), but drivers may choose to enable/disable interrupts at a different time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=603>603</a></td>\n' +
            '<td>drm_irq_uninstall is similarly used to uninstall an IRQ handler. It starts by waking up all processes waiting on a vblank interrupt to make sure they don' + "'" + 't hang, and then calls the optional irq_uninstall driver operation. The operation must disable all hardware interrupts. Finally the function frees the IRQ by calling free_irq.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=604>604</a></td>\n' +
            '<td>Manual IRQ Registration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=605>605</a></td>\n' +
            '<td>Drivers that require multiple interrupt handlers can' + "'" + 't use the managed IRQ registration functions. In that case IRQs must be registered and unregistered manually (usually with the request_irq and free_irq functions, or their devm_* equivalent).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=606>606</a></td>\n' +
            '<td>When manually registering IRQs, drivers must not set the DRIVER_HAVE_IRQ driver feature flag, and must not provide the irq_handler driver operation. They must set the drm_device irq_enabled field to 1 upon registration of the IRQs, and clear it to 0 after unregistering the IRQs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=607>607</a></td>\n' +
            '<td>Memory Manager Initialization</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=608>608</a></td>\n' +
            '<td>Every DRM driver requires a memory manager which must be initialized at load time. DRM currently contains two memory managers, the Translation Table Manager (TTM) and the Graphics Execution Manager (GEM). This document describes the use of the GEM memory manager only. See ??? for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=609>609</a></td>\n' +
            '<td>Miscellaneous Device Configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=610>610</a></td>\n' +
            '<td>Another task that may be necessary for PCI devices during configuration is mapping the video BIOS. On many devices, the VBIOS describes device configuration, LCD panel timings (if any), and contains flags indicating device state. Mapping the BIOS can be done using the pci_map_rom() call, a convenience function that takes care of mapping the actual ROM, whether it has been shadowed into memory (typically at address 0xc0000) or exists on the PCI device in the ROM BAR. Note that after the ROM has been mapped and any necessary information has been extracted, it should be unmapped; on many devices, the ROM address decoder is shared with other BARs, so leaving it mapped could cause undesired behaviour like hangs or memory corruption.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=611>611</a></td>\n' +
            '<td>Memory management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=612>612</a></td>\n' +
            '<td>Modern Linux systems require large amount of graphics memory to store frame buffers, textures, vertices and other graphics-related data. Given the very dynamic nature of many of that data, managing graphics memory efficiently is thus crucial for the graphics stack and plays a central role in the DRM infrastructure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=613>613</a></td>\n' +
            '<td>The DRM core includes two memory managers, namely Translation Table Maps (TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory manager to be developed and tried to be a one-size-fits-them all solution. It provides a single userspace API to accommodate the need of all hardware, supporting both Unified Memory Architecture (UMA) devices and devices with dedicated video RAM (i.e. most discrete video cards). This resulted in a large, complex piece of code that turned out to be hard to use for driver development.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=614>614</a></td>\n' +
            '<td>GEM started as an Intel-sponsored project in reaction to TTM' + "'" + 's complexity. Its design philosophy is completely different: instead of providing a solution to every graphics memory-related problems, GEM identified common code between drivers and created a support library to share it. GEM has simpler initialization and execution requirements than TTM, but has no video RAM management capabitilies and is thus limited to UMA devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=615>615</a></td>\n' +
            '<td>The Translation Table Manager (TTM)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=616>616</a></td>\n' +
            '<td>TTM design background and information belongs here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=617>617</a></td>\n' +
            '<td>TTM initialization</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=618>618</a></td>\n' +
            '<td>Warning</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=619>619</a></td>\n' +
            '<td>This section is outdated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=620>620</a></td>\n' +
            '<td>Drivers wishing to support TTM must fill out a drm_bo_driver structure. The structure contains several fields with function pointers for initializing the TTM, allocating and freeing memory, waiting for command completion and fence synchronization, and memory migration. See the radeon_ttm.c file for an example of usage.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=621>621</a></td>\n' +
            '<td>The ttm_global_reference structure is made up of several fields:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=622>622</a></td>\n' +
            '<td>      struct ttm_global_reference {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=623>623</a></td>\n' +
            '<td>        enum ttm_global_types global_type;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=624>624</a></td>\n' +
            '<td>        size_t size;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=625>625</a></td>\n' +
            '<td>        void *object;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=626>626</a></td>\n' +
            '<td>        int (*init) (struct ttm_global_reference *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=627>627</a></td>\n' +
            '<td>        void (*release) (struct ttm_global_reference *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=628>628</a></td>\n' +
            '<td>      };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=629>629</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=630>630</a></td>\n' +
            '<td>There should be one global reference structure for your memory manager as a whole, and there will be others for each object created by the memory manager at runtime. Your global TTM should have a type of TTM_GLOBAL_TTM_MEM. The size field for the global object should be sizeof(struct ttm_mem_global), and the init and release hooks should point at your driver-specific init and release routines, which probably eventually call ttm_mem_global_init and ttm_mem_global_release, respectively.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=631>631</a></td>\n' +
            '<td>Once your global TTM accounting structure is set up and initialized by calling ttm_global_item_ref() on it, you need to create a buffer object TTM to provide a pool for buffer object allocation by clients and the kernel itself. The type of this object should be TTM_GLOBAL_TTM_BO, and its size should be sizeof(struct ttm_bo_global). Again, driver-specific init and release functions may be provided, likely eventually calling ttm_bo_global_init() and ttm_bo_global_release(), respectively. Also, like the previous object, ttm_global_item_ref() is used to create an initial reference count for the TTM, which will call your initialization function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=632>632</a></td>\n' +
            '<td>The Graphics Execution Manager (GEM)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=633>633</a></td>\n' +
            '<td>The GEM design approach has resulted in a memory manager that doesn' + "'" + 't provide full coverage of all (or even all common) use cases in its userspace or kernel API. GEM exposes a set of standard memory-related operations to userspace and a set of helper functions to drivers, and let drivers implement hardware-specific operations with their own private API.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=634>634</a></td>\n' +
            '<td>The GEM userspace API is described in the GEM - the Graphics Execution Manager article on LWN. While slightly outdated, the document provides a good overview of the GEM API principles. Buffer allocation and read and write operations, described as part of the common GEM API, are currently implemented using driver-specific ioctls.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=635>635</a></td>\n' +
            '<td>GEM is data-agnostic. It manages abstract buffer objects without knowing what individual buffers contain. APIs that require knowledge of buffer contents or purpose, such as buffer allocation or synchronization primitives, are thus outside of the scope of GEM and must be implemented using driver-specific ioctls.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=636>636</a></td>\n' +
            '<td>On a fundamental level, GEM involves several operations:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=637>637</a></td>\n' +
            '<td>    Memory allocation and freeing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=638>638</a></td>\n' +
            '<td>    Command execution</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=639>639</a></td>\n' +
            '<td>    Aperture management at command execution time</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=640>640</a></td>\n' +
            '<td>Buffer object allocation is relatively straightforward and largely provided by Linux' + "'" + 's shmem layer, which provides memory to back each object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=641>641</a></td>\n' +
            '<td>Device-specific operations, such as command execution, pinning, buffer read &amp; write, mapping, and domain ownership transfers are left to driver-specific ioctls.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=642>642</a></td>\n' +
            '<td>GEM Initialization</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=643>643</a></td>\n' +
            '<td>Drivers that use GEM must set the DRIVER_GEM bit in the struct drm_driver driver_features field. The DRM core will then automatically initialize the GEM core before calling the load operation. Behind the scene, this will create a DRM Memory Manager object which provides an address space pool for object allocation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=644>644</a></td>\n' +
            '<td>In a KMS configuration, drivers need to allocate and initialize a command ring buffer following core GEM initialization if required by the hardware. UMA devices usually have what is called a "stolen" memory region, which provides space for the initial framebuffer and large, contiguous memory regions required by the device. This space is typically not managed by GEM, and must be initialized separately into its own DRM MM object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=645>645</a></td>\n' +
            '<td>GEM Objects Creation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=646>646</a></td>\n' +
            '<td>GEM splits creation of GEM objects and allocation of the memory that backs them in two distinct operations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=647>647</a></td>\n' +
            '<td>GEM objects are represented by an instance of struct drm_gem_object. Drivers usually need to extend GEM objects with private information and thus create a driver-specific GEM object structure type that embeds an instance of struct drm_gem_object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=648>648</a></td>\n' +
            '<td>To create a GEM object, a driver allocates memory for an instance of its specific GEM object type and initializes the embedded struct drm_gem_object with a call to drm_gem_object_init. The function takes a pointer to the DRM device, a pointer to the GEM object and the buffer object size in bytes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=649>649</a></td>\n' +
            '<td>GEM uses shmem to allocate anonymous pageable memory. drm_gem_object_init will create an shmfs file of the requested size and store it into the struct drm_gem_object filp field. The memory is used as either main storage for the object when the graphics hardware uses system memory directly or as a backing store otherwise.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=650>650</a></td>\n' +
            '<td>Drivers are responsible for the actual physical pages allocation by calling shmem_read_mapping_page_gfp for each page. Note that they can decide to allocate pages when initializing the GEM object, or to delay allocation until the memory is needed (for instance when a page fault occurs as a result of a userspace memory access or when the driver needs to start a DMA transfer involving the memory).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=651>651</a></td>\n' +
            '<td>Anonymous pageable memory allocation is not always desired, for instance when the hardware requires physically contiguous system memory as is often the case in embedded devices. Drivers can create GEM objects with no shmfs backing (called private GEM objects) by initializing them with a call to drm_gem_private_object_init instead of drm_gem_object_init. Storage for private GEM objects must be managed by drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=652>652</a></td>\n' +
            '<td>Drivers that do not need to extend GEM objects with private information can call the drm_gem_object_alloc function to allocate and initialize a struct drm_gem_object instance. The GEM core will call the optional driver gem_init_object operation after initializing the GEM object with drm_gem_object_init. int (*gem_init_object) (struct drm_gem_object *obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=653>653</a></td>\n' +
            '<td>No alloc-and-init function exists for private GEM objects.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=654>654</a></td>\n' +
            '<td>GEM Objects Lifetime</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=655>655</a></td>\n' +
            '<td>All GEM objects are reference-counted by the GEM core. References can be acquired and release by calling drm_gem_object_reference and drm_gem_object_unreference respectively. The caller must hold the drm_device struct_mutex lock. As a convenience, GEM provides the drm_gem_object_reference_unlocked and drm_gem_object_unreference_unlocked functions that can be called without holding the lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=656>656</a></td>\n' +
            '<td>When the last reference to a GEM object is released the GEM core calls the drm_driver gem_free_object operation. That operation is mandatory for GEM-enabled drivers and must free the GEM object and all associated resources.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=657>657</a></td>\n' +
            '<td>void (*gem_free_object) (struct drm_gem_object *obj); Drivers are responsible for freeing all GEM object resources, including the resources created by the GEM core. If an mmap offset has been created for the object (in which case drm_gem_object::map_list::map is not NULL) it must be freed by a call to drm_gem_free_mmap_offset. The shmfs backing store must be released by calling drm_gem_object_release (that function can safely be called if no shmfs backing store has been created).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=658>658</a></td>\n' +
            '<td>GEM Objects Naming</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=659>659</a></td>\n' +
            '<td>Communication between userspace and the kernel refers to GEM objects using local handles, global names or, more recently, file descriptors. All of those are 32-bit integer values; the usual Linux kernel limits apply to the file descriptors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=660>660</a></td>\n' +
            '<td>GEM handles are local to a DRM file. Applications get a handle to a GEM object through a driver-specific ioctl, and can use that handle to refer to the GEM object in other standard or driver-specific ioctls. Closing a DRM file handle frees all its GEM handles and dereferences the associated GEM objects.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=661>661</a></td>\n' +
            '<td>To create a handle for a GEM object drivers call drm_gem_handle_create. The function takes a pointer to the DRM file and the GEM object and returns a locally unique handle. When the handle is no longer needed drivers delete it with a call to drm_gem_handle_delete. Finally the GEM object associated with a handle can be retrieved by a call to drm_gem_object_lookup.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=662>662</a></td>\n' +
            '<td>Handles don' + "'" + 't take ownership of GEM objects, they only take a reference to the object that will be dropped when the handle is destroyed. To avoid leaking GEM objects, drivers must make sure they drop the reference(s) they own (such as the initial reference taken at object creation time) as appropriate, without any special consideration for the handle. For example, in the particular case of combined GEM object and handle creation in the implementation of the dumb_create operation, drivers must drop the initial reference to the GEM object before returning the handle.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=663>663</a></td>\n' +
            '<td>GEM names are similar in purpose to handles but are not local to DRM files. They can be passed between processes to reference a GEM object globally. Names can' + "'" + 't be used directly to refer to objects in the DRM API, applications must convert handles to names and names to handles using the DRM_IOCTL_GEM_FLINK and DRM_IOCTL_GEM_OPEN ioctls respectively. The conversion is handled by the DRM core without any driver-specific support.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=664>664</a></td>\n' +
            '<td>Similar to global names, GEM file descriptors are also used to share GEM objects across processes. They offer additional security: as file descriptors must be explicitly sent over UNIX domain sockets to be shared between applications, they can' + "'" + 't be guessed like the globally unique GEM names.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=665>665</a></td>\n' +
            '<td>Drivers that support GEM file descriptors, also known as the DRM PRIME API, must set the DRIVER_PRIME bit in the struct drm_driver driver_features field, and implement the prime_handle_to_fd and prime_fd_to_handle operations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=666>666</a></td>\n' +
            '<td>int (*prime_handle_to_fd)(struct drm_device *dev, struct drm_file *file_priv, uint32_t handle, uint32_t flags, int *prime_fd); int (*prime_fd_to_handle)(struct drm_device *dev, struct drm_file *file_priv, int prime_fd, uint32_t *handle); Those two operations convert a handle to a PRIME file descriptor and vice versa. Drivers must use the kernel dma-buf buffer sharing framework to manage the PRIME file descriptors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=667>667</a></td>\n' +
            '<td>While non-GEM drivers must implement the operations themselves, GEM drivers must use the drm_gem_prime_handle_to_fd and drm_gem_prime_fd_to_handle helper functions. Those helpers rely on the driver gem_prime_export and gem_prime_import operations to create a dma-buf instance from a GEM object (dma-buf exporter role) and to create a GEM object from a dma-buf instance (dma-buf importer role).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=668>668</a></td>\n' +
            '<td>struct dma_buf * (*gem_prime_export)(struct drm_device *dev, struct drm_gem_object *obj, int flags); struct drm_gem_object * (*gem_prime_import)(struct drm_device *dev, struct dma_buf *dma_buf); These two operations are mandatory for GEM drivers that support DRM PRIME.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=669>669</a></td>\n' +
            '<td>DRM PRIME Helper Functions Reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=670>670</a></td>\n' +
            '<td>!Pdrivers/gpu/drm/drm_prime.c PRIME Helpers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=671>671</a></td>\n' +
            '<td>GEM Objects Mapping</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=672>672</a></td>\n' +
            '<td>Because mapping operations are fairly heavyweight GEM favours read/write-like access to buffers, implemented through driver-specific ioctls, over mapping buffers to userspace. However, when random access to the buffer is needed (to perform software rendering for instance), direct access to the object can be more efficient.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=673>673</a></td>\n' +
            '<td>The mmap system call can' + "'" + 't be used directly to map GEM objects, as they don' + "'" + 't have their own file handle. Two alternative methods currently co-exist to map GEM objects to userspace. The first method uses a driver-specific ioctl to perform the mapping operation, calling do_mmap under the hood. This is often considered dubious, seems to be discouraged for new GEM-enabled drivers, and will thus not be described here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=674>674</a></td>\n' +
            '<td>The second method uses the mmap system call on the DRM file handle. void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); DRM identifies the GEM object to be mapped by a fake offset passed through the mmap offset argument. Prior to being mapped, a GEM object must thus be associated with a fake offset. To do so, drivers must call drm_gem_create_mmap_offset on the object. The function allocates a fake offset range from a pool and stores the offset divided by PAGE_SIZE in obj-&gt;map_list.hash.key. Care must be taken not to call drm_gem_create_mmap_offset if a fake offset has already been allocated for the object. This can be tested by obj-&gt;map_list.map being non-NULL.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=675>675</a></td>\n' +
            '<td>Once allocated, the fake offset value (obj-&gt;map_list.hash.key &lt;&lt; PAGE_SHIFT) must be passed to the application in a driver-specific way and can then be used as the mmap offset argument.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=676>676</a></td>\n' +
            '<td>The GEM core provides a helper method drm_gem_mmap to handle object mapping. The method can be set directly as the mmap file operation handler. It will look up the GEM object based on the offset value and set the VMA operations to the drm_driver gem_vm_ops field. Note that drm_gem_mmap doesn' + "'" + 't map memory to userspace, but relies on the driver-provided fault handler to map pages individually.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=677>677</a></td>\n' +
            '<td>To use drm_gem_mmap, drivers must fill the struct drm_driver gem_vm_ops field with a pointer to VM operations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=678>678</a></td>\n' +
            '<td>struct vm_operations_struct *gem_vm_ops struct vm_operations_struct { void (*open)(struct vm_area_struct * area); void (*close)(struct vm_area_struct * area); int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf); };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=679>679</a></td>\n' +
            '<td>The open and close operations must update the GEM object reference count. Drivers can use the drm_gem_vm_open and drm_gem_vm_close helper functions directly as open and close handlers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=680>680</a></td>\n' +
            '<td>The fault operation handler is responsible for mapping individual pages to userspace when a page fault occurs. Depending on the memory allocation scheme, drivers can allocate pages at fault time, or can decide to allocate memory for the GEM object at the time the object is created.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=681>681</a></td>\n' +
            '<td>Drivers that want to map the GEM object upfront instead of handling page faults can implement their own mmap file operation handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=682>682</a></td>\n' +
            '<td>Dumb GEM Objects</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=683>683</a></td>\n' +
            '<td>The GEM API doesn' + "'" + 't standardize GEM objects creation and leaves it to driver-specific ioctls. While not an issue for full-fledged graphics stacks that include device-specific userspace components (in libdrm for instance), this limit makes DRM-based early boot graphics unnecessarily complex.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=684>684</a></td>\n' +
            '<td>Dumb GEM objects partly alleviate the problem by providing a standard API to create dumb buffers suitable for scanout, which can then be used to create KMS frame buffers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=685>685</a></td>\n' +
            '<td>To support dumb GEM objects drivers must implement the dumb_create, dumb_destroy and dumb_map_offset operations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=686>686</a></td>\n' +
            '<td>    int (*dumb_create)(struct drm_file *file_priv, struct drm_device *dev, struct drm_mode_create_dumb *args);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=687>687</a></td>\n' +
            '<td>     The dumb_create operation creates a GEM object suitable for scanout based on the width, height and depth from the struct drm_mode_create_dumb argument. It fills the argument' + "'" + 's handle, pitch and size fields with a handle for the newly created GEM object and its line pitch and size in bytes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=688>688</a></td>\n' +
            '<td>    int (*dumb_destroy)(struct drm_file *file_priv, struct drm_device *dev, uint32_t handle);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=689>689</a></td>\n' +
            '<td>     The dumb_destroy operation destroys a dumb GEM object created by dumb_create.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=690>690</a></td>\n' +
            '<td>    int (*dumb_map_offset)(struct drm_file *file_priv, struct drm_device *dev, uint32_t handle, uint64_t *offset);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=691>691</a></td>\n' +
            '<td>     The dumb_map_offset operation associates an mmap fake offset with the GEM object given by the handle and returns it. Drivers must use the drm_gem_create_mmap_offset function to associate the fake offset as described in ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=692>692</a></td>\n' +
            '<td>Memory Coherency</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=693>693</a></td>\n' +
            '<td>When mapped to the device or used in a command buffer, backing pages for an object are flushed to memory and marked write combined so as to be coherent with the GPU. Likewise, if the CPU accesses an object after the GPU has finished rendering to the object, then the object must be made coherent with the CPU' + "'" + 's view of memory, usually involving GPU cache flushing of various kinds. This core CPU&lt;-&gt;GPU coherency management is provided by a device-specific ioctl, which evaluates an object' + "'" + 's current domain and performs any necessary flushing or synchronization to put the object into the desired coherency domain (note that the object may be busy, i.e. an active render target; in that case, setting the domain blocks the client and waits for rendering to complete before performing any necessary flushing operations).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=694>694</a></td>\n' +
            '<td>Command Execution</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=695>695</a></td>\n' +
            '<td>Perhaps the most important GEM function for GPU devices is providing a command execution interface to clients. Client programs construct command buffers containing references to previously allocated memory objects, and then submit them to GEM. At that point, GEM takes care to bind all the objects into the GTT, execute the buffer, and provide necessary synchronization between clients accessing the same buffers. This often involves evicting some objects from the GTT and re-binding others (a fairly expensive operation), and providing relocation support which hides fixed GTT offsets from clients. Clients must take care not to submit command buffers that reference more objects than can fit in the GTT; otherwise, GEM will reject them and no rendering will occur. Similarly, if several objects in the buffer require fence registers to be allocated for correct rendering (e.g. 2D blits on pre-965 chips), care must be taken not to require more fence registers than are available to the client. Such resource management should be abstracted from the client in libdrm.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=696>696</a></td>\n' +
            '<td>Mode Setting</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=697>697</a></td>\n' +
            '<td>Drivers must initialize the mode setting core by calling drm_mode_config_init on the DRM device. The function initializes the drm_device mode_config field and never fails. Once done, mode configuration must be setup by initializing the following fields.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=698>698</a></td>\n' +
            '<td>    int min_width, min_height; int max_width, max_height;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=699>699</a></td>\n' +
            '<td>     Minimum and maximum width and height of the frame buffers in pixel units.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=700>700</a></td>\n' +
            '<td>    struct drm_mode_config_funcs *funcs;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=701>701</a></td>\n' +
            '<td>     Mode setting functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=702>702</a></td>\n' +
            '<td>Frame Buffer Creation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=703>703</a></td>\n' +
            '<td>struct drm_framebuffer *(*fb_create)(struct drm_device *dev, struct drm_file *file_priv, struct drm_mode_fb_cmd2 *mode_cmd);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=704>704</a></td>\n' +
            '<td>Frame buffers are abstract memory objects that provide a source of pixels to scanout to a CRTC. Applications explicitly request the creation of frame buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and receive an opaque handle that can be passed to the KMS CRTC control, plane configuration and page flip functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=705>705</a></td>\n' +
            '<td>Frame buffers rely on the underneath memory manager for low-level memory operations. When creating a frame buffer applications pass a memory handle (or a list of memory handles for multi-planar formats) through the drm_mode_fb_cmd2 argument. This document assumes that the driver uses GEM, those handles thus reference GEM objects.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=706>706</a></td>\n' +
            '<td>Drivers must first validate the requested frame buffer parameters passed through the mode_cmd argument. In particular this is where invalid sizes, pixel formats or pitches can be caught.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=707>707</a></td>\n' +
            '<td>If the parameters are deemed valid, drivers then create, initialize and return an instance of struct drm_framebuffer. If desired the instance can be embedded in a larger driver-specific structure. Drivers must fill its width, height, pitches, offsets, depth, bits_per_pixel and pixel_format fields from the values passed through the drm_mode_fb_cmd2 argument. They should call the drm_helper_mode_fill_fb_struct helper function to do so.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=708>708</a></td>\n' +
            '<td>The initailization of the new framebuffer instance is finalized with a call to drm_framebuffer_init which takes a pointer to DRM frame buffer operations (struct drm_framebuffer_funcs). Note that this function publishes the framebuffer and so from this point on it can be accessed concurrently from other threads. Hence it must be the last step in the driver' + "'" + 's framebuffer initialization sequence. Frame buffer operations are</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=709>709</a></td>\n' +
            '<td>    int (*create_handle)(struct drm_framebuffer *fb, struct drm_file *file_priv, unsigned int *handle);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=710>710</a></td>\n' +
            '<td>     Create a handle to the frame buffer underlying memory object. If the frame buffer uses a multi-plane format, the handle will reference the memory object associated with the first plane.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=711>711</a></td>\n' +
            '<td>     Drivers call drm_gem_handle_create to create the handle.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=712>712</a></td>\n' +
            '<td>    void (*destroy)(struct drm_framebuffer *framebuffer);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=713>713</a></td>\n' +
            '<td>     Destroy the frame buffer object and frees all associated resources. Drivers must call drm_framebuffer_cleanup to free resources allocated by the DRM core for the frame buffer object, and must make sure to unreference all memory objects associated with the frame buffer. Handles created by the create_handle operation are released by the DRM core.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=714>714</a></td>\n' +
            '<td>    int (*dirty)(struct drm_framebuffer *framebuffer, struct drm_file *file_priv, unsigned flags, unsigned color, struct drm_clip_rect *clips, unsigned num_clips);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=715>715</a></td>\n' +
            '<td>     This optional operation notifies the driver that a region of the frame buffer has changed in response to a DRM_IOCTL_MODE_DIRTYFB ioctl call.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=716>716</a></td>\n' +
            '<td>The lifetime of a drm framebuffer is controlled with a reference count, drivers can grab additional references with drm_framebuffer_reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=717>717</a></td>\n' +
            '<td>and drop them again with</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=718>718</a></td>\n' +
            '<td>drm_framebuffer_unreference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=719>719</a></td>\n' +
            '<td>. For driver-private framebuffers for which the last reference is never dropped (e.g. for the fbdev framebuffer when the struct</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=720>720</a></td>\n' +
            '<td>drm_framebuffer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=721>721</a></td>\n' +
            '<td>is embedded into the fbdev helper struct) drivers can manually clean up a framebuffer at module unload time with</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=722>722</a></td>\n' +
            '<td>drm_framebuffer_unregister_private</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=723>723</a></td>\n' +
            '<td>.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=724>724</a></td>\n' +
            '<td>Output Polling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=725>725</a></td>\n' +
            '<td>void (*output_poll_changed)(struct drm_device *dev);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=726>726</a></td>\n' +
            '<td>This operation notifies the driver that the status of one or more connectors has changed. Drivers that use the fb helper can just call the drm_fb_helper_hotplug_event function to handle this operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=727>727</a></td>\n' +
            '<td>Locking</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=728>728</a></td>\n' +
            '<td>Beside some lookup structures with their own locking (which is hidden behind the interface functions) most of the modeset state is protected by the dev-&lt;mode_config.lock mutex and additionally per-crtc locks to allow cursor updates, pageflips and similar operations to occur concurrently with background tasks like output detection. Operations which cross domains like a full modeset always grab all locks. Drivers there need to protect resources shared between crtcs with additional locking. They also need to be careful to always grab the relevant crtc locks if a modset functions touches crtc state, e.g. for load detection (which does only grab the mode_config.lock to allow concurrent screen updates on live crtcs).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=729>729</a></td>\n' +
            '<td>KMS Initialization and Cleanup</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=730>730</a></td>\n' +
            '<td>A KMS device is abstracted and exposed as a set of planes, CRTCs, encoders and connectors. KMS drivers must thus create and initialize all those objects at load time after initializing mode setting.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=731>731</a></td>\n' +
            '<td>CRTCs (struct drm_crtc)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=732>732</a></td>\n' +
            '<td>A CRTC is an abstraction representing a part of the chip that contains a pointer to a scanout buffer. Therefore, the number of CRTCs available determines how many independent scanout buffers can be active at any given time. The CRTC structure contains several fields to support this: a pointer to some video memory (abstracted as a frame buffer object), a display mode, and an (x, y) offset into the video memory to support panning or configurations where one piece of video memory spans multiple CRTCs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=733>733</a></td>\n' +
            '<td>CRTC Initialization</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=734>734</a></td>\n' +
            '<td>A KMS device must create and register at least one struct drm_crtc instance. The instance is allocated and zeroed by the driver, possibly as part of a larger structure, and registered with a call to drm_crtc_init with a pointer to CRTC functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=735>735</a></td>\n' +
            '<td>CRTC Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=736>736</a></td>\n' +
            '<td>Set Configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=737>737</a></td>\n' +
            '<td>int (*set_config)(struct drm_mode_set *set);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=738>738</a></td>\n' +
            '<td>Apply a new CRTC configuration to the device. The configuration specifies a CRTC, a frame buffer to scan out from, a (x,y) position in the frame buffer, a display mode and an array of connectors to drive with the CRTC if possible.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=739>739</a></td>\n' +
            '<td>If the frame buffer specified in the configuration is NULL, the driver must detach all encoders connected to the CRTC and all connectors attached to those encoders and disable them.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=740>740</a></td>\n' +
            '<td>This operation is called with the mode config lock held.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=741>741</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=742>742</a></td>\n' +
            '<td>FIXME: How should set_config interact with DPMS? If the CRTC is suspended, should it be resumed?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=743>743</a></td>\n' +
            '<td>Page Flipping</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=744>744</a></td>\n' +
            '<td>int (*page_flip)(struct drm_crtc *crtc, struct drm_framebuffer *fb, struct drm_pending_vblank_event *event);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=745>745</a></td>\n' +
            '<td>Schedule a page flip to the given frame buffer for the CRTC. This operation is called with the mode config mutex held.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=746>746</a></td>\n' +
            '<td>Page flipping is a synchronization mechanism that replaces the frame buffer being scanned out by the CRTC with a new frame buffer during vertical blanking, avoiding tearing. When an application requests a page flip the DRM core verifies that the new frame buffer is large enough to be scanned out by the CRTC in the currently configured mode and then calls the CRTC page_flip operation with a pointer to the new frame buffer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=747>747</a></td>\n' +
            '<td>The page_flip operation schedules a page flip. Once any pending rendering targeting the new frame buffer has completed, the CRTC will be reprogrammed to display that frame buffer after the next vertical refresh. The operation must return immediately without waiting for rendering or page flip to complete and must block any new rendering to the frame buffer until the page flip completes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=748>748</a></td>\n' +
            '<td>If a page flip can be successfully scheduled the driver must set the drm_crtc-&lt;fb field to the new framebuffer pointed to by fb. This is important so that the reference counting on framebuffers stays balanced.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=749>749</a></td>\n' +
            '<td>If a page flip is already pending, the page_flip operation must return -EBUSY.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=750>750</a></td>\n' +
            '<td>To synchronize page flip to vertical blanking the driver will likely need to enable vertical blanking interrupts. It should call drm_vblank_get for that purpose, and call drm_vblank_put after the page flip completes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=751>751</a></td>\n' +
            '<td>If the application has requested to be notified when page flip completes the page_flip operation will be called with a non-NULL event argument pointing to a drm_pending_vblank_event instance. Upon page flip completion the driver must call drm_send_vblank_event to fill in the event and send to wake up any waiting processes. This can be performed with</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=752>752</a></td>\n' +
            '<td>            spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=753>753</a></td>\n' +
            '<td>            ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=754>754</a></td>\n' +
            '<td>            drm_send_vblank_event(dev, pipe, event);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=755>755</a></td>\n' +
            '<td>            spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=756>756</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=757>757</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=758>758</a></td>\n' +
            '<td>FIXME: Could drivers that don' + "'" + 't need to wait for rendering to complete just add the event to dev-&gt;vblank_event_list and let the DRM core handle everything, as for "normal" vertical blanking events?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=759>759</a></td>\n' +
            '<td>While waiting for the page flip to complete, the event-&gt;base.link list head can be used freely by the driver to store the pending event in a driver-specific list.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=760>760</a></td>\n' +
            '<td>If the file handle is closed before the event is signaled, drivers must take care to destroy the event in their preclose operation (and, if needed, call drm_vblank_put).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=761>761</a></td>\n' +
            '<td>Miscellaneous</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=762>762</a></td>\n' +
            '<td>    void (*set_property)(struct drm_crtc *crtc, struct drm_property *property, uint64_t value);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=763>763</a></td>\n' +
            '<td>     Set the value of the given CRTC property to value. See ??? for more information about properties.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=764>764</a></td>\n' +
            '<td>    void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b, uint32_t start, uint32_t size);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=765>765</a></td>\n' +
            '<td>     Apply a gamma table to the device. The operation is optional.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=766>766</a></td>\n' +
            '<td>    void (*destroy)(struct drm_crtc *crtc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=767>767</a></td>\n' +
            '<td>     Destroy the CRTC when not needed anymore. See ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=768>768</a></td>\n' +
            '<td>Planes (struct drm_plane)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=769>769</a></td>\n' +
            '<td>A plane represents an image source that can be blended with or overlayed on top of a CRTC during the scanout process. Planes are associated with a frame buffer to crop a portion of the image memory (source) and optionally scale it to a destination size. The result is then blended with or overlayed on top of a CRTC.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=770>770</a></td>\n' +
            '<td>Plane Initialization</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=771>771</a></td>\n' +
            '<td>Planes are optional. To create a plane, a KMS drivers allocates and zeroes an instances of struct drm_plane (possibly as part of a larger structure) and registers it with a call to drm_plane_init. The function takes a bitmask of the CRTCs that can be associated with the plane, a pointer to the plane functions and a list of format supported formats.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=772>772</a></td>\n' +
            '<td>Plane Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=773>773</a></td>\n' +
            '<td>    int (*update_plane)(struct drm_plane *plane, struct drm_crtc *crtc, struct drm_framebuffer *fb, int crtc_x, int crtc_y, unsigned int crtc_w, unsigned int crtc_h, uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=774>774</a></td>\n' +
            '<td>     Enable and configure the plane to use the given CRTC and frame buffer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=775>775</a></td>\n' +
            '<td>     The source rectangle in frame buffer memory coordinates is given by the src_x, src_y, src_w and src_h parameters (as 16.16 fixed point values). Devices that don' + "'" + 't support subpixel plane coordinates can ignore the fractional part.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=776>776</a></td>\n' +
            '<td>     The destination rectangle in CRTC coordinates is given by the crtc_x, crtc_y, crtc_w and crtc_h parameters (as integer values). Devices scale the source rectangle to the destination rectangle. If scaling is not supported, and the source rectangle size doesn' + "'" + 't match the destination rectangle size, the driver must return a -EINVAL error.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=777>777</a></td>\n' +
            '<td>    int (*disable_plane)(struct drm_plane *plane);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=778>778</a></td>\n' +
            '<td>     Disable the plane. The DRM core calls this method in response to a DRM_IOCTL_MODE_SETPLANE ioctl call with the frame buffer ID set to 0. Disabled planes must not be processed by the CRTC.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=779>779</a></td>\n' +
            '<td>    void (*destroy)(struct drm_plane *plane);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=780>780</a></td>\n' +
            '<td>     Destroy the plane when not needed anymore. See ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=781>781</a></td>\n' +
            '<td>Encoders (struct drm_encoder)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=782>782</a></td>\n' +
            '<td>An encoder takes pixel data from a CRTC and converts it to a format suitable for any attached connectors. On some devices, it may be possible to have a CRTC send data to more than one encoder. In that case, both encoders would receive data from the same scanout buffer, resulting in a "cloned" display configuration across the connectors attached to each encoder.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=783>783</a></td>\n' +
            '<td>Encoder Initialization</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=784>784</a></td>\n' +
            '<td>As for CRTCs, a KMS driver must create, initialize and register at least one struct drm_encoder instance. The instance is allocated and zeroed by the driver, possibly as part of a larger structure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=785>785</a></td>\n' +
            '<td>Drivers must initialize the struct drm_encoder possible_crtcs and possible_clones fields before registering the encoder. Both fields are bitmasks of respectively the CRTCs that the encoder can be connected to, and sibling encoders candidate for cloning.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=786>786</a></td>\n' +
            '<td>After being initialized, the encoder must be registered with a call to drm_encoder_init. The function takes a pointer to the encoder functions and an encoder type. Supported types are</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=787>787</a></td>\n' +
            '<td>    DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=788>788</a></td>\n' +
            '<td>    DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=789>789</a></td>\n' +
            '<td>    DRM_MODE_ENCODER_LVDS for display panels</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=790>790</a></td>\n' +
            '<td>    DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video, Component, SCART)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=791>791</a></td>\n' +
            '<td>    DRM_MODE_ENCODER_VIRTUAL for virtual machine displays</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=792>792</a></td>\n' +
            '<td>Encoders must be attached to a CRTC to be used. DRM drivers leave encoders unattached at initialization time. Applications (or the fbdev compatibility layer when implemented) are responsible for attaching the encoders they want to use to a CRTC.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=793>793</a></td>\n' +
            '<td>Encoder Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=794>794</a></td>\n' +
            '<td>    void (*destroy)(struct drm_encoder *encoder);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=795>795</a></td>\n' +
            '<td>     Called to destroy the encoder when not needed anymore. See ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=796>796</a></td>\n' +
            '<td>    void (*set_property)(struct drm_plane *plane, struct drm_property *property, uint64_t value);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=797>797</a></td>\n' +
            '<td>     Set the value of the given plane property to value. See ??? for more information about properties.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=798>798</a></td>\n' +
            '<td>Connectors (struct drm_connector)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=799>799</a></td>\n' +
            '<td>A connector is the final destination for pixel data on a device, and usually connects directly to an external display device like a monitor or laptop panel. A connector can only be attached to one encoder at a time. The connector is also the structure where information about the attached display is kept, so it contains fields for display data, EDID data, DPMS &amp; connection status, and information about modes supported on the attached displays.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=800>800</a></td>\n' +
            '<td>Connector Initialization</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=801>801</a></td>\n' +
            '<td>Finally a KMS driver must create, initialize, register and attach at least one struct drm_connector instance. The instance is created as other KMS objects and initialized by setting the following fields.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=802>802</a></td>\n' +
            '<td>interlace_allowed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=803>803</a></td>\n' +
            '<td>Whether the connector can handle interlaced modes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=804>804</a></td>\n' +
            '<td>doublescan_allowed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=805>805</a></td>\n' +
            '<td>Whether the connector can handle doublescan.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=806>806</a></td>\n' +
            '<td>display_info</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=807>807</a></td>\n' +
            '<td>Display information is filled from EDID information when a display is detected. For non hot-pluggable displays such as flat panels in embedded systems, the driver should initialize the display_info.width_mm and display_info.height_mm fields with the physical size of the display.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=808>808</a></td>\n' +
            '<td>polled</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=809>809</a></td>\n' +
            '<td>Connector polling mode, a combination of</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=810>810</a></td>\n' +
            '<td>DRM_CONNECTOR_POLL_HPD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=811>811</a></td>\n' +
            '<td>The connector generates hotplug events and doesn' + "'" + 't need to be periodically polled. The CONNECT and DISCONNECT flags must not be set together with the HPD flag.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=812>812</a></td>\n' +
            '<td>DRM_CONNECTOR_POLL_CONNECT</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=813>813</a></td>\n' +
            '<td>Periodically poll the connector for connection.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=814>814</a></td>\n' +
            '<td>DRM_CONNECTOR_POLL_DISCONNECT</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=815>815</a></td>\n' +
            '<td>Periodically poll the connector for disconnection.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=816>816</a></td>\n' +
            '<td>Set to 0 for connectors that don' + "'" + 't support connection status discovery.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=817>817</a></td>\n' +
            '<td>The connector is then registered with a call to drm_connector_init with a pointer to the connector functions and a connector type, and exposed through sysfs with a call to drm_sysfs_connector_add.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=818>818</a></td>\n' +
            '<td>Supported connector types are</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=819>819</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_VGA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=820>820</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_DVII</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=821>821</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_DVID</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=822>822</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_DVIA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=823>823</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_Composite</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=824>824</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_SVIDEO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=825>825</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_LVDS</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=826>826</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_Component</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=827>827</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_9PinDIN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=828>828</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_DisplayPort</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=829>829</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_HDMIA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=830>830</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_HDMIB</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=831>831</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_TV</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=832>832</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_eDP</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=833>833</a></td>\n' +
            '<td>    DRM_MODE_CONNECTOR_VIRTUAL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=834>834</a></td>\n' +
            '<td>Connectors must be attached to an encoder to be used. For devices that map connectors to encoders 1:1, the connector should be attached at initialization time with a call to drm_mode_connector_attach_encoder. The driver must also set the drm_connector encoder field to point to the attached encoder.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=835>835</a></td>\n' +
            '<td>Finally, drivers must initialize the connectors state change detection with a call to drm_kms_helper_poll_init. If at least one connector is pollable but can' + "'" + 't generate hotplug interrupts (indicated by the DRM_CONNECTOR_POLL_CONNECT and DRM_CONNECTOR_POLL_DISCONNECT connector flags), a delayed work will automatically be queued to periodically poll for changes. Connectors that can generate hotplug interrupts must be marked with the DRM_CONNECTOR_POLL_HPD flag instead, and their interrupt handler must call drm_helper_hpd_irq_event. The function will queue a delayed work to check the state of all connectors, but no periodic polling will be done.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=836>836</a></td>\n' +
            '<td>Connector Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=837>837</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=838>838</a></td>\n' +
            '<td>Unless otherwise state, all operations are mandatory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=839>839</a></td>\n' +
            '<td>DPMS</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=840>840</a></td>\n' +
            '<td>void (*dpms)(struct drm_connector *connector, int mode);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=841>841</a></td>\n' +
            '<td>The DPMS operation sets the power state of a connector. The mode argument is one of</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=842>842</a></td>\n' +
            '<td>    DRM_MODE_DPMS_ON</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=843>843</a></td>\n' +
            '<td>    DRM_MODE_DPMS_STANDBY</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=844>844</a></td>\n' +
            '<td>    DRM_MODE_DPMS_SUSPEND</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=845>845</a></td>\n' +
            '<td>    DRM_MODE_DPMS_OFF</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=846>846</a></td>\n' +
            '<td>In all but DPMS_ON mode the encoder to which the connector is attached should put the display in low-power mode by driving its signals appropriately. If more than one connector is attached to the encoder care should be taken not to change the power state of other displays as a side effect. Low-power mode should be propagated to the encoders and CRTCs when all related connectors are put in low-power mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=847>847</a></td>\n' +
            '<td>Modes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=848>848</a></td>\n' +
            '<td>int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=849>849</a></td>\n' +
            '<td>Fill the mode list with all supported modes for the connector. If the max_width and max_height arguments are non-zero, the implementation must ignore all modes wider than max_width or higher than max_height.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=850>850</a></td>\n' +
            '<td>The connector must also fill in this operation its display_info width_mm and height_mm fields with the connected display physical size in millimeters. The fields should be set to 0 if the value isn' + "'" + 't known or is not applicable (for instance for projector devices).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=851>851</a></td>\n' +
            '<td>Connection Status</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=852>852</a></td>\n' +
            '<td>The connection status is updated through polling or hotplug events when supported (see term_title). The status value is reported to userspace through ioctls and must not be used inside the driver, as it only gets initialized by a call to drm_mode_getconnector from userspace.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=853>853</a></td>\n' +
            '<td>enum drm_connector_status (*detect)(struct drm_connector *connector, bool force);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=854>854</a></td>\n' +
            '<td>Check to see if anything is attached to the connector. The force parameter is set to false whilst polling or to true when checking the connector due to user request. force can be used by the driver to avoid expensive, destructive operations during automated probing.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=855>855</a></td>\n' +
            '<td>Return connector_status_connected if something is connected to the connector, connector_status_disconnected if nothing is connected and connector_status_unknown if the connection state isn' + "'" + 't known.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=856>856</a></td>\n' +
            '<td>Drivers should only return connector_status_connected if the connection status has really been probed as connected. Connectors that can' + "'" + 't detect the connection status, or failed connection status probes, should return connector_status_unknown.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=857>857</a></td>\n' +
            '<td>Miscellaneous</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=858>858</a></td>\n' +
            '<td>    void (*set_property)(struct drm_connector *connector, struct drm_property *property, uint64_t value);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=859>859</a></td>\n' +
            '<td>     Set the value of the given connector property to value. See ??? for more information about properties.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=860>860</a></td>\n' +
            '<td>    void (*destroy)(struct drm_connector *connector);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=861>861</a></td>\n' +
            '<td>     Destroy the connector when not needed anymore. See ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=862>862</a></td>\n' +
            '<td>Cleanup</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=863>863</a></td>\n' +
            '<td>The DRM core manages its objects' + "'" + ' lifetime. When an object is not needed anymore the core calls its destroy function, which must clean up and free every resource allocated for the object. Every drm_*_init call must be matched with a corresponding drm_*_cleanup call to cleanup CRTCs (drm_crtc_cleanup), planes (drm_plane_cleanup), encoders (drm_encoder_cleanup) and connectors (drm_connector_cleanup). Furthermore, connectors that have been added to sysfs must be removed by a call to drm_sysfs_connector_remove before calling drm_connector_cleanup.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=864>864</a></td>\n' +
            '<td>Connectors state change detection must be cleanup up with a call to drm_kms_helper_poll_fini.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=865>865</a></td>\n' +
            '<td>Output discovery and initialization example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=866>866</a></td>\n' +
            '<td>void intel_crt_init(struct drm_device *dev)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=867>867</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=868>868</a></td>\n' +
            '<td>    struct drm_connector *connector;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=869>869</a></td>\n' +
            '<td>    struct intel_output *intel_output;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=870>870</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=871>871</a></td>\n' +
            '<td>    intel_output = kzalloc(sizeof(struct intel_output), GFP_KERNEL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=872>872</a></td>\n' +
            '<td>    if (!intel_output)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=873>873</a></td>\n' +
            '<td>        return;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=874>874</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=875>875</a></td>\n' +
            '<td>    connector = &amp;intel_output-&gt;base;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=876>876</a></td>\n' +
            '<td>    drm_connector_init(dev, &amp;intel_output-&gt;base,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=877>877</a></td>\n' +
            '<td>               &amp;intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=878>878</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=879>879</a></td>\n' +
            '<td>    drm_encoder_init(dev, &amp;intel_output-&gt;enc, &amp;intel_crt_enc_funcs,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=880>880</a></td>\n' +
            '<td>             DRM_MODE_ENCODER_DAC);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=881>881</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=882>882</a></td>\n' +
            '<td>    drm_mode_connector_attach_encoder(&amp;intel_output-&gt;base,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=883>883</a></td>\n' +
            '<td>                      &amp;intel_output-&gt;enc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=884>884</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=885>885</a></td>\n' +
            '<td>    /* Set up the DDC bus. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=886>886</a></td>\n' +
            '<td>    intel_output-&gt;ddc_bus = intel_i2c_create(dev, GPIOA, "CRTDDC_A");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=887>887</a></td>\n' +
            '<td>    if (!intel_output-&gt;ddc_bus) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=888>888</a></td>\n' +
            '<td>        dev_printk(KERN_ERR, &amp;dev-&gt;pdev-&gt;dev, "DDC bus registration "</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=889>889</a></td>\n' +
            '<td>               "failed.\\n");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=890>890</a></td>\n' +
            '<td>        return;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=891>891</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=892>892</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=893>893</a></td>\n' +
            '<td>    intel_output-&gt;type = INTEL_OUTPUT_ANALOG;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=894>894</a></td>\n' +
            '<td>    connector-&gt;interlace_allowed = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=895>895</a></td>\n' +
            '<td>    connector-&gt;doublescan_allowed = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=896>896</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=897>897</a></td>\n' +
            '<td>    drm_encoder_helper_add(&amp;intel_output-&gt;enc, &amp;intel_crt_helper_funcs);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=898>898</a></td>\n' +
            '<td>    drm_connector_helper_add(connector, &amp;intel_crt_connector_helper_funcs);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=899>899</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=900>900</a></td>\n' +
            '<td>    drm_sysfs_connector_add(connector);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=901>901</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=902>902</a></td>\n' +
            '<td>In the example above (taken from the i915 driver), a CRTC, connector and encoder combination is created. A device-specific i2c bus is also created for fetching EDID data and performing monitor detection. Once the process is complete, the new connector is registered with sysfs to make its properties available to applications.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=903>903</a></td>\n' +
            '<td>KMS API Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=904>904</a></td>\n' +
            '<td>!Edrivers/gpu/drm/drm_crtc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=905>905</a></td>\n' +
            '<td>Mode Setting Helper Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=906>906</a></td>\n' +
            '<td>The CRTC, encoder and connector functions provided by the drivers implement the DRM API. They' + "'" + 're called by the DRM core and ioctl handlers to handle device state changes and configuration request. As implementing those functions often requires logic not specific to drivers, mid-layer helper functions are available to avoid duplicating boilerplate code.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=907>907</a></td>\n' +
            '<td>The DRM core contains one mid-layer implementation. The mid-layer provides implementations of several CRTC, encoder and connector functions (called from the top of the mid-layer) that pre-process requests and call lower-level functions provided by the driver (at the bottom of the mid-layer). For instance, the drm_crtc_helper_set_config function can be used to fill the struct drm_crtc_funcs set_config field. When called, it will split the set_config operation in smaller, simpler operations and call the driver to handle them.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=908>908</a></td>\n' +
            '<td>To use the mid-layer, drivers call drm_crtc_helper_add, drm_encoder_helper_add and drm_connector_helper_add functions to install their mid-layer bottom operations handlers, and fill the drm_crtc_funcs, drm_encoder_funcs and drm_connector_funcs structures with pointers to the mid-layer top API functions. Installing the mid-layer bottom operation handlers is best done right after registering the corresponding KMS object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=909>909</a></td>\n' +
            '<td>The mid-layer is not split between CRTC, encoder and connector operations. To use it, a driver must provide bottom functions for all of the three KMS entities.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=910>910</a></td>\n' +
            '<td>Helper Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=911>911</a></td>\n' +
            '<td>    int drm_crtc_helper_set_config(struct drm_mode_set *set);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=912>912</a></td>\n' +
            '<td>     The drm_crtc_helper_set_config helper function is a CRTC set_config implementation. It first tries to locate the best encoder for each connector by calling the connector best_encoder helper operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=913>913</a></td>\n' +
            '<td>     After locating the appropriate encoders, the helper function will call the mode_fixup encoder and CRTC helper operations to adjust the requested mode, or reject it completely in which case an error will be returned to the application. If the new configuration after mode adjustment is identical to the current configuration the helper function will return without performing any other operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=914>914</a></td>\n' +
            '<td>     If the adjusted mode is identical to the current mode but changes to the frame buffer need to be applied, the drm_crtc_helper_set_config function will call the CRTC mode_set_base helper operation. If the adjusted mode differs from the current mode, or if the mode_set_base helper operation is not provided, the helper function performs a full mode set sequence by calling the prepare, mode_set and commit CRTC and encoder helper operations, in that order.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=915>915</a></td>\n' +
            '<td>    void drm_helper_connector_dpms(struct drm_connector *connector, int mode);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=916>916</a></td>\n' +
            '<td>     The drm_helper_connector_dpms helper function is a connector dpms implementation that tracks power state of connectors. To use the function, drivers must provide dpms helper operations for CRTCs and encoders to apply the DPMS state to the device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=917>917</a></td>\n' +
            '<td>     The mid-layer doesn' + "'" + 't track the power state of CRTCs and encoders. The dpms helper operations can thus be called with a mode identical to the currently active mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=918>918</a></td>\n' +
            '<td>    int drm_helper_probe_single_connector_modes(struct drm_connector *connector, uint32_t maxX, uint32_t maxY);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=919>919</a></td>\n' +
            '<td>     The drm_helper_probe_single_connector_modes helper function is a connector fill_modes implementation that updates the connection status for the connector and then retrieves a list of modes by calling the connector get_modes helper operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=920>920</a></td>\n' +
            '<td>     The function filters out modes larger than max_width and max_height if specified. It then calls the connector mode_valid helper operation for each mode in the probed list to check whether the mode is valid for the connector.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=921>921</a></td>\n' +
            '<td>CRTC Helper Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=922>922</a></td>\n' +
            '<td>    bool (*mode_fixup)(struct drm_crtc *crtc, const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=923>923</a></td>\n' +
            '<td>     Let CRTCs adjust the requested mode or reject it completely. This operation returns true if the mode is accepted (possibly after being adjusted) or false if it is rejected.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=924>924</a></td>\n' +
            '<td>     The mode_fixup operation should reject the mode if it can' + "'" + 't reasonably use it. The definition of "reasonable" is currently fuzzy in this context. One possible behaviour would be to set the adjusted mode to the panel timings when a fixed-mode panel is used with hardware capable of scaling. Another behaviour would be to accept any input mode and adjust it to the closest mode supported by the hardware (FIXME: This needs to be clarified).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=925>925</a></td>\n' +
            '<td>    int (*mode_set_base)(struct drm_crtc *crtc, int x, int y, struct drm_framebuffer *old_fb)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=926>926</a></td>\n' +
            '<td>     Move the CRTC on the current frame buffer (stored in crtc-&gt;fb) to position (x,y). Any of the frame buffer, x position or y position may have been modified.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=927>927</a></td>\n' +
            '<td>     This helper operation is optional. If not provided, the drm_crtc_helper_set_config function will fall back to the mode_set helper operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=928>928</a></td>\n' +
            '<td>     Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=929>929</a></td>\n' +
            '<td>     FIXME: Why are x and y passed as arguments, as they can be accessed through crtc-&gt;x and crtc-&gt;y?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=930>930</a></td>\n' +
            '<td>    void (*prepare)(struct drm_crtc *crtc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=931>931</a></td>\n' +
            '<td>     Prepare the CRTC for mode setting. This operation is called after validating the requested mode. Drivers use it to perform device-specific operations required before setting the new mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=932>932</a></td>\n' +
            '<td>    int (*mode_set)(struct drm_crtc *crtc, struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode, int x, int y, struct drm_framebuffer *old_fb);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=933>933</a></td>\n' +
            '<td>     Set a new mode, position and frame buffer. Depending on the device requirements, the mode can be stored internally by the driver and applied in the commit operation, or programmed to the hardware immediately.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=934>934</a></td>\n' +
            '<td>     The mode_set operation returns 0 on success or a negative error code if an error occurs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=935>935</a></td>\n' +
            '<td>    void (*commit)(struct drm_crtc *crtc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=936>936</a></td>\n' +
            '<td>     Commit a mode. This operation is called after setting the new mode. Upon return the device must use the new mode and be fully operational.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=937>937</a></td>\n' +
            '<td>Encoder Helper Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=938>938</a></td>\n' +
            '<td>    bool (*mode_fixup)(struct drm_encoder *encoder, const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=939>939</a></td>\n' +
            '<td>     Let encoders adjust the requested mode or reject it completely. This operation returns true if the mode is accepted (possibly after being adjusted) or false if it is rejected. See the mode_fixup CRTC helper operation for an explanation of the allowed adjustments.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=940>940</a></td>\n' +
            '<td>    void (*prepare)(struct drm_encoder *encoder);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=941>941</a></td>\n' +
            '<td>     Prepare the encoder for mode setting. This operation is called after validating the requested mode. Drivers use it to perform device-specific operations required before setting the new mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=942>942</a></td>\n' +
            '<td>    void (*mode_set)(struct drm_encoder *encoder, struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=943>943</a></td>\n' +
            '<td>     Set a new mode. Depending on the device requirements, the mode can be stored internally by the driver and applied in the commit operation, or programmed to the hardware immediately.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=944>944</a></td>\n' +
            '<td>    void (*commit)(struct drm_encoder *encoder);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=945>945</a></td>\n' +
            '<td>     Commit a mode. This operation is called after setting the new mode. Upon return the device must use the new mode and be fully operational.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=946>946</a></td>\n' +
            '<td>Connector Helper Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=947>947</a></td>\n' +
            '<td>    struct drm_encoder *(*best_encoder)(struct drm_connector *connector);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=948>948</a></td>\n' +
            '<td>     Return a pointer to the best encoder for the connecter. Device that map connectors to encoders 1:1 simply return the pointer to the associated encoder. This operation is mandatory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=949>949</a></td>\n' +
            '<td>    int (*get_modes)(struct drm_connector *connector);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=950>950</a></td>\n' +
            '<td>     Fill the connector' + "'" + 's probed_modes list by parsing EDID data with drm_add_edid_modes or calling drm_mode_probed_add directly for every supported mode and return the number of modes it has detected. This operation is mandatory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=951>951</a></td>\n' +
            '<td>     When adding modes manually the driver creates each mode with a call to drm_mode_create and must fill the following fields.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=952>952</a></td>\n' +
            '<td>    __u32 type;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=953>953</a></td>\n' +
            '<td>     Mode type bitmask, a combination of</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=954>954</a></td>\n' +
            '<td>     DRM_MODE_TYPE_BUILTIN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=955>955</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=956>956</a></td>\n' +
            '<td>     DRM_MODE_TYPE_CLOCK_C</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=957>957</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=958>958</a></td>\n' +
            '<td>     DRM_MODE_TYPE_CRTC_C</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=959>959</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=960>960</a></td>\n' +
            '<td>     DRM_MODE_TYPE_PREFERRED - The preferred mode for the connector</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=961>961</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=962>962</a></td>\n' +
            '<td>     DRM_MODE_TYPE_DEFAULT</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=963>963</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=964>964</a></td>\n' +
            '<td>     DRM_MODE_TYPE_USERDEF</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=965>965</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=966>966</a></td>\n' +
            '<td>     DRM_MODE_TYPE_DRIVER</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=967>967</a></td>\n' +
            '<td>     The mode has been created by the driver (as opposed to to user-created modes).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=968>968</a></td>\n' +
            '<td>     Drivers must set the DRM_MODE_TYPE_DRIVER bit for all modes they create, and set the DRM_MODE_TYPE_PREFERRED bit for the preferred mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=969>969</a></td>\n' +
            '<td>    __u32 clock;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=970>970</a></td>\n' +
            '<td>     Pixel clock frequency in kHz unit</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=971>971</a></td>\n' +
            '<td>    __u16 hdisplay, hsync_start, hsync_end, htotal; __u16 vdisplay, vsync_start, vsync_end, vtotal;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=972>972</a></td>\n' +
            '<td>     Horizontal and vertical timing information</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=973>973</a></td>\n' +
            '<td>                  Active                 Front           Sync           Back</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=974>974</a></td>\n' +
            '<td>             Region                 Porch                          Porch</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=975>975</a></td>\n' +
            '<td>    &lt;-----------------------&gt;&lt;----------------&gt;&lt;-------------&gt;&lt;--------------&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=976>976</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=977>977</a></td>\n' +
            '<td>      //////////////////////|</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=978>978</a></td>\n' +
            '<td>     ////////////////////// |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=979>979</a></td>\n' +
            '<td>    //////////////////////  |..................               ................</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=980>980</a></td>\n' +
            '<td>                                               _______________</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=981>981</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=982>982</a></td>\n' +
            '<td>    &lt;----- [hv]display -----&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=983>983</a></td>\n' +
            '<td>    &lt;------------- [hv]sync_start ------------&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=984>984</a></td>\n' +
            '<td>    &lt;--------------------- [hv]sync_end ---------------------&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=985>985</a></td>\n' +
            '<td>    &lt;-------------------------------- [hv]total -----------------------------&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=986>986</a></td>\n' +
            '<td>    __u16 hskew; __u16 vscan;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=987>987</a></td>\n' +
            '<td>     Unknown</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=988>988</a></td>\n' +
            '<td>    __u32 flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=989>989</a></td>\n' +
            '<td>     Mode flags, a combination of</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=990>990</a></td>\n' +
            '<td>     DRM_MODE_FLAG_PHSYNC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=991>991</a></td>\n' +
            '<td>     Horizontal sync is active high</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=992>992</a></td>\n' +
            '<td>     DRM_MODE_FLAG_NHSYNC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=993>993</a></td>\n' +
            '<td>     Horizontal sync is active low</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=994>994</a></td>\n' +
            '<td>     DRM_MODE_FLAG_PVSYNC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=995>995</a></td>\n' +
            '<td>     Vertical sync is active high</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=996>996</a></td>\n' +
            '<td>     DRM_MODE_FLAG_NVSYNC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=997>997</a></td>\n' +
            '<td>     Vertical sync is active low</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=998>998</a></td>\n' +
            '<td>     DRM_MODE_FLAG_INTERLACE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=999>999</a></td>\n' +
            '<td>     Mode is interlaced</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1000>1000</a></td>\n' +
            '<td>     DRM_MODE_FLAG_DBLSCAN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1001>1001</a></td>\n' +
            '<td>     Mode uses doublescan</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1002>1002</a></td>\n' +
            '<td>     DRM_MODE_FLAG_CSYNC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1003>1003</a></td>\n' +
            '<td>     Mode uses composite sync</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1004>1004</a></td>\n' +
            '<td>     DRM_MODE_FLAG_PCSYNC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1005>1005</a></td>\n' +
            '<td>     Composite sync is active high</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1006>1006</a></td>\n' +
            '<td>     DRM_MODE_FLAG_NCSYNC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1007>1007</a></td>\n' +
            '<td>     Composite sync is active low</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1008>1008</a></td>\n' +
            '<td>     DRM_MODE_FLAG_HSKEW</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1009>1009</a></td>\n' +
            '<td>     hskew provided (not used?)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1010>1010</a></td>\n' +
            '<td>     DRM_MODE_FLAG_BCAST</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1011>1011</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1012>1012</a></td>\n' +
            '<td>     DRM_MODE_FLAG_PIXMUX</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1013>1013</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1014>1014</a></td>\n' +
            '<td>     DRM_MODE_FLAG_DBLCLK</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1015>1015</a></td>\n' +
            '<td>     not used?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1016>1016</a></td>\n' +
            '<td>     DRM_MODE_FLAG_CLKDIV2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1017>1017</a></td>\n' +
            '<td>     ?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1018>1018</a></td>\n' +
            '<td>     Note that modes marked with the INTERLACE or DBLSCAN flags will be filtered out by drm_helper_probe_single_connector_modes if the connector' + "'" + 's interlace_allowed or doublescan_allowed field is set to 0.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1019>1019</a></td>\n' +
            '<td>    char name[DRM_DISPLAY_MODE_LEN];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1020>1020</a></td>\n' +
            '<td>     Mode name. The driver must call drm_mode_set_name to fill the mode name from hdisplay, vdisplay and interlace flag after filling the corresponding fields.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1021>1021</a></td>\n' +
            '<td>     The vrefresh value is computed by drm_helper_probe_single_connector_modes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1022>1022</a></td>\n' +
            '<td>     When parsing EDID data, drm_add_edid_modes fill the connector display_info width_mm and height_mm fields. When creating modes manually the get_modes helper operation must set the display_info width_mm and height_mm fields if they haven' + "'" + 't been set already (for instance at initilization time when a fixed-size panel is attached to the connector). The mode width_mm and height_mm fields are only used internally during EDID parsing and should not be set when creating modes manually.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1023>1023</a></td>\n' +
            '<td>    int (*mode_valid)(struct drm_connector *connector, struct drm_display_mode *mode);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1024>1024</a></td>\n' +
            '<td>     Verify whether a mode is valid for the connector. Return MODE_OK for supported modes and one of the enum drm_mode_status values (MODE_*) for unsupported modes. This operation is mandatory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1025>1025</a></td>\n' +
            '<td>     As the mode rejection reason is currently not used beside for immediately removing the unsupported mode, an implementation can return MODE_BAD regardless of the exact reason why the mode is not valid.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1026>1026</a></td>\n' +
            '<td>     Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1027>1027</a></td>\n' +
            '<td>     Note that the mode_valid helper operation is only called for modes detected by the device, and not for modes set by the user through the CRTC set_config operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1028>1028</a></td>\n' +
            '<td>Modeset Helper Functions Reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1029>1029</a></td>\n' +
            '<td>!Edrivers/gpu/drm/drm_crtc_helper.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1030>1030</a></td>\n' +
            '<td>fbdev Helper Functions Reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1031>1031</a></td>\n' +
            '<td>!Pdrivers/gpu/drm/drm_fb_helper.c fbdev helpers !Edrivers/gpu/drm/drm_fb_helper.c !Iinclude/drm/drm_fb_helper.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1032>1032</a></td>\n' +
            '<td>Display Port Helper Functions Reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1033>1033</a></td>\n' +
            '<td>!Pdrivers/gpu/drm/drm_dp_helper.c dp helpers !Iinclude/drm/drm_dp_helper.h !Edrivers/gpu/drm/drm_dp_helper.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1034>1034</a></td>\n' +
            '<td>EDID Helper Functions Reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1035>1035</a></td>\n' +
            '<td>!Edrivers/gpu/drm/drm_edid.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1036>1036</a></td>\n' +
            '<td>Rectangle Utilities Reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1037>1037</a></td>\n' +
            '<td>!Pinclude/drm/drm_rect.h rect utils !Iinclude/drm/drm_rect.h !Edrivers/gpu/drm/drm_rect.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1038>1038</a></td>\n' +
            '<td>Flip-work Helper Reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1039>1039</a></td>\n' +
            '<td>!Pinclude/drm/drm_flip_work.h flip utils !Iinclude/drm/drm_flip_work.h !Edrivers/gpu/drm/drm_flip_work.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1040>1040</a></td>\n' +
            '<td>VMA Offset Manager</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1041>1041</a></td>\n' +
            '<td>!Pdrivers/gpu/drm/drm_vma_manager.c vma offset manager !Edrivers/gpu/drm/drm_vma_manager.c !Iinclude/drm/drm_vma_manager.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1042>1042</a></td>\n' +
            '<td>KMS Properties</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1043>1043</a></td>\n' +
            '<td>Drivers may need to expose additional parameters to applications than those described in the previous sections. KMS supports attaching properties to CRTCs, connectors and planes and offers a userspace API to list, get and set the property values.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1044>1044</a></td>\n' +
            '<td>Properties are identified by a name that uniquely defines the property purpose, and store an associated value. For all property types except blob properties the value is a 64-bit unsigned integer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1045>1045</a></td>\n' +
            '<td>KMS differentiates between properties and property instances. Drivers first create properties and then create and associate individual instances of those properties to objects. A property can be instantiated multiple times and associated with different objects. Values are stored in property instances, and all other property information are stored in the propery and shared between all instances of the property.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1046>1046</a></td>\n' +
            '<td>Every property is created with a type that influences how the KMS core handles the property. Supported property types are</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1047>1047</a></td>\n' +
            '<td>DRM_MODE_PROP_RANGE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1048>1048</a></td>\n' +
            '<td>Range properties report their minimum and maximum admissible values. The KMS core verifies that values set by application fit in that range.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1049>1049</a></td>\n' +
            '<td>DRM_MODE_PROP_ENUM</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1050>1050</a></td>\n' +
            '<td>Enumerated properties take a numerical value that ranges from 0 to the number of enumerated values defined by the property minus one, and associate a free-formed string name to each value. Applications can retrieve the list of defined value-name pairs and use the numerical value to get and set property instance values.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1051>1051</a></td>\n' +
            '<td>DRM_MODE_PROP_BITMASK</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1052>1052</a></td>\n' +
            '<td>Bitmask properties are enumeration properties that additionally restrict all enumerated values to the 0..63 range. Bitmask property instance values combine one or more of the enumerated bits defined by the property.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1053>1053</a></td>\n' +
            '<td>DRM_MODE_PROP_BLOB</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1054>1054</a></td>\n' +
            '<td>Blob properties store a binary blob without any format restriction. The binary blobs are created as KMS standalone objects, and blob property instance values store the ID of their associated blob object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1055>1055</a></td>\n' +
            '<td>Blob properties are only used for the connector EDID property and cannot be created by drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1056>1056</a></td>\n' +
            '<td>To create a property drivers call one of the following functions depending on the property type. All property creation functions take property flags and name, as well as type-specific arguments.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1057>1057</a></td>\n' +
            '<td>    struct drm_property *drm_property_create_range(struct drm_device *dev, int flags, const char *name, uint64_t min, uint64_t max);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1058>1058</a></td>\n' +
            '<td>     Create a range property with the given minimum and maximum values.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1059>1059</a></td>\n' +
            '<td>    struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags, const char *name, const struct drm_prop_enum_list *props, int num_values);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1060>1060</a></td>\n' +
            '<td>     Create an enumerated property. The props argument points to an array of num_values value-name pairs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1061>1061</a></td>\n' +
            '<td>    struct drm_property *drm_property_create_bitmask(struct drm_device *dev, int flags, const char *name, const struct drm_prop_enum_list *props, int num_values);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1062>1062</a></td>\n' +
            '<td>     Create a bitmask property. The props argument points to an array of num_values value-name pairs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1063>1063</a></td>\n' +
            '<td>Properties can additionally be created as immutable, in which case they will be read-only for applications but can be modified by the driver. To create an immutable property drivers must set the DRM_MODE_PROP_IMMUTABLE flag at property creation time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1064>1064</a></td>\n' +
            '<td>When no array of value-name pairs is readily available at property creation time for enumerated or range properties, drivers can create the property using the drm_property_create function and manually add enumeration value-name pairs by calling the drm_property_add_enum function. Care must be taken to properly specify the property type through the flags argument.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1065>1065</a></td>\n' +
            '<td>After creating properties drivers can attach property instances to CRTC, connector and plane objects by calling the drm_object_attach_property. The function takes a pointer to the target object, a pointer to the previously created property and an initial instance value.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1066>1066</a></td>\n' +
            '<td>Vertical Blanking</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1067>1067</a></td>\n' +
            '<td>Vertical blanking plays a major role in graphics rendering. To achieve tear-free display, users must synchronize page flips and/or rendering to vertical blanking. The DRM API offers ioctls to perform page flips synchronized to vertical blanking and wait for vertical blanking.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1068>1068</a></td>\n' +
            '<td>The DRM core handles most of the vertical blanking management logic, which involves filtering out spurious interrupts, keeping race-free blanking counters, coping with counter wrap-around and resets and keeping use counts. It relies on the driver to generate vertical blanking interrupts and optionally provide a hardware vertical blanking counter. Drivers must implement the following operations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1069>1069</a></td>\n' +
            '<td>    int (*enable_vblank) (struct drm_device *dev, int crtc); void (*disable_vblank) (struct drm_device *dev, int crtc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1070>1070</a></td>\n' +
            '<td>     Enable or disable vertical blanking interrupts for the given CRTC.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1071>1071</a></td>\n' +
            '<td>    u32 (*get_vblank_counter) (struct drm_device *dev, int crtc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1072>1072</a></td>\n' +
            '<td>     Retrieve the value of the vertical blanking counter for the given CRTC. If the hardware maintains a vertical blanking counter its value should be returned. Otherwise drivers can use the drm_vblank_count helper function to handle this operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1073>1073</a></td>\n' +
            '<td>Drivers must initialize the vertical blanking handling core with a call to drm_vblank_init in their load operation. The function will set the struct drm_device vblank_disable_allowed field to 0. This will keep vertical blanking interrupts enabled permanently until the first mode set operation, where vblank_disable_allowed is set to 1. The reason behind this is not clear. Drivers can set the field to 1 after calling drm_vblank_init to make vertical blanking interrupts dynamically managed from the beginning.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1074>1074</a></td>\n' +
            '<td>Vertical blanking interrupts can be enabled by the DRM core or by drivers themselves (for instance to handle page flipping operations). The DRM core maintains a vertical blanking use count to ensure that the interrupts are not disabled while a user still needs them. To increment the use count, drivers call drm_vblank_get. Upon return vertical blanking interrupts are guaranteed to be enabled.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1075>1075</a></td>\n' +
            '<td>To decrement the use count drivers call drm_vblank_put. Only when the use count drops to zero will the DRM core disable the vertical blanking interrupts after a delay by scheduling a timer. The delay is accessible through the vblankoffdelay module parameter or the drm_vblank_offdelay global variable and expressed in milliseconds. Its default value is 5000 ms.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1076>1076</a></td>\n' +
            '<td>When a vertical blanking interrupt occurs drivers only need to call the drm_handle_vblank function to account for the interrupt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1077>1077</a></td>\n' +
            '<td>Resources allocated by drm_vblank_init must be freed with a call to drm_vblank_cleanup in the driver unload operation handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1078>1078</a></td>\n' +
            '<td>Open/Close, File Operations and IOCTLs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1079>1079</a></td>\n' +
            '<td>Open and Close</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1080>1080</a></td>\n' +
            '<td>int (*firstopen) (struct drm_device *); void (*lastclose) (struct drm_device *); int (*open) (struct drm_device *, struct drm_file *); void (*preclose) (struct drm_device *, struct drm_file *); void (*postclose) (struct drm_device *, struct drm_file *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1081>1081</a></td>\n' +
            '<td>Open and close handlers. None of those methods are mandatory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1082>1082</a></td>\n' +
            '<td>The firstopen method is called by the DRM core for legacy UMS (User Mode Setting) drivers only when an application opens a device that has no other opened file handle. UMS drivers can implement it to acquire device resources. KMS drivers can' + "'" + 't use the method and must acquire resources in the load method instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1083>1083</a></td>\n' +
            '<td>Similarly the lastclose method is called when the last application holding a file handle opened on the device closes it, for both UMS and KMS drivers. Additionally, the method is also called at module unload time or, for hot-pluggable devices, when the device is unplugged. The firstopen and lastclose calls can thus be unbalanced.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1084>1084</a></td>\n' +
            '<td>The open method is called every time the device is opened by an application. Drivers can allocate per-file private data in this method and store them in the struct drm_file driver_priv field. Note that the open method is called before firstopen.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1085>1085</a></td>\n' +
            '<td>The close operation is split into preclose and postclose methods. Drivers must stop and cleanup all per-file operations in the preclose method. For instance pending vertical blanking and page flip events must be cancelled. No per-file operation is allowed on the file handle after returning from the preclose method.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1086>1086</a></td>\n' +
            '<td>Finally the postclose method is called as the last step of the close operation, right before calling the lastclose method if no other open file handle exists for the device. Drivers that have allocated per-file private data in the open method should free it here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1087>1087</a></td>\n' +
            '<td>The lastclose method should restore CRTC and plane properties to default value, so that a subsequent open of the device will not inherit state from the previous user. It can also be used to execute delayed power switching state changes, e.g. in conjunction with the vga-switcheroo infrastructure. Beyond that KMS drivers should not do any further cleanup. Only legacy UMS drivers might need to clean up device state so that the vga console or an independent fbdev driver could take over.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1088>1088</a></td>\n' +
            '<td>File Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1089>1089</a></td>\n' +
            '<td>const struct file_operations *fops</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1090>1090</a></td>\n' +
            '<td>File operations for the DRM device node.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1091>1091</a></td>\n' +
            '<td>Drivers must define the file operations structure that forms the DRM userspace API entry point, even though most of those operations are implemented in the DRM core. The open, release and ioctl operations are handled by</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1092>1092</a></td>\n' +
            '<td>    .owner = THIS_MODULE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1093>1093</a></td>\n' +
            '<td>    .open = drm_open,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1094>1094</a></td>\n' +
            '<td>    .release = drm_release,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1095>1095</a></td>\n' +
            '<td>    .unlocked_ioctl = drm_ioctl,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1096>1096</a></td>\n' +
            '<td>  #ifdef CONFIG_COMPAT</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1097>1097</a></td>\n' +
            '<td>    .compat_ioctl = drm_compat_ioctl,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1098>1098</a></td>\n' +
            '<td>  #endif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1099>1099</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1100>1100</a></td>\n' +
            '<td>Drivers that implement private ioctls that requires 32/64bit compatibility support must provide their own compat_ioctl handler that processes private ioctls and calls drm_compat_ioctl for core ioctls.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1101>1101</a></td>\n' +
            '<td>The read and poll operations provide support for reading DRM events and polling them. They are implemented by</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1102>1102</a></td>\n' +
            '<td>    .poll = drm_poll,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1103>1103</a></td>\n' +
            '<td>    .read = drm_read,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1104>1104</a></td>\n' +
            '<td>    .llseek = no_llseek,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1105>1105</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1106>1106</a></td>\n' +
            '<td>The memory mapping implementation varies depending on how the driver manages memory. Pre-GEM drivers will use drm_mmap, while GEM-aware drivers will use drm_gem_mmap. See ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1107>1107</a></td>\n' +
            '<td>    .mmap = drm_gem_mmap,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1108>1108</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1109>1109</a></td>\n' +
            '<td>No other file operation is supported by the DRM API.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1110>1110</a></td>\n' +
            '<td>IOCTLs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1111>1111</a></td>\n' +
            '<td>struct drm_ioctl_desc *ioctls; int num_ioctls;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1112>1112</a></td>\n' +
            '<td>Driver-specific ioctls descriptors table.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1113>1113</a></td>\n' +
            '<td>Driver-specific ioctls numbers start at DRM_COMMAND_BASE. The ioctls descriptors table is indexed by the ioctl number offset from the base value. Drivers can use the DRM_IOCTL_DEF_DRV() macro to initialize the table entries.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1114>1114</a></td>\n' +
            '<td>DRM_IOCTL_DEF_DRV(ioctl, func, flags)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1115>1115</a></td>\n' +
            '<td>ioctl is the ioctl name. Drivers must define the DRM_##ioctl and DRM_IOCTL_##ioctl macros to the ioctl number offset from DRM_COMMAND_BASE and the ioctl number respectively. The first macro is private to the device while the second must be exposed to userspace in a public header.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1116>1116</a></td>\n' +
            '<td>func is a pointer to the ioctl handler function compatible with the drm_ioctl_t type.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1117>1117</a></td>\n' +
            '<td>typedef int drm_ioctl_t(struct drm_device *dev, void *data,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1118>1118</a></td>\n' +
            '<td>        struct drm_file *file_priv);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1119>1119</a></td>\n' +
            '<td>flags is a bitmask combination of the following values. It restricts how the ioctl is allowed to be called.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1120>1120</a></td>\n' +
            '<td>    DRM_AUTH - Only authenticated callers allowed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1121>1121</a></td>\n' +
            '<td>    DRM_MASTER - The ioctl can only be called on the master file handle</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1122>1122</a></td>\n' +
            '<td>    DRM_ROOT_ONLY - Only callers with the SYSADMIN capability allowed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1123>1123</a></td>\n' +
            '<td>    DRM_CONTROL_ALLOW - The ioctl can only be called on a control device</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1124>1124</a></td>\n' +
            '<td>    DRM_UNLOCKED - The ioctl handler will be called without locking the DRM global mutex</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1125>1125</a></td>\n' +
            '<td>Command submission &amp; fencing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1126>1126</a></td>\n' +
            '<td>This should cover a few device-specific command submission implementations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1127>1127</a></td>\n' +
            '<td>Suspend/Resume</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1128>1128</a></td>\n' +
            '<td>The DRM core provides some suspend/resume code, but drivers wanting full suspend/resume support should provide save() and restore() functions. These are called at suspend, hibernate, or resume time, and should perform any state save or restore required by your device across suspend or hibernate states.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1129>1129</a></td>\n' +
            '<td>int (*suspend) (struct drm_device *, pm_message_t state); int (*resume) (struct drm_device *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1130>1130</a></td>\n' +
            '<td>Those are legacy suspend and resume methods. New driver should use the power management interface provided by their bus type (usually through the struct device_driver dev_pm_ops) and set these methods to NULL.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1131>1131</a></td>\n' +
            '<td>DMA services</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1132>1132</a></td>\n' +
            '<td>This should cover how DMA mapping etc. is supported by the core. These functions are deprecated and should not be used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1133>1133</a></td>\n' +
            '<td>Userland interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1134>1134</a></td>\n' +
            '<td>The DRM core exports several interfaces to applications, generally intended to be used through corresponding libdrm wrapper functions. In addition, drivers export device-specific interfaces for use by userspace drivers &amp; device-aware applications through ioctls and sysfs files.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1135>1135</a></td>\n' +
            '<td>External interfaces include: memory mapping, context management, DMA operations, AGP management, vblank control, fence management, memory management, and output management.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1136>1136</a></td>\n' +
            '<td>Cover generic ioctls and sysfs layout here. We only need high-level info, since man pages should cover the rest.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1137>1137</a></td>\n' +
            '<td>Render nodes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1138>1138</a></td>\n' +
            '<td>DRM core provides multiple character-devices for user-space to use. Depending on which device is opened, user-space can perform a different set of operations (mainly ioctls). The primary node is always created and called card&lt;num&gt;. Additionally, a currently unused control node, called controlD&lt;num&gt; is also created. The primary node provides all legacy operations and historically was the only interface used by userspace. With KMS, the control node was introduced. However, the planned KMS control interface has never been written and so the control node stays unused to date.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1139>1139</a></td>\n' +
            '<td>With the increased use of offscreen renderers and GPGPU applications, clients no longer require running compositors or graphics servers to make use of a GPU. But the DRM API required unprivileged clients to authenticate to a DRM-Master prior to getting GPU access. To avoid this step and to grant clients GPU access without authenticating, render nodes were introduced. Render nodes solely serve render clients, that is, no modesetting or privileged ioctls can be issued on render nodes. Only non-global rendering commands are allowed. If a driver supports render nodes, it must advertise it via the DRIVER_RENDER DRM driver capability. If not supported, the primary node must be used for render clients together with the legacy drmAuth authentication procedure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1140>1140</a></td>\n' +
            '<td>If a driver advertises render node support, DRM core will create a separate render node called renderD&lt;num&gt;. There will be one render node per device. No ioctls except PRIME-related ioctls will be allowed on this node. Especially GEM_OPEN will be explicitly prohibited. Render nodes are designed to avoid the buffer-leaks, which occur if clients guess the flink names or mmap offsets on the legacy interface. Additionally to this basic interface, drivers must mark their driver-dependent render-only ioctls as DRM_RENDER_ALLOW so render clients can use them. Driver authors must be careful not to allow any privileged ioctls on render nodes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1141>1141</a></td>\n' +
            '<td>With render nodes, user-space can now control access to the render node via basic file-system access-modes. A running graphics server which authenticates clients on the privileged primary/legacy node is no longer required. Instead, a client can open the render node and is immediately granted GPU access. Communication between clients (or servers) is done via PRIME. FLINK from render node to legacy node is not supported. New clients must not use the insecure FLINK interface.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1142>1142</a></td>\n' +
            '<td>Besides dropping all modeset/global ioctls, render nodes also drop the DRM-Master concept. There is no reason to associate render clients with a DRM-Master as they are independent of any graphics server. Besides, they must work without any running master, anyway. Drivers must be able to run without a master object if they support render nodes. If, on the other hand, a driver requires shared state between clients which is visible to user-space and accessible beyond open-file boundaries, they cannot support render nodes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1143>1143</a></td>\n' +
            '<td>VBlank event handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1144>1144</a></td>\n' +
            '<td>The DRM core exposes two vertical blank related ioctls:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1145>1145</a></td>\n' +
            '<td>DRM_IOCTL_WAIT_VBLANK</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1146>1146</a></td>\n' +
            '<td>This takes a struct drm_wait_vblank structure as its argument, and it is used to block or request a signal when a specified vblank event occurs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1147>1147</a></td>\n' +
            '<td>DRM_IOCTL_MODESET_CTL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1148>1148</a></td>\n' +
            '<td>This should be called by application level drivers before and after mode setting, since on many devices the vertical blank counter is reset at that time. Internally, the DRM snapshots the last vblank count when the ioctl is called with the _DRM_PRE_MODESET command, so that the counter won' + "'" + 't go backwards (which is dealt with when _DRM_POST_MODESET is used).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1149>1149</a></td>\n' +
            '<td>DRM Driver API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1150>1150</a></td>\n' +
            '<td>Include auto-generated API reference here (need to reference it from paragraphs above too).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1151>1151</a></td>\n' +
            '<td>The Linux VFS</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1152>1152</a></td>\n' +
            '<td>The Filesystem types</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1153>1153</a></td>\n' +
            '<td>!Iinclude/linux/fs.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1154>1154</a></td>\n' +
            '<td>The Directory Cache</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1155>1155</a></td>\n' +
            '<td>!Efs/dcache.c !Iinclude/linux/dcache.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1156>1156</a></td>\n' +
            '<td>Inode Handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1157>1157</a></td>\n' +
            '<td>!Efs/inode.c !Efs/bad_inode.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1158>1158</a></td>\n' +
            '<td>Registration and Superblocks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1159>1159</a></td>\n' +
            '<td>!Efs/super.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1160>1160</a></td>\n' +
            '<td>File Locks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1161>1161</a></td>\n' +
            '<td>!Efs/locks.c !Ifs/locks.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1162>1162</a></td>\n' +
            '<td>Other Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1163>1163</a></td>\n' +
            '<td>!Efs/mpage.c !Efs/namei.c !Efs/buffer.c !Efs/bio.c !Efs/seq_file.c !Efs/filesystems.c !Efs/fs-writeback.c !Efs/block_dev.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1164>1164</a></td>\n' +
            '<td>The proc filesystem</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1165>1165</a></td>\n' +
            '<td>sysctl interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1166>1166</a></td>\n' +
            '<td>!Ekernel/sysctl.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1167>1167</a></td>\n' +
            '<td>proc filesystem interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1168>1168</a></td>\n' +
            '<td>!Ifs/proc/base.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1169>1169</a></td>\n' +
            '<td>Events based on file descriptors</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1170>1170</a></td>\n' +
            '<td>!Efs/eventfd.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1171>1171</a></td>\n' +
            '<td>The Filesystem for Exporting Kernel Objects</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1172>1172</a></td>\n' +
            '<td>!Efs/sysfs/file.c !Efs/sysfs/symlink.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1173>1173</a></td>\n' +
            '<td>The debugfs filesystem</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1174>1174</a></td>\n' +
            '<td>debugfs interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1175>1175</a></td>\n' +
            '<td>!Efs/debugfs/inode.c !Efs/debugfs/file.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1176>1176</a></td>\n' +
            '<td>The Linux Journalling API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1177>1177</a></td>\n' +
            '<td>Overview</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1178>1178</a></td>\n' +
            '<td>Details</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1179>1179</a></td>\n' +
            '<td>The journalling layer is easy to use. You need to first of all create a journal_t data structure. There are two calls to do this dependent on how you decide to allocate the physical media on which the journal resides. The journal_init_inode() call is for journals stored in filesystem inodes, or the journal_init_dev() call can be use for journal stored on a raw device (in a continuous range of blocks). A journal_t is a typedef for a struct pointer, so when you are finally finished make sure you call journal_destroy() on it to free up any used kernel memory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1180>1180</a></td>\n' +
            '<td>Once you have got your journal_t object you need to ' + "'" + 'mount' + "'" + ' or load the journal file, unless of course you haven' + "'" + 't initialised it yet - in which case you need to call journal_create().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1181>1181</a></td>\n' +
            '<td>Most of the time however your journal file will already have been created, but before you load it you must call journal_wipe() to empty the journal file. Hang on, you say , what if the filesystem wasn' + "'" + 't cleanly umount()' + "'" + 'd . Well, it is the job of the client file system to detect this and skip the call to journal_wipe().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1182>1182</a></td>\n' +
            '<td>In either case the next call should be to journal_load() which prepares the journal file for use. Note that journal_wipe(..,0) calls journal_skip_recovery() for you if it detects any outstanding transactions in the journal and similarly journal_load() will call journal_recover() if necessary. I would advise reading fs/ext3/super.c for examples on this stage. [RGG: Why is the journal_wipe() call necessary - doesn' + "'" + 't this needlessly complicate the API. Or isn' + "'" + 't a good idea for the journal layer to hide dirty mounts from the client fs]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1183>1183</a></td>\n' +
            '<td>Now you can go ahead and start modifying the underlying filesystem. Almost.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1184>1184</a></td>\n' +
            '<td>You still need to actually journal your filesystem changes, this is done by wrapping them into transactions. Additionally you also need to wrap the modification of each of the buffers with calls to the journal layer, so it knows what the modifications you are actually making are. To do this use journal_start() which returns a transaction handle.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1185>1185</a></td>\n' +
            '<td>journal_start() and its counterpart journal_stop(), which indicates the end of a transaction are nestable calls, so you can reenter a transaction if necessary, but remember you must call journal_stop() the same number of times as journal_start() before the transaction is completed (or more accurately leaves the update phase). Ext3/VFS makes use of this feature to simplify quota support.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1186>1186</a></td>\n' +
            '<td>Inside each transaction you need to wrap the modifications to the individual buffers (blocks). Before you start to modify a buffer you need to call journal_get_{create,write,undo}_access() as appropriate, this allows the journalling layer to copy the unmodified data if it needs to. After all the buffer may be part of a previously uncommitted transaction. At this point you are at last ready to modify a buffer, and once you are have done so you need to call journal_dirty_{meta,}data(). Or if you' + "'" + 've asked for access to a buffer you now know is now longer required to be pushed back on the device you can call journal_forget() in much the same way as you might have used bforget() in the past.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1187>1187</a></td>\n' +
            '<td>A journal_flush() may be called at any time to commit and checkpoint all your transactions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1188>1188</a></td>\n' +
            '<td>Then at umount time , in your put_super() you can then call journal_destroy() to clean up your in-core journal object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1189>1189</a></td>\n' +
            '<td>Unfortunately there a couple of ways the journal layer can cause a deadlock. The first thing to note is that each task can only have a single outstanding transaction at any one time, remember nothing commits until the outermost journal_stop(). This means you must complete the transaction at the end of each file/inode/address etc. operation you perform, so that the journalling system isn' + "'" + 't re-entered on another journal. Since transactions can' + "'" + 't be nested/batched across differing journals, and another filesystem other than yours (say ext3) may be modified in a later syscall.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1190>1190</a></td>\n' +
            '<td>The second case to bear in mind is that journal_start() can block if there isn' + "'" + 't enough space in the journal for your transaction (based on the passed nblocks param) - when it blocks it merely(!) needs to wait for transactions to complete and be committed from other tasks, so essentially we are waiting for journal_stop(). So to avoid deadlocks you must treat journal_start/stop() as if they were semaphores and include them in your semaphore ordering rules to prevent deadlocks. Note that journal_extend() has similar blocking behaviour to journal_start() so you can deadlock here just as easily as on journal_start().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1191>1191</a></td>\n' +
            '<td>Try to reserve the right number of blocks the first time. ;-). This will be the maximum number of blocks you are going to touch in this transaction. I advise having a look at at least ext3_jbd.h to see the basis on which ext3 uses to make these decisions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1192>1192</a></td>\n' +
            '<td>Another wriggle to watch out for is your on-disk block allocation strategy. why? Because, if you undo a delete, you need to ensure you haven' + "'" + 't reused any of the freed blocks in a later transaction. One simple way of doing this is make sure any blocks you allocate only have checkpointed transactions listed against them. Ext3 does this in ext3_test_allocatable().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1193>1193</a></td>\n' +
            '<td>Lock is also providing through journal_{un,}lock_updates(), ext3 uses this when it wants a window with a clean and stable fs for a moment. eg.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1194>1194</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1195>1195</a></td>\n' +
            '<td>    journal_lock_updates() //stop new stuff happening..</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1196>1196</a></td>\n' +
            '<td>    journal_flush()        // checkpoint everything.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1197>1197</a></td>\n' +
            '<td>    ..do stuff on stable fs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1198>1198</a></td>\n' +
            '<td>    journal_unlock_updates() // carry on with filesystem use.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1199>1199</a></td>\n' +
            '<td>The opportunities for abuse and DOS attacks with this should be obvious, if you allow unprivileged userspace to trigger codepaths containing these calls.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1200>1200</a></td>\n' +
            '<td>A new feature of jbd since 2.5.25 is commit callbacks with the new journal_callback_set() function you can now ask the journalling layer to call you back when the transaction is finally committed to disk, so that you can do some of your own management. The key to this is the journal_callback struct, this maintains the internal callback information but you can extend it like this:-</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1201>1201</a></td>\n' +
            '<td>    struct  myfs_callback_s {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1202>1202</a></td>\n' +
            '<td>        //Data structure element required by jbd..</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1203>1203</a></td>\n' +
            '<td>        struct journal_callback for_jbd;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1204>1204</a></td>\n' +
            '<td>        // Stuff for myfs allocated together.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1205>1205</a></td>\n' +
            '<td>        myfs_inode*    i_commited;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1206>1206</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1207>1207</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1208>1208</a></td>\n' +
            '<td>this would be useful if you needed to know when data was committed to a particular inode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1209>1209</a></td>\n' +
            '<td>Summary</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1210>1210</a></td>\n' +
            '<td>Using the journal is a matter of wrapping the different context changes, being each mount, each modification (transaction) and each changed buffer to tell the journalling layer about them.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1211>1211</a></td>\n' +
            '<td>Here is a some pseudo code to give you an idea of how it works, as an example.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1212>1212</a></td>\n' +
            '<td>  journal_t* my_jnrl = journal_create();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1213>1213</a></td>\n' +
            '<td>  journal_init_{dev,inode}(jnrl,...)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1214>1214</a></td>\n' +
            '<td>  if (clean) journal_wipe();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1215>1215</a></td>\n' +
            '<td>  journal_load();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1216>1216</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1217>1217</a></td>\n' +
            '<td>   foreach(transaction) { /*transactions must be</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1218>1218</a></td>\n' +
            '<td>                            completed before</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1219>1219</a></td>\n' +
            '<td>                            a syscall returns to</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1220>1220</a></td>\n' +
            '<td>                            userspace*/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1221>1221</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1222>1222</a></td>\n' +
            '<td>          handle_t * xct=journal_start(my_jnrl);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1223>1223</a></td>\n' +
            '<td>          foreach(bh) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1224>1224</a></td>\n' +
            '<td>                journal_get_{create,write,undo}_access(xact,bh);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1225>1225</a></td>\n' +
            '<td>                if ( myfs_modify(bh) ) { /* returns true</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1226>1226</a></td>\n' +
            '<td>                                        if makes changes */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1227>1227</a></td>\n' +
            '<td>                           journal_dirty_{meta,}data(xact,bh);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1228>1228</a></td>\n' +
            '<td>                } else {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1229>1229</a></td>\n' +
            '<td>                           journal_forget(bh);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1230>1230</a></td>\n' +
            '<td>                }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1231>1231</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1232>1232</a></td>\n' +
            '<td>          journal_stop(xct);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1233>1233</a></td>\n' +
            '<td>   }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1234>1234</a></td>\n' +
            '<td>   journal_destroy(my_jrnl);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1235>1235</a></td>\n' +
            '<td>Data Types</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1236>1236</a></td>\n' +
            '<td>The journalling layer uses typedefs to ' + "'" + 'hide' + "'" + ' the concrete definitions of the structures used. As a client of the JBD layer you can just rely on the using the pointer as a magic cookie of some sort. Obviously the hiding is not enforced as this is ' + "'" + 'C' + "'" + '.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1237>1237</a></td>\n' +
            '<td>Structures</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1238>1238</a></td>\n' +
            '<td>!Iinclude/linux/jbd.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1239>1239</a></td>\n' +
            '<td>Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1240>1240</a></td>\n' +
            '<td>The functions here are split into two groups those that affect a journal as a whole, and those which are used to manage transactions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1241>1241</a></td>\n' +
            '<td>Journal Level</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1242>1242</a></td>\n' +
            '<td>!Efs/jbd/journal.c !Ifs/jbd/recovery.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1243>1243</a></td>\n' +
            '<td>Transasction Level</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1244>1244</a></td>\n' +
            '<td>!Efs/jbd/transaction.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1245>1245</a></td>\n' +
            '<td>See also</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1246>1246</a></td>\n' +
            '<td>Journaling the Linux ext2fs Filesystem, LinuxExpo 98, Stephen Tweedie</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1247>1247</a></td>\n' +
            '<td>Ext3 Journalling FileSystem, OLS 2000, Dr. Stephen Tweedie</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1248>1248</a></td>\n' +
            '<td>splice API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1249>1249</a></td>\n' +
            '<td>splice is a method for moving blocks of data around inside the kernel, without continually transferring them between the kernel and user space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1250>1250</a></td>\n' +
            '<td>!Ffs/splice.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1251>1251</a></td>\n' +
            '<td>pipes API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1252>1252</a></td>\n' +
            '<td>Pipe interfaces are all for in-kernel (builtin image) use. They are not exported for use by modules.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1253>1253</a></td>\n' +
            '<td>!Iinclude/linux/pipe_fs_i.h !Ffs/pipe.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1254>1254</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1255>1255</a></td>\n' +
            '<td>This document presents a Linux-USB "Gadget" kernel mode API, for use within peripherals and other USB devices that embed Linux. It provides an overview of the API structure, and shows how that fits into a system development project. This is the first such API released on Linux to address a number of important problems, including:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1256>1256</a></td>\n' +
            '<td>    Supports USB 2.0, for high speed devices which can stream data at several dozen megabytes per second.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1257>1257</a></td>\n' +
            '<td>    Handles devices with dozens of endpoints just as well as ones with just two fixed-function ones. Gadget drivers can be written so they' + "'" + 're easy to port to new hardware.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1258>1258</a></td>\n' +
            '<td>    Flexible enough to expose more complex USB device capabilities such as multiple configurations, multiple interfaces, composite devices, and alternate interface settings.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1259>1259</a></td>\n' +
            '<td>    USB "On-The-Go" (OTG) support, in conjunction with updates to the Linux-USB host side.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1260>1260</a></td>\n' +
            '<td>    Sharing data structures and API models with the Linux-USB host side API. This helps the OTG support, and looks forward to more-symmetric frameworks (where the same I/O model is used by both host and device side drivers).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1261>1261</a></td>\n' +
            '<td>    Minimalist, so it' + "'" + 's easier to support new device controller hardware. I/O processing doesn' + "'" + 't imply large demands for memory or CPU resources.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1262>1262</a></td>\n' +
            '<td>Most Linux developers will not be able to use this API, since they have USB "host" hardware in a PC, workstation, or server. Linux users with embedded systems are more likely to have USB peripheral hardware. To distinguish drivers running inside such hardware from the more familiar Linux "USB device drivers", which are host side proxies for the real USB devices, a different term is used: the drivers inside the peripherals are "USB gadget drivers". In USB protocol interactions, the device driver is the master (or "client driver") and the gadget driver is the slave (or "function driver").</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1263>1263</a></td>\n' +
            '<td>The gadget API resembles the host side Linux-USB API in that both use queues of request objects to package I/O buffers, and those requests may be submitted or canceled. They share common definitions for the standard USB Chapter 9 messages, structures, and constants. Also, both APIs bind and unbind drivers to devices. The APIs differ in detail, since the host side' + "'" + 's current URB framework exposes a number of implementation details and assumptions that are inappropriate for a gadget API. While the model for control transfers and configuration management is necessarily different (one side is a hardware-neutral master, the other is a hardware-aware slave), the endpoint I/0 API used here should also be usable for an overhead-reduced host side API.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1264>1264</a></td>\n' +
            '<td>Structure of Gadget Drivers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1265>1265</a></td>\n' +
            '<td>A system running inside a USB peripheral normally has at least three layers inside the kernel to handle USB protocol processing, and may have additional layers in user space code. The "gadget" API is used by the middle layer to interact with the lowest level (which directly handles hardware).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1266>1266</a></td>\n' +
            '<td>In Linux, from the bottom up, these layers are:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1267>1267</a></td>\n' +
            '<td>USB Controller Driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1268>1268</a></td>\n' +
            '<td>This is the lowest software level. It is the only layer that talks to hardware, through registers, fifos, dma, irqs, and the like. The &lt;linux/usb/gadget.h&gt; API abstracts the peripheral controller endpoint hardware. That hardware is exposed through endpoint objects, which accept streams of IN/OUT buffers, and through callbacks that interact with gadget drivers. Since normal USB devices only have one upstream port, they only have one of these drivers. The controller driver can support any number of different gadget drivers, but only one of them can be used at a time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1269>1269</a></td>\n' +
            '<td>Examples of such controller hardware include the PCI-based NetChip 2280 USB 2.0 high speed controller, the SA-11x0 or PXA-25x UDC (found within many PDAs), and a variety of other products.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1270>1270</a></td>\n' +
            '<td>Gadget Driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1271>1271</a></td>\n' +
            '<td>The lower boundary of this driver implements hardware-neutral USB functions, using calls to the controller driver. Because such hardware varies widely in capabilities and restrictions, and is used in embedded environments where space is at a premium, the gadget driver is often configured at compile time to work with endpoints supported by one particular controller. Gadget drivers may be portable to several different controllers, using conditional compilation. (Recent kernels substantially simplify the work involved in supporting new hardware, by autoconfiguring endpoints automatically for many bulk-oriented drivers.) Gadget driver responsibilities include:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1272>1272</a></td>\n' +
            '<td>    handling setup requests (ep0 protocol responses) possibly including class-specific functionality</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1273>1273</a></td>\n' +
            '<td>    returning configuration and string descriptors</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1274>1274</a></td>\n' +
            '<td>    (re)setting configurations and interface altsettings, including enabling and configuring endpoints</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1275>1275</a></td>\n' +
            '<td>    handling life cycle events, such as managing bindings to hardware, USB suspend/resume, remote wakeup, and disconnection from the USB host.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1276>1276</a></td>\n' +
            '<td>    managing IN and OUT transfers on all currently enabled endpoints</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1277>1277</a></td>\n' +
            '<td>Such drivers may be modules of proprietary code, although that approach is discouraged in the Linux community.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1278>1278</a></td>\n' +
            '<td>Upper Level</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1279>1279</a></td>\n' +
            '<td>Most gadget drivers have an upper boundary that connects to some Linux driver or framework in Linux. Through that boundary flows the data which the gadget driver produces and/or consumes through protocol transfers over USB. Examples include:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1280>1280</a></td>\n' +
            '<td>    user mode code, using generic (gadgetfs) or application specific files in /dev</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1281>1281</a></td>\n' +
            '<td>    networking subsystem (for network gadgets, like the CDC Ethernet Model gadget driver)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1282>1282</a></td>\n' +
            '<td>    data capture drivers, perhaps video4Linux or a scanner driver; or test and measurement hardware.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1283>1283</a></td>\n' +
            '<td>    input subsystem (for HID gadgets)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1284>1284</a></td>\n' +
            '<td>    sound subsystem (for audio gadgets)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1285>1285</a></td>\n' +
            '<td>    file system (for PTP gadgets)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1286>1286</a></td>\n' +
            '<td>    block i/o subsystem (for usb-storage gadgets)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1287>1287</a></td>\n' +
            '<td>    ... and more</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1288>1288</a></td>\n' +
            '<td>Additional Layers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1289>1289</a></td>\n' +
            '<td>Other layers may exist. These could include kernel layers, such as network protocol stacks, as well as user mode applications building on standard POSIX system call APIs such as open(), close(), read() and write(). On newer systems, POSIX Async I/O calls may be an option. Such user mode code will not necessarily be subject to the GNU General Public License (GPL).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1290>1290</a></td>\n' +
            '<td>OTG-capable systems will also need to include a standard Linux-USB host side stack, with usbcore, one or more Host Controller Drivers (HCDs), USB Device Drivers to support the OTG "Targeted Peripheral List", and so forth. There will also be an OTG Controller Driver, which is visible to gadget and device driver developers only indirectly. That helps the host and device side USB controllers implement the two new OTG protocols (HNP and SRP). Roles switch (host to peripheral, or vice versa) using HNP during USB suspend processing, and SRP can be viewed as a more battery-friendly kind of device wakeup protocol.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1291>1291</a></td>\n' +
            '<td>Over time, reusable utilities are evolving to help make some gadget driver tasks simpler. For example, building configuration descriptors from vectors of descriptors for the configurations interfaces and endpoints is now automated, and many drivers now use autoconfiguration to choose hardware endpoints and initialize their descriptors. A potential example of particular interest is code implementing standard USB-IF protocols for HID, networking, storage, or audio classes. Some developers are interested in KDB or KGDB hooks, to let target hardware be remotely debugged. Most such USB protocol code doesn' + "'" + 't need to be hardware-specific, any more than network protocols like X11, HTTP, or NFS are. Such gadget-side interface drivers should eventually be combined, to implement composite devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1292>1292</a></td>\n' +
            '<td>Kernel Mode Gadget API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1293>1293</a></td>\n' +
            '<td>Gadget drivers declare themselves through a struct usb_gadget_driver, which is responsible for most parts of enumeration for a struct usb_gadget. The response to a set_configuration usually involves enabling one or more of the struct usb_ep objects exposed by the gadget, and submitting one or more struct usb_request buffers to transfer data. Understand those four data types, and their operations, and you will understand how this API works.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1294>1294</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1295>1295</a></td>\n' +
            '<td>This documentation was prepared using the standard Linux kernel docproc tool, which turns text and in-code comments into SGML DocBook and then into usable formats such as HTML or PDF. Other than the "Chapter 9" data types, most of the significant data types and functions are described here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1296>1296</a></td>\n' +
            '<td>However, docproc does not understand all the C constructs that are used, so some relevant information is likely omitted from what you are reading. One example of such information is endpoint autoconfiguration. You' + "'" + 'll have to read the header file, and use example source code (such as that for "Gadget Zero"), to fully understand the API.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1297>1297</a></td>\n' +
            '<td>The part of the API implementing some basic driver capabilities is specific to the version of the Linux kernel that' + "'" + 's in use. The 2.6 kernel includes a driver model framework that has no analogue on earlier kernels; so those parts of the gadget API are not fully portable. (They are implemented on 2.4 kernels, but in a different way.) The driver model state is another part of this API that is ignored by the kerneldoc tools.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1298>1298</a></td>\n' +
            '<td>The core API does not expose every possible hardware feature, only the most widely available ones. There are significant hardware features, such as device-to-device DMA (without temporary storage in a memory buffer) that would be added using hardware-specific APIs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1299>1299</a></td>\n' +
            '<td>This API allows drivers to use conditional compilation to handle endpoint capabilities of different hardware, but doesn' + "'" + 't require that. Hardware tends to have arbitrary restrictions, relating to transfer types, addressing, packet sizes, buffering, and availability. As a rule, such differences only matter for "endpoint zero" logic that handles device configuration and management. The API supports limited run-time detection of capabilities, through naming conventions for endpoints. Many drivers will be able to at least partially autoconfigure themselves. In particular, driver init sections will often have endpoint autoconfiguration logic that scans the hardware' + "'" + 's list of endpoints to find ones matching the driver requirements (relying on those conventions), to eliminate some of the most common reasons for conditional compilation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1300>1300</a></td>\n' +
            '<td>Like the Linux-USB host side API, this API exposes the "chunky" nature of USB messages: I/O requests are in terms of one or more "packets", and packet boundaries are visible to drivers. Compared to RS-232 serial protocols, USB resembles synchronous protocols like HDLC (N bytes per frame, multipoint addressing, host as the primary station and devices as secondary stations) more than asynchronous ones (tty style: 8 data bits per frame, no parity, one stop bit). So for example the controller drivers won' + "'" + 't buffer two single byte writes into a single two-byte USB IN packet, although gadget drivers may do so when they implement protocols where packet boundaries (and "short packets") are not significant.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1301>1301</a></td>\n' +
            '<td>Driver Life Cycle</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1302>1302</a></td>\n' +
            '<td>Gadget drivers make endpoint I/O requests to hardware without needing to know many details of the hardware, but driver setup/configuration code needs to handle some differences. Use the API like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1303>1303</a></td>\n' +
            '<td>1.    Register a driver for the particular device side usb controller hardware, such as the net2280 on PCI (USB 2.0), sa11x0 or pxa25x as found in Linux PDAs, and so on. At this point the device is logically in the USB ch9 initial state ("attached"), drawing no power and not usable (since it does not yet support enumeration). Any host should not see the device, since it' + "'" + 's not activated the data line pullup used by the host to detect a device, even if VBUS power is available.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1304>1304</a></td>\n' +
            '<td>2.    Register a gadget driver that implements some higher level device function. That will then bind() to a usb_gadget, which activates the data line pullup sometime after detecting VBUS.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1305>1305</a></td>\n' +
            '<td>3.    The hardware driver can now start enumerating. The steps it handles are to accept USB power and set_address requests. Other steps are handled by the gadget driver. If the gadget driver module is unloaded before the host starts to enumerate, steps before step 7 are skipped.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1306>1306</a></td>\n' +
            '<td>4.    The gadget driver' + "'" + 's setup() call returns usb descriptors, based both on what the bus interface hardware provides and on the functionality being implemented. That can involve alternate settings or configurations, unless the hardware prevents such operation. For OTG devices, each configuration descriptor includes an OTG descriptor.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1307>1307</a></td>\n' +
            '<td>5.    The gadget driver handles the last step of enumeration, when the USB host issues a set_configuration call. It enables all endpoints used in that configuration, with all interfaces in their default settings. That involves using a list of the hardware' + "'" + 's endpoints, enabling each endpoint according to its descriptor. It may also involve using usb_gadget_vbus_draw to let more power be drawn from VBUS, as allowed by that configuration. For OTG devices, setting a configuration may also involve reporting HNP capabilities through a user interface.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1308>1308</a></td>\n' +
            '<td>6.    Do real work and perform data transfers, possibly involving changes to interface settings or switching to new configurations, until the device is disconnect()ed from the host. Queue any number of transfer requests to each endpoint. It may be suspended and resumed several times before being disconnected. On disconnect, the drivers go back to step 3 (above).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1309>1309</a></td>\n' +
            '<td>7.    When the gadget driver module is being unloaded, the driver unbind() callback is issued. That lets the controller driver be unloaded.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1310>1310</a></td>\n' +
            '<td>Drivers will normally be arranged so that just loading the gadget driver module (or statically linking it into a Linux kernel) allows the peripheral device to be enumerated, but some drivers will defer enumeration until some higher level component (like a user mode daemon) enables it. Note that at this lowest level there are no policies about how ep0 configuration logic is implemented, except that it should obey USB specifications. Such issues are in the domain of gadget drivers, including knowing about implementation constraints imposed by some USB controllers or understanding that composite devices might happen to be built by integrating reusable components.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1311>1311</a></td>\n' +
            '<td>Note that the lifecycle above can be slightly different for OTG devices. Other than providing an additional OTG descriptor in each configuration, only the HNP-related differences are particularly visible to driver code. They involve reporting requirements during the SET_CONFIGURATION request, and the option to invoke HNP during some suspend callbacks. Also, SRP changes the semantics of usb_gadget_wakeup slightly.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1312>1312</a></td>\n' +
            '<td>USB 2.0 Chapter 9 Types and Constants</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1313>1313</a></td>\n' +
            '<td>Gadget drivers rely on common USB structures and constants defined in the &lt;linux/usb/ch9.h&gt; header file, which is standard in Linux 2.6 kernels. These are the same types and constants used by host side drivers (and usbcore).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1314>1314</a></td>\n' +
            '<td>!Iinclude/linux/usb/ch9.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1315>1315</a></td>\n' +
            '<td>Core Objects and Methods</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1316>1316</a></td>\n' +
            '<td>These are declared in &lt;linux/usb/gadget.h&gt;, and are used by gadget drivers to interact with USB peripheral controller drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1317>1317</a></td>\n' +
            '<td>!Iinclude/linux/usb/gadget.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1318>1318</a></td>\n' +
            '<td>Optional Utilities</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1319>1319</a></td>\n' +
            '<td>The core API is sufficient for writing a USB Gadget Driver, but some optional utilities are provided to simplify common tasks. These utilities include endpoint autoconfiguration.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1320>1320</a></td>\n' +
            '<td>!Edrivers/usb/gadget/usbstring.c !Edrivers/usb/gadget/config.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1321>1321</a></td>\n' +
            '<td>Composite Device Framework</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1322>1322</a></td>\n' +
            '<td>The core API is sufficient for writing drivers for composite USB devices (with more than one function in a given configuration), and also multi-configuration devices (also more than one function, but not necessarily sharing a given configuration). There is however an optional framework which makes it easier to reuse and combine functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1323>1323</a></td>\n' +
            '<td>Devices using this framework provide a struct usb_composite_driver, which in turn provides one or more struct usb_configuration instances. Each such configuration includes at least one struct usb_function, which packages a user visible role such as "network link" or "mass storage device". Management functions may also exist, such as "Device Firmware Upgrade".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1324>1324</a></td>\n' +
            '<td>!Iinclude/linux/usb/composite.h !Edrivers/usb/gadget/composite.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1325>1325</a></td>\n' +
            '<td>Composite Device Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1326>1326</a></td>\n' +
            '<td>At this writing, a few of the current gadget drivers have been converted to this framework. Near-term plans include converting all of them, except for "gadgetfs".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1327>1327</a></td>\n' +
            '<td>!Edrivers/usb/gadget/f_acm.c !Edrivers/usb/gadget/f_ecm.c !Edrivers/usb/gadget/f_subset.c !Edrivers/usb/gadget/f_obex.c !Edrivers/usb/gadget/f_serial.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1328>1328</a></td>\n' +
            '<td>Peripheral Controller Drivers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1329>1329</a></td>\n' +
            '<td>The first hardware supporting this API was the NetChip 2280 controller, which supports USB 2.0 high speed and is based on PCI. This is the net2280 driver module. The driver supports Linux kernel versions 2.4 and 2.6; contact NetChip Technologies for development boards and product information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1330>1330</a></td>\n' +
            '<td>Other hardware working in the "gadget" framework includes: Intel' + "'" + 's PXA 25x and IXP42x series processors (pxa2xx_udc), Toshiba TC86c001 "Goku-S" (goku_udc), Renesas SH7705/7727 (sh_udc), MediaQ 11xx (mq11xx_udc), Hynix HMS30C7202 (h7202_udc), National 9303/4 (n9604_udc), Texas Instruments OMAP (omap_udc), Sharp LH7A40x (lh7a40x_udc), and more. Most of those are full speed controllers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1331>1331</a></td>\n' +
            '<td>At this writing, there are people at work on drivers in this framework for several other USB device controllers, with plans to make many of them be widely available.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1332>1332</a></td>\n' +
            '<td>A partial USB simulator, the dummy_hcd driver, is available. It can act like a net2280, a pxa25x, or an sa11x0 in terms of available endpoints and device speeds; and it simulates control, bulk, and to some extent interrupt transfers. That lets you develop some parts of a gadget driver on a normal PC, without any special hardware, and perhaps with the assistance of tools such as GDB running with User Mode Linux. At least one person has expressed interest in adapting that approach, hooking it up to a simulator for a microcontroller. Such simulators can help debug subsystems where the runtime hardware is unfriendly to software development, or is not yet available.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1333>1333</a></td>\n' +
            '<td>Support for other controllers is expected to be developed and contributed over time, as this driver framework evolves.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1334>1334</a></td>\n' +
            '<td>Gadget Drivers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1335>1335</a></td>\n' +
            '<td>In addition to Gadget Zero (used primarily for testing and development with drivers for usb controller hardware), other gadget drivers exist.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1336>1336</a></td>\n' +
            '<td>There' + "'" + 's an ethernet gadget driver, which implements one of the most useful Communications Device Class (CDC) models. One of the standards for cable modem interoperability even specifies the use of this ethernet model as one of two mandatory options. Gadgets using this code look to a USB host as if they' + "'" + 're an Ethernet adapter. It provides access to a network where the gadget' + "'" + 's CPU is one host, which could easily be bridging, routing, or firewalling access to other networks. Since some hardware can' + "'" + 't fully implement the CDC Ethernet requirements, this driver also implements a "good parts only" subset of CDC Ethernet. (That subset doesn' + "'" + 't advertise itself as CDC Ethernet, to avoid creating problems.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1337>1337</a></td>\n' +
            '<td>Support for Microsoft' + "'" + 's RNDIS protocol has been contributed by Pengutronix and Auerswald GmbH. This is like CDC Ethernet, but it runs on more slightly USB hardware (but less than the CDC subset). However, its main claim to fame is being able to connect directly to recent versions of Windows, using drivers that Microsoft bundles and supports, making it much simpler to network with Windows.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1338>1338</a></td>\n' +
            '<td>There is also support for user mode gadget drivers, using gadgetfs. This provides a User Mode API that presents each endpoint as a single file descriptor. I/O is done using normal read() and read() calls. Familiar tools like GDB and pthreads can be used to develop and debug user mode drivers, so that once a robust controller driver is available many applications for it won' + "'" + 't require new kernel mode software. Linux 2.6 Async I/O (AIO) support is available, so that user mode software can stream data with only slightly more overhead than a kernel driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1339>1339</a></td>\n' +
            '<td>There' + "'" + 's a USB Mass Storage class driver, which provides a different solution for interoperability with systems such as MS-Windows and MacOS. That Mass Storage driver uses a file or block device as backing store for a drive, like the loop driver. The USB host uses the BBB, CB, or CBI versions of the mass storage class specification, using transparent SCSI commands to access the data from the backing store.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1340>1340</a></td>\n' +
            '<td>There' + "'" + 's a "serial line" driver, useful for TTY style operation over USB. The latest version of that driver supports CDC ACM style operation, like a USB modem, and so on most hardware it can interoperate easily with MS-Windows. One interesting use of that driver is in boot firmware (like a BIOS), which can sometimes use that model with very small systems without real serial lines.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1341>1341</a></td>\n' +
            '<td>Support for other kinds of gadget is expected to be developed and contributed over time, as this driver framework evolves.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1342>1342</a></td>\n' +
            '<td>USB On-The-GO (OTG)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1343>1343</a></td>\n' +
            '<td>USB OTG support on Linux 2.6 was initially developed by Texas Instruments for OMAP 16xx and 17xx series processors. Other OTG systems should work in similar ways, but the hardware level details could be very different.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1344>1344</a></td>\n' +
            '<td>Systems need specialized hardware support to implement OTG, notably including a special Mini-AB jack and associated transciever to support Dual-Role operation: they can act either as a host, using the standard Linux-USB host side driver stack, or as a peripheral, using this "gadget" framework. To do that, the system software relies on small additions to those programming interfaces, and on a new internal component (here called an "OTG Controller") affecting which driver stack connects to the OTG port. In each role, the system can re-use the existing pool of hardware-neutral drivers, layered on top of the controller driver interfaces (usb_bus or usb_gadget). Such drivers need at most minor changes, and most of the calls added to support OTG can also benefit non-OTG products.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1345>1345</a></td>\n' +
            '<td>    Gadget drivers test the is_otg flag, and use it to determine whether or not to include an OTG descriptor in each of their configurations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1346>1346</a></td>\n' +
            '<td>    Gadget drivers may need changes to support the two new OTG protocols, exposed in new gadget attributes such as b_hnp_enable flag. HNP support should be reported through a user interface (two LEDs could suffice), and is triggered in some cases when the host suspends the peripheral. SRP support can be user-initiated just like remote wakeup, probably by pressing the same button.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1347>1347</a></td>\n' +
            '<td>    On the host side, USB device drivers need to be taught to trigger HNP at appropriate moments, using usb_suspend_device(). That also conserves battery power, which is useful even for non-OTG configurations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1348>1348</a></td>\n' +
            '<td>    Also on the host side, a driver must support the OTG "Targeted Peripheral List". That' + "'" + 's just a whitelist, used to reject peripherals not supported with a given Linux OTG host. This whitelist is product-specific; each product must modify otg_whitelist.h to match its interoperability specification.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1349>1349</a></td>\n' +
            '<td>     Non-OTG Linux hosts, like PCs and workstations, normally have some solution for adding drivers, so that peripherals that aren' + "'" + 't recognized can eventually be supported. That approach is unreasonable for consumer products that may never have their firmware upgraded, and where it' + "'" + 's usually unrealistic to expect traditional PC/workstation/server kinds of support model to work. For example, it' + "'" + 's often impractical to change device firmware once the product has been distributed, so driver bugs can' + "'" + 't normally be fixed if they' + "'" + 're found after shipment.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1350>1350</a></td>\n' +
            '<td>Additional changes are needed below those hardware-neutral usb_bus and usb_gadget driver interfaces; those aren' + "'" + 't discussed here in any detail. Those affect the hardware-specific code for each USB Host or Peripheral controller, and how the HCD initializes (since OTG can be active only on a single port). They also involve what may be called an OTG Controller Driver, managing the OTG transceiver and the OTG state machine logic as well as much of the root hub behavior for the OTG port. The OTG controller driver needs to activate and deactivate USB controllers depending on the relevant device role. Some related changes were needed inside usbcore, so that it can identify OTG-capable devices and respond appropriately to HNP or SRP protocols.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1351>1351</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1352>1352</a></td>\n' +
            '<td>The generic interrupt handling layer is designed to provide a complete abstraction of interrupt handling for device drivers. It is able to handle all the different types of interrupt controller hardware. Device drivers use generic API functions to request, enable, disable and free interrupts. The drivers do not have to know anything about interrupt hardware details, so they can be used on different platforms without code changes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1353>1353</a></td>\n' +
            '<td>This documentation is provided to developers who want to implement an interrupt subsystem based for their architecture, with the help of the generic IRQ handling layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1354>1354</a></td>\n' +
            '<td>Rationale</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1355>1355</a></td>\n' +
            '<td>The original implementation of interrupt handling in Linux uses the __do_IRQ() super-handler, which is able to deal with every type of interrupt logic.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1356>1356</a></td>\n' +
            '<td>Originally, Russell King identified different types of handlers to build a quite universal set for the ARM interrupt handler implementation in Linux 2.5/2.6. He distinguished between:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1357>1357</a></td>\n' +
            '<td>    Level type</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1358>1358</a></td>\n' +
            '<td>    Edge type</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1359>1359</a></td>\n' +
            '<td>    Simple type</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1360>1360</a></td>\n' +
            '<td>During the implementation we identified another type:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1361>1361</a></td>\n' +
            '<td>    Fast EOI type</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1362>1362</a></td>\n' +
            '<td>In the SMP world of the __do_IRQ() super-handler another type was identified:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1363>1363</a></td>\n' +
            '<td>    Per CPU type</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1364>1364</a></td>\n' +
            '<td>This split implementation of high-level IRQ handlers allows us to optimize the flow of the interrupt handling for each specific interrupt type. This reduces complexity in that particular code path and allows the optimized handling of a given type.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1365>1365</a></td>\n' +
            '<td>The original general IRQ implementation used hw_interrupt_type structures and their -&gt;ack(), -&gt;end() [etc.] callbacks to differentiate the flow control in the super-handler. This leads to a mix of flow logic and low-level hardware logic, and it also leads to unnecessary code duplication: for example in i386, there is an ioapic_level_irq and an ioapic_edge_irq IRQ-type which share many of the low-level details but have different flow handling.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1366>1366</a></td>\n' +
            '<td>A more natural abstraction is the clean separation of the ' + "'" + 'irq flow' + "'" + ' and the ' + "'" + 'chip details' + "'" + '.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1367>1367</a></td>\n' +
            '<td>Analysing a couple of architecture' + "'" + 's IRQ subsystem implementations reveals that most of them can use a generic set of ' + "'" + 'irq flow' + "'" + ' methods and only need to add the chip-level specific code. The separation is also valuable for (sub)architectures which need specific quirks in the IRQ flow itself but not in the chip details - and thus provides a more transparent IRQ subsystem design.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1368>1368</a></td>\n' +
            '<td>Each interrupt descriptor is assigned its own high-level flow handler, which is normally one of the generic implementations. (This high-level flow handler implementation also makes it simple to provide demultiplexing handlers which can be found in embedded platforms on various architectures.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1369>1369</a></td>\n' +
            '<td>The separation makes the generic interrupt handling layer more flexible and extensible. For example, an (sub)architecture can use a generic IRQ-flow implementation for ' + "'" + 'level type' + "'" + ' interrupts and add a (sub)architecture specific ' + "'" + 'edge type' + "'" + ' implementation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1370>1370</a></td>\n' +
            '<td>To make the transition to the new model easier and prevent the breakage of existing implementations, the __do_IRQ() super-handler is still available. This leads to a kind of duality for the time being. Over time the new model should be used in more and more architectures, as it enables smaller and cleaner IRQ subsystems. It' + "'" + 's deprecated for three years now and about to be removed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1371>1371</a></td>\n' +
            '<td>Known Bugs And Assumptions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1372>1372</a></td>\n' +
            '<td>None (knock on wood).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1373>1373</a></td>\n' +
            '<td>Abstraction layers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1374>1374</a></td>\n' +
            '<td>There are three main levels of abstraction in the interrupt code:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1375>1375</a></td>\n' +
            '<td>1.    High-level driver API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1376>1376</a></td>\n' +
            '<td>2.    High-level IRQ flow handlers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1377>1377</a></td>\n' +
            '<td>3.    Chip-level hardware encapsulation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1378>1378</a></td>\n' +
            '<td>Interrupt control flow</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1379>1379</a></td>\n' +
            '<td>Each interrupt is described by an interrupt descriptor structure irq_desc. The interrupt is referenced by an ' + "'" + 'unsigned int' + "'" + ' numeric value which selects the corresponding interrupt decription structure in the descriptor structures array. The descriptor structure contains status information and pointers to the interrupt flow method and the interrupt chip structure which are assigned to this interrupt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1380>1380</a></td>\n' +
            '<td>Whenever an interrupt triggers, the low-level architecture code calls into the generic interrupt code by calling desc-&gt;handle_irq(). This high-level IRQ handling function only uses desc-&gt;irq_data.chip primitives referenced by the assigned chip descriptor structure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1381>1381</a></td>\n' +
            '<td>High-level Driver API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1382>1382</a></td>\n' +
            '<td>The high-level Driver API consists of following functions:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1383>1383</a></td>\n' +
            '<td>    request_irq()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1384>1384</a></td>\n' +
            '<td>    free_irq()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1385>1385</a></td>\n' +
            '<td>    disable_irq()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1386>1386</a></td>\n' +
            '<td>    enable_irq()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1387>1387</a></td>\n' +
            '<td>    disable_irq_nosync() (SMP only)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1388>1388</a></td>\n' +
            '<td>    synchronize_irq() (SMP only)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1389>1389</a></td>\n' +
            '<td>    irq_set_irq_type()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1390>1390</a></td>\n' +
            '<td>    irq_set_irq_wake()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1391>1391</a></td>\n' +
            '<td>    irq_set_handler_data()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1392>1392</a></td>\n' +
            '<td>    irq_set_chip()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1393>1393</a></td>\n' +
            '<td>    irq_set_chip_data()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1394>1394</a></td>\n' +
            '<td>See the autogenerated function documentation for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1395>1395</a></td>\n' +
            '<td>High-level IRQ flow handlers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1396>1396</a></td>\n' +
            '<td>The generic layer provides a set of pre-defined irq-flow methods:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1397>1397</a></td>\n' +
            '<td>    handle_level_irq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1398>1398</a></td>\n' +
            '<td>    handle_edge_irq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1399>1399</a></td>\n' +
            '<td>    handle_fasteoi_irq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1400>1400</a></td>\n' +
            '<td>    handle_simple_irq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1401>1401</a></td>\n' +
            '<td>    handle_percpu_irq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1402>1402</a></td>\n' +
            '<td>    handle_edge_eoi_irq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1403>1403</a></td>\n' +
            '<td>    handle_bad_irq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1404>1404</a></td>\n' +
            '<td>The interrupt flow handlers (either pre-defined or architecture specific) are assigned to specific interrupts by the architecture either during bootup or during device initialization.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1405>1405</a></td>\n' +
            '<td>Default flow implementations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1406>1406</a></td>\n' +
            '<td>Helper functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1407>1407</a></td>\n' +
            '<td>The helper functions call the chip primitives and are used by the default flow implementations. The following helper functions are implemented (simplified excerpt):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1408>1408</a></td>\n' +
            '<td>default_enable(struct irq_data *data)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1409>1409</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1410>1410</a></td>\n' +
            '<td>    desc-&gt;irq_data.chip-&gt;irq_unmask(data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1411>1411</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1412>1412</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1413>1413</a></td>\n' +
            '<td>default_disable(struct irq_data *data)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1414>1414</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1415>1415</a></td>\n' +
            '<td>    if (!delay_disable(data))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1416>1416</a></td>\n' +
            '<td>        desc-&gt;irq_data.chip-&gt;irq_mask(data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1417>1417</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1418>1418</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1419>1419</a></td>\n' +
            '<td>default_ack(struct irq_data *data)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1420>1420</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1421>1421</a></td>\n' +
            '<td>    chip-&gt;irq_ack(data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1422>1422</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1423>1423</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1424>1424</a></td>\n' +
            '<td>default_mask_ack(struct irq_data *data)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1425>1425</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1426>1426</a></td>\n' +
            '<td>    if (chip-&gt;irq_mask_ack) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1427>1427</a></td>\n' +
            '<td>        chip-&gt;irq_mask_ack(data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1428>1428</a></td>\n' +
            '<td>    } else {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1429>1429</a></td>\n' +
            '<td>        chip-&gt;irq_mask(data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1430>1430</a></td>\n' +
            '<td>        chip-&gt;irq_ack(data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1431>1431</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1432>1432</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1433>1433</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1434>1434</a></td>\n' +
            '<td>noop(struct irq_data *data))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1435>1435</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1436>1436</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1437>1437</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1438>1438</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1439>1439</a></td>\n' +
            '<td>Default flow handler implementations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1440>1440</a></td>\n' +
            '<td>Default Level IRQ flow handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1441>1441</a></td>\n' +
            '<td>handle_level_irq provides a generic implementation for level-triggered interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1442>1442</a></td>\n' +
            '<td>The following control flow is implemented (simplified excerpt):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1443>1443</a></td>\n' +
            '<td>desc-&gt;irq_data.chip-&gt;irq_mask_ack();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1444>1444</a></td>\n' +
            '<td>handle_irq_event(desc-&gt;action);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1445>1445</a></td>\n' +
            '<td>desc-&gt;irq_data.chip-&gt;irq_unmask();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1446>1446</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1447>1447</a></td>\n' +
            '<td>Default Fast EOI IRQ flow handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1448>1448</a></td>\n' +
            '<td>handle_fasteoi_irq provides a generic implementation for interrupts, which only need an EOI at the end of the handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1449>1449</a></td>\n' +
            '<td>The following control flow is implemented (simplified excerpt):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1450>1450</a></td>\n' +
            '<td>handle_irq_event(desc-&gt;action);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1451>1451</a></td>\n' +
            '<td>desc-&gt;irq_data.chip-&gt;irq_eoi();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1452>1452</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1453>1453</a></td>\n' +
            '<td>Default Edge IRQ flow handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1454>1454</a></td>\n' +
            '<td>handle_edge_irq provides a generic implementation for edge-triggered interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1455>1455</a></td>\n' +
            '<td>The following control flow is implemented (simplified excerpt):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1456>1456</a></td>\n' +
            '<td>if (desc-&gt;status &amp; running) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1457>1457</a></td>\n' +
            '<td>    desc-&gt;irq_data.chip-&gt;irq_mask_ack();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1458>1458</a></td>\n' +
            '<td>    desc-&gt;status |= pending | masked;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1459>1459</a></td>\n' +
            '<td>    return;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1460>1460</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1461>1461</a></td>\n' +
            '<td>desc-&gt;irq_data.chip-&gt;irq_ack();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1462>1462</a></td>\n' +
            '<td>desc-&gt;status |= running;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1463>1463</a></td>\n' +
            '<td>do {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1464>1464</a></td>\n' +
            '<td>    if (desc-&gt;status &amp; masked)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1465>1465</a></td>\n' +
            '<td>        desc-&gt;irq_data.chip-&gt;irq_unmask();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1466>1466</a></td>\n' +
            '<td>    desc-&gt;status &amp;= ~pending;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1467>1467</a></td>\n' +
            '<td>    handle_irq_event(desc-&gt;action);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1468>1468</a></td>\n' +
            '<td>} while (status &amp; pending);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1469>1469</a></td>\n' +
            '<td>desc-&gt;status &amp;= ~running;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1470>1470</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1471>1471</a></td>\n' +
            '<td>Default simple IRQ flow handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1472>1472</a></td>\n' +
            '<td>handle_simple_irq provides a generic implementation for simple interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1473>1473</a></td>\n' +
            '<td>Note: The simple flow handler does not call any handler/chip primitives.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1474>1474</a></td>\n' +
            '<td>The following control flow is implemented (simplified excerpt):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1475>1475</a></td>\n' +
            '<td>handle_irq_event(desc-&gt;action);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1476>1476</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1477>1477</a></td>\n' +
            '<td>Default per CPU flow handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1478>1478</a></td>\n' +
            '<td>handle_percpu_irq provides a generic implementation for per CPU interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1479>1479</a></td>\n' +
            '<td>Per CPU interrupts are only available on SMP and the handler provides a simplified version without locking.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1480>1480</a></td>\n' +
            '<td>The following control flow is implemented (simplified excerpt):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1481>1481</a></td>\n' +
            '<td>if (desc-&gt;irq_data.chip-&gt;irq_ack)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1482>1482</a></td>\n' +
            '<td>    desc-&gt;irq_data.chip-&gt;irq_ack();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1483>1483</a></td>\n' +
            '<td>handle_irq_event(desc-&gt;action);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1484>1484</a></td>\n' +
            '<td>if (desc-&gt;irq_data.chip-&gt;irq_eoi)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1485>1485</a></td>\n' +
            '<td>        desc-&gt;irq_data.chip-&gt;irq_eoi();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1486>1486</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1487>1487</a></td>\n' +
            '<td>EOI Edge IRQ flow handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1488>1488</a></td>\n' +
            '<td>handle_edge_eoi_irq provides an abnomination of the edge handler which is solely used to tame a badly wreckaged irq controller on powerpc/cell.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1489>1489</a></td>\n' +
            '<td>Bad IRQ flow handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1490>1490</a></td>\n' +
            '<td>handle_bad_irq is used for spurious interrupts which have no real handler assigned..</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1491>1491</a></td>\n' +
            '<td>Quirks and optimizations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1492>1492</a></td>\n' +
            '<td>The generic functions are intended for ' + "'" + 'clean' + "'" + ' architectures and chips, which have no platform-specific IRQ handling quirks. If an architecture needs to implement quirks on the ' + "'" + 'flow' + "'" + ' level then it can do so by overriding the high-level irq-flow handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1493>1493</a></td>\n' +
            '<td>Delayed interrupt disable</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1494>1494</a></td>\n' +
            '<td>This per interrupt selectable feature, which was introduced by Russell King in the ARM interrupt implementation, does not mask an interrupt at the hardware level when disable_irq() is called. The interrupt is kept enabled and is masked in the flow handler when an interrupt event happens. This prevents losing edge interrupts on hardware which does not store an edge interrupt event while the interrupt is disabled at the hardware level. When an interrupt arrives while the IRQ_DISABLED flag is set, then the interrupt is masked at the hardware level and the IRQ_PENDING bit is set. When the interrupt is re-enabled by enable_irq() the pending bit is checked and if it is set, the interrupt is resent either via hardware or by a software resend mechanism. (It' + "'" + 's necessary to enable CONFIG_HARDIRQS_SW_RESEND when you want to use the delayed interrupt disable feature and your hardware is not capable of retriggering an interrupt.) The delayed interrupt disable is not configurable.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1495>1495</a></td>\n' +
            '<td>Chip-level hardware encapsulation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1496>1496</a></td>\n' +
            '<td>The chip-level hardware descriptor structure irq_chip contains all the direct chip relevant functions, which can be utilized by the irq flow implementations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1497>1497</a></td>\n' +
            '<td>    irq_ack()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1498>1498</a></td>\n' +
            '<td>    irq_mask_ack() - Optional, recommended for performance</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1499>1499</a></td>\n' +
            '<td>    irq_mask()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1500>1500</a></td>\n' +
            '<td>    irq_unmask()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1501>1501</a></td>\n' +
            '<td>    irq_eoi() - Optional, required for EOI flow handlers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1502>1502</a></td>\n' +
            '<td>    irq_retrigger() - Optional</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1503>1503</a></td>\n' +
            '<td>    irq_set_type() - Optional</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1504>1504</a></td>\n' +
            '<td>    irq_set_wake() - Optional</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1505>1505</a></td>\n' +
            '<td>These primitives are strictly intended to mean what they say: ack means ACK, masking means masking of an IRQ line, etc. It is up to the flow handler(s) to use these basic units of low-level functionality.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1506>1506</a></td>\n' +
            '<td>__do_IRQ entry point</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1507>1507</a></td>\n' +
            '<td>The original implementation __do_IRQ() was an alternative entry point for all types of interrupts. It no longer exists.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1508>1508</a></td>\n' +
            '<td>This handler turned out to be not suitable for all interrupt hardware and was therefore reimplemented with split functionality for edge/level/simple/percpu interrupts. This is not only a functional optimization. It also shortens code paths for interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1509>1509</a></td>\n' +
            '<td>Locking on SMP</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1510>1510</a></td>\n' +
            '<td>The locking of chip registers is up to the architecture that defines the chip primitives. The per-irq structure is protected via desc-&gt;lock, by the generic layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1511>1511</a></td>\n' +
            '<td>Generic interrupt chip</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1512>1512</a></td>\n' +
            '<td>To avoid copies of identical implementations of IRQ chips the core provides a configurable generic interrupt chip implementation. Developers should check carefuly whether the generic chip fits their needs before implementing the same functionality slightly differently themselves.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1513>1513</a></td>\n' +
            '<td>!Ekernel/irq/generic-chip.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1514>1514</a></td>\n' +
            '<td>Structures</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1515>1515</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the structures which are used in the generic IRQ layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1516>1516</a></td>\n' +
            '<td>!Iinclude/linux/irq.h !Iinclude/linux/interrupt.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1517>1517</a></td>\n' +
            '<td>Public Functions Provided</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1518>1518</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the kernel API functions which are exported.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1519>1519</a></td>\n' +
            '<td>!Ekernel/irq/manage.c !Ekernel/irq/chip.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1520>1520</a></td>\n' +
            '<td>Internal Functions Provided</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1521>1521</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the internal functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1522>1522</a></td>\n' +
            '<td>!Ikernel/irq/irqdesc.c !Ikernel/irq/handle.c !Ikernel/irq/chip.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1523>1523</a></td>\n' +
            '<td>Credits</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1524>1524</a></td>\n' +
            '<td>The following people have contributed to this document:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1525>1525</a></td>\n' +
            '<td>1.    Thomas Gleixnertglx@linutronix.de</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1526>1526</a></td>\n' +
            '<td>2.    Ingo Molnarmingo@elte.hu</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1527>1527</a></td>\n' +
            '<td>Data Types</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1528>1528</a></td>\n' +
            '<td>Doubly Linked Lists</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1529>1529</a></td>\n' +
            '<td>!Iinclude/linux/list.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1530>1530</a></td>\n' +
            '<td>Basic C Library Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1531>1531</a></td>\n' +
            '<td>When writing drivers, you cannot in general use routines which are from the C Library. Some of the functions have been found generally useful and they are listed below. The behaviour of these functions may vary slightly from those defined by ANSI, and these deviations are noted in the text.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1532>1532</a></td>\n' +
            '<td>String Conversions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1533>1533</a></td>\n' +
            '<td>!Elib/vsprintf.c !Finclude/linux/kernel.h kstrtol !Finclude/linux/kernel.h kstrtoul !Elib/kstrtox.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1534>1534</a></td>\n' +
            '<td>String Manipulation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1535>1535</a></td>\n' +
            '<td>!Elib/string.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1536>1536</a></td>\n' +
            '<td>Bit Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1537>1537</a></td>\n' +
            '<td>!Iarch/x86/include/asm/bitops.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1538>1538</a></td>\n' +
            '<td>Basic Kernel Library Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1539>1539</a></td>\n' +
            '<td>The Linux kernel provides more basic utility functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1540>1540</a></td>\n' +
            '<td>Bitmap Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1541>1541</a></td>\n' +
            '<td>!Elib/bitmap.c !Ilib/bitmap.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1542>1542</a></td>\n' +
            '<td>Command-line Parsing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1543>1543</a></td>\n' +
            '<td>!Elib/cmdline.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1544>1544</a></td>\n' +
            '<td>CRC Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1545>1545</a></td>\n' +
            '<td>!Elib/crc7.c !Elib/crc16.c !Elib/crc-itu-t.c !Elib/crc32.c !Elib/crc-ccitt.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1546>1546</a></td>\n' +
            '<td>idr/ida Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1547>1547</a></td>\n' +
            '<td>!Pinclude/linux/idr.h idr sync !Plib/idr.c IDA description !Elib/idr.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1548>1548</a></td>\n' +
            '<td>Memory Management in Linux</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1549>1549</a></td>\n' +
            '<td>The Slab Cache</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1550>1550</a></td>\n' +
            '<td>!Iinclude/linux/slab.h !Emm/slab.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1551>1551</a></td>\n' +
            '<td>User Space Memory Access</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1552>1552</a></td>\n' +
            '<td>!Iarch/x86/include/asm/uaccess_32.h !Earch/x86/lib/usercopy_32.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1553>1553</a></td>\n' +
            '<td>More Memory Management Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1554>1554</a></td>\n' +
            '<td>!Emm/readahead.c !Emm/filemap.c !Emm/memory.c !Emm/vmalloc.c !Imm/page_alloc.c !Emm/mempool.c !Emm/dmapool.c !Emm/page-writeback.c !Emm/truncate.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1555>1555</a></td>\n' +
            '<td>Kernel IPC facilities</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1556>1556</a></td>\n' +
            '<td>IPC utilities</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1557>1557</a></td>\n' +
            '<td>!Iipc/util.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1558>1558</a></td>\n' +
            '<td>FIFO Buffer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1559>1559</a></td>\n' +
            '<td>kfifo interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1560>1560</a></td>\n' +
            '<td>!Iinclude/linux/kfifo.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1561>1561</a></td>\n' +
            '<td>relay interface support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1562>1562</a></td>\n' +
            '<td>Relay interface support is designed to provide an efficient mechanism for tools and facilities to relay large amounts of data from kernel space to user space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1563>1563</a></td>\n' +
            '<td>relay interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1564>1564</a></td>\n' +
            '<td>!Ekernel/relay.c !Ikernel/relay.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1565>1565</a></td>\n' +
            '<td>Module Support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1566>1566</a></td>\n' +
            '<td>Module Loading</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1567>1567</a></td>\n' +
            '<td>!Ekernel/kmod.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1568>1568</a></td>\n' +
            '<td>Inter Module support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1569>1569</a></td>\n' +
            '<td>Refer to the file kernel/module.c for more information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1570>1570</a></td>\n' +
            '<td>Hardware Interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1571>1571</a></td>\n' +
            '<td>Interrupt Handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1572>1572</a></td>\n' +
            '<td>!Ekernel/irq/manage.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1573>1573</a></td>\n' +
            '<td>DMA Channels</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1574>1574</a></td>\n' +
            '<td>!Ekernel/dma.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1575>1575</a></td>\n' +
            '<td>Resources Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1576>1576</a></td>\n' +
            '<td>!Ikernel/resource.c !Ekernel/resource.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1577>1577</a></td>\n' +
            '<td>MTRR Handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1578>1578</a></td>\n' +
            '<td>!Earch/x86/kernel/cpu/mtrr/main.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1579>1579</a></td>\n' +
            '<td>PCI Support Library</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1580>1580</a></td>\n' +
            '<td>!Edrivers/pci/pci.c !Edrivers/pci/pci-driver.c !Edrivers/pci/remove.c !Edrivers/pci/search.c !Edrivers/pci/msi.c !Edrivers/pci/bus.c !Edrivers/pci/access.c !Edrivers/pci/irq.c !Edrivers/pci/htirq.c !Edrivers/pci/probe.c !Edrivers/pci/slot.c !Edrivers/pci/rom.c !Edrivers/pci/iov.c !Idrivers/pci/pci-sysfs.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1581>1581</a></td>\n' +
            '<td>PCI Hotplug Support Library</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1582>1582</a></td>\n' +
            '<td>!Edrivers/pci/hotplug/pci_hotplug_core.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1583>1583</a></td>\n' +
            '<td>Firmware Interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1584>1584</a></td>\n' +
            '<td>DMI Interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1585>1585</a></td>\n' +
            '<td>!Edrivers/firmware/dmi_scan.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1586>1586</a></td>\n' +
            '<td>EDD Interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1587>1587</a></td>\n' +
            '<td>!Idrivers/firmware/edd.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1588>1588</a></td>\n' +
            '<td>Security Framework</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1589>1589</a></td>\n' +
            '<td>!Isecurity/security.c !Esecurity/inode.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1590>1590</a></td>\n' +
            '<td>Audit Interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1591>1591</a></td>\n' +
            '<td>!Ekernel/audit.c !Ikernel/auditsc.c !Ikernel/auditfilter.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1592>1592</a></td>\n' +
            '<td>Accounting Framework</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1593>1593</a></td>\n' +
            '<td>!Ikernel/acct.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1594>1594</a></td>\n' +
            '<td>Block Devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1595>1595</a></td>\n' +
            '<td>!Eblock/blk-core.c !Iblock/blk-core.c !Eblock/blk-map.c !Iblock/blk-sysfs.c !Eblock/blk-settings.c !Eblock/blk-exec.c !Eblock/blk-flush.c !Eblock/blk-lib.c !Eblock/blk-tag.c !Iblock/blk-tag.c !Eblock/blk-integrity.c !Ikernel/trace/blktrace.c !Iblock/genhd.c !Eblock/genhd.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1596>1596</a></td>\n' +
            '<td>Char devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1597>1597</a></td>\n' +
            '<td>!Efs/char_dev.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1598>1598</a></td>\n' +
            '<td>Miscellaneous Devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1599>1599</a></td>\n' +
            '<td>!Edrivers/char/misc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1600>1600</a></td>\n' +
            '<td>Clock Framework</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1601>1601</a></td>\n' +
            '<td>The clock framework defines programming interfaces to support software management of the system clock tree. This framework is widely used with System-On-Chip (SOC) platforms to support power management and various devices which may need custom clock rates. Note that these "clocks" don' + "'" + 't relate to timekeeping or real time clocks (RTCs), each of which have separate frameworks. These struct clk instances may be used to manage for example a 96 MHz signal that is used to shift bits into and out of peripherals or busses, or otherwise trigger synchronous state machine transitions in system hardware.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1602>1602</a></td>\n' +
            '<td>Power management is supported by explicit software clock gating: unused clocks are disabled, so the system doesn' + "'" + 't waste power changing the state of transistors that aren' + "'" + 't in active use. On some systems this may be backed by hardware clock gating, where clocks are gated without being disabled in software. Sections of chips that are powered but not clocked may be able to retain their last state. This low power state is often called a retention mode. This mode still incurs leakage currents, especially with finer circuit geometries, but for CMOS circuits power is mostly used by clocked state changes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1603>1603</a></td>\n' +
            '<td>Power-aware drivers only enable their clocks when the device they manage is in active use. Also, system sleep states often differ according to which clock domains are active: while a "standby" state may allow wakeup from several active domains, a "mem" (suspend-to-RAM) state may require a more wholesale shutdown of clocks derived from higher speed PLLs and oscillators, limiting the number of possible wakeup event sources. A driver' + "'" + 's suspend method may need to be aware of system-specific clock constraints on the target sleep state.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1604>1604</a></td>\n' +
            '<td>Some platforms support programmable clock generators. These can be used by external chips of various kinds, such as other CPUs, multimedia codecs, and devices with strict requirements for interface clocking.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1605>1605</a></td>\n' +
            '<td>!Iinclude/linux/clk.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1606>1606</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1607>1607</a></td>\n' +
            '<td>Welcome, gentle reader, to Rusty' + "'" + 's Remarkably Unreliable Guide to Linux Kernel Hacking. This document describes the common routines and general requirements for kernel code: its goal is to serve as a primer for Linux kernel development for experienced C programmers. I avoid implementation details: that' + "'" + 's what the code is for, and I ignore whole tracts of useful routines.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1608>1608</a></td>\n' +
            '<td>Before you read this, please understand that I never wanted to write this document, being grossly under-qualified, but I always wanted to read it, and this was the only way. I hope it will grow into a compendium of best practice, common starting points and random information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1609>1609</a></td>\n' +
            '<td>The Players</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1610>1610</a></td>\n' +
            '<td>At any time each of the CPUs in a system can be:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1611>1611</a></td>\n' +
            '<td>    not associated with any process, serving a hardware interrupt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1612>1612</a></td>\n' +
            '<td>    not associated with any process, serving a softirq or tasklet;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1613>1613</a></td>\n' +
            '<td>    running in kernel space, associated with a process (user context);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1614>1614</a></td>\n' +
            '<td>    running a process in user space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1615>1615</a></td>\n' +
            '<td>There is an ordering between these. The bottom two can preempt each other, but above that is a strict hierarchy: each can only be preempted by the ones above it. For example, while a softirq is running on a CPU, no other softirq will preempt it, but a hardware interrupt can. However, any other CPUs in the system execute independently.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1616>1616</a></td>\n' +
            '<td>We' + "'" + 'll see a number of ways that the user context can block interrupts, to become truly non-preemptable.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1617>1617</a></td>\n' +
            '<td>User Context</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1618>1618</a></td>\n' +
            '<td>User context is when you are coming in from a system call or other trap: like userspace, you can be preempted by more important tasks and by interrupts. You can sleep, by calling schedule().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1619>1619</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1620>1620</a></td>\n' +
            '<td>You are always in user context on module load and unload, and on operations on the block device layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1621>1621</a></td>\n' +
            '<td>In user context, the current pointer (indicating the task we are currently executing) is valid, and in_interrupt() (include/linux/interrupt.h) is false.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1622>1622</a></td>\n' +
            '<td>Caution</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1623>1623</a></td>\n' +
            '<td>Beware that if you have preemption or softirqs disabled (see below), in_interrupt() will return a false positive.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1624>1624</a></td>\n' +
            '<td>Hardware Interrupts (Hard IRQs)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1625>1625</a></td>\n' +
            '<td>Timer ticks, network cards and keyboard are examples of real hardware which produce interrupts at any time. The kernel runs interrupt handlers, which services the hardware. The kernel guarantees that this handler is never re-entered: if the same interrupt arrives, it is queued (or dropped). Because it disables interrupts, this handler has to be fast: frequently it simply acknowledges the interrupt, marks a ' + "'" + 'software interrupt' + "'" + ' for execution and exits.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1626>1626</a></td>\n' +
            '<td>You can tell you are in a hardware interrupt, because in_irq() returns true.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1627>1627</a></td>\n' +
            '<td>Caution</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1628>1628</a></td>\n' +
            '<td>Beware that this will return a false positive if interrupts are disabled (see below).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1629>1629</a></td>\n' +
            '<td>Software Interrupt Context: Softirqs and Tasklets</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1630>1630</a></td>\n' +
            '<td>Whenever a system call is about to return to userspace, or a hardware interrupt handler exits, any ' + "'" + 'software interrupts' + "'" + ' which are marked pending (usually by hardware interrupts) are run (kernel/softirq.c).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1631>1631</a></td>\n' +
            '<td>Much of the real interrupt handling work is done here. Early in the transition to SMP, there were only ' + "'" + 'bottom halves' + "'" + ' (BHs), which didn' + "'" + 't take advantage of multiple CPUs. Shortly after we switched from wind-up computers made of match-sticks and snot, we abandoned this limitation and switched to ' + "'" + 'softirqs' + "'" + '.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1632>1632</a></td>\n' +
            '<td>include/linux/interrupt.h lists the different softirqs. A very important softirq is the timer softirq (include/linux/timer.h): you can register to have it call functions for you in a given length of time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1633>1633</a></td>\n' +
            '<td>Softirqs are often a pain to deal with, since the same softirq will run simultaneously on more than one CPU. For this reason, tasklets (include/linux/interrupt.h) are more often used: they are dynamically-registrable (meaning you can have as many as you want), and they also guarantee that any tasklet will only run on one CPU at any time, although different tasklets can run simultaneously.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1634>1634</a></td>\n' +
            '<td>Caution</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1635>1635</a></td>\n' +
            '<td>The name ' + "'" + 'tasklet' + "'" + ' is misleading: they have nothing to do with ' + "'" + 'tasks' + "'" + ', and probably more to do with some bad vodka Alexey Kuznetsov had at the time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1636>1636</a></td>\n' +
            '<td>You can tell you are in a softirq (or tasklet) using the in_softirq() macro (include/linux/interrupt.h).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1637>1637</a></td>\n' +
            '<td>Caution</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1638>1638</a></td>\n' +
            '<td>Beware that this will return a false positive if a bh lock (see below) is held.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1639>1639</a></td>\n' +
            '<td>Some Basic Rules</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1640>1640</a></td>\n' +
            '<td>No memory protection</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1641>1641</a></td>\n' +
            '<td>If you corrupt memory, whether in user context or interrupt context, the whole machine will crash. Are you sure you can' + "'" + 't do what you want in userspace?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1642>1642</a></td>\n' +
            '<td>No floating point or MMX</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1643>1643</a></td>\n' +
            '<td>The FPU context is not saved; even in user context the FPU state probably won' + "'" + 't correspond with the current process: you would mess with some user process' + "'" + ' FPU state. If you really want to do this, you would have to explicitly save/restore the full FPU state (and avoid context switches). It is generally a bad idea; use fixed point arithmetic first.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1644>1644</a></td>\n' +
            '<td>A rigid stack limit</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1645>1645</a></td>\n' +
            '<td>Depending on configuration options the kernel stack is about 3K to 6K for most 32-bit architectures: it' + "'" + 's about 14K on most 64-bit archs, and often shared with interrupts so you can' + "'" + 't use it all. Avoid deep recursion and huge local arrays on the stack (allocate them dynamically instead).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1646>1646</a></td>\n' +
            '<td>The Linux kernel is portable</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1647>1647</a></td>\n' +
            '<td>Let' + "'" + 's keep it that way. Your code should be 64-bit clean, and endian-independent. You should also minimize CPU specific stuff, e.g. inline assembly should be cleanly encapsulated and minimized to ease porting. Generally it should be restricted to the architecture-dependent part of the kernel tree.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1648>1648</a></td>\n' +
            '<td>ioctls: Not writing a new system call</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1649>1649</a></td>\n' +
            '<td>A system call generally looks like this</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1650>1650</a></td>\n' +
            '<td>asmlinkage long sys_mycall(int arg)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1651>1651</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1652>1652</a></td>\n' +
            '<td>        return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1653>1653</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1654>1654</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1655>1655</a></td>\n' +
            '<td>First, in most cases you don' + "'" + 't want to create a new system call. You create a character device and implement an appropriate ioctl for it. This is much more flexible than system calls, doesn' + "'" + 't have to be entered in every architecture' + "'" + 's include/asm/unistd.h and arch/kernel/entry.S file, and is much more likely to be accepted by Linus.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1656>1656</a></td>\n' +
            '<td>If all your routine does is read or write some parameter, consider implementing a sysfs interface instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1657>1657</a></td>\n' +
            '<td>Inside the ioctl you' + "'" + 're in user context to a process. When a error occurs you return a negated errno (see include/linux/errno.h), otherwise you return 0.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1658>1658</a></td>\n' +
            '<td>After you slept you should check if a signal occurred: the Unix/Linux way of handling signals is to temporarily exit the system call with the -ERESTARTSYS error. The system call entry code will switch back to user context, process the signal handler and then your system call will be restarted (unless the user disabled that). So you should be prepared to process the restart, e.g. if you' + "'" + 're in the middle of manipulating some data structure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1659>1659</a></td>\n' +
            '<td>if (signal_pending(current))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1660>1660</a></td>\n' +
            '<td>        return -ERESTARTSYS;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1661>1661</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1662>1662</a></td>\n' +
            '<td>If you' + "'" + 're doing longer computations: first think userspace. If you really want to do it in kernel you should regularly check if you need to give up the CPU (remember there is cooperative multitasking per CPU). Idiom:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1663>1663</a></td>\n' +
            '<td>cond_resched(); /* Will sleep */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1664>1664</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1665>1665</a></td>\n' +
            '<td>A short note on interface design: the UNIX system call motto is "Provide mechanism not policy".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1666>1666</a></td>\n' +
            '<td>Recipes for Deadlock</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1667>1667</a></td>\n' +
            '<td>You cannot call any routines which may sleep, unless:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1668>1668</a></td>\n' +
            '<td>    You are in user context.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1669>1669</a></td>\n' +
            '<td>    You do not own any spinlocks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1670>1670</a></td>\n' +
            '<td>    You have interrupts enabled (actually, Andi Kleen says that the scheduling code will enable them for you, but that' + "'" + 's probably not what you wanted).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1671>1671</a></td>\n' +
            '<td>Note that some functions may sleep implicitly: common ones are the user space access functions (*_user) and memory allocation functions without GFP_ATOMIC.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1672>1672</a></td>\n' +
            '<td>You should always compile your kernel CONFIG_DEBUG_ATOMIC_SLEEP on, and it will warn you if you break these rules. If you do break the rules, you will eventually lock up your box.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1673>1673</a></td>\n' +
            '<td>Really.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1674>1674</a></td>\n' +
            '<td>Common Routines</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1675>1675</a></td>\n' +
            '<td>printk() include/linux/kernel.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1676>1676</a></td>\n' +
            '<td>printk() feeds kernel messages to the console, dmesg, and the syslog daemon. It is useful for debugging and reporting errors, and can be used inside interrupt context, but use with caution: a machine which has its console flooded with printk messages is unusable. It uses a format string mostly compatible with ANSI C printf, and C string concatenation to give it a first "priority" argument:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1677>1677</a></td>\n' +
            '<td>printk(KERN_INFO "i = %u\\n", i);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1678>1678</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1679>1679</a></td>\n' +
            '<td>See include/linux/kernel.h; for other KERN_ values; these are interpreted by syslog as the level. Special case: for printing an IP address use</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1680>1680</a></td>\n' +
            '<td>__be32 ipaddress;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1681>1681</a></td>\n' +
            '<td>printk(KERN_INFO "my ip: %pI4\\n", &amp;ipaddress);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1682>1682</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1683>1683</a></td>\n' +
            '<td>printk() internally uses a 1K buffer and does not catch overruns. Make sure that will be enough.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1684>1684</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1685>1685</a></td>\n' +
            '<td>You will know when you are a real kernel hacker when you start typoing printf as printk in your user programs :)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1686>1686</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1687>1687</a></td>\n' +
            '<td>Another sidenote: the original Unix Version 6 sources had a comment on top of its printf function: "Printf should not be used for chit-chat". You should follow that advice.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1688>1688</a></td>\n' +
            '<td>copy_[to/from]_user() / get_user() / put_user() include/asm/uaccess.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1689>1689</a></td>\n' +
            '<td>[SLEEPS]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1690>1690</a></td>\n' +
            '<td>put_user() and get_user() are used to get and put single values (such as an int, char, or long) from and to userspace. A pointer into userspace should never be simply dereferenced: data should be copied using these routines. Both return -EFAULT or 0.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1691>1691</a></td>\n' +
            '<td>copy_to_user() and copy_from_user() are more general: they copy an arbitrary amount of data to and from userspace.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1692>1692</a></td>\n' +
            '<td>Caution</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1693>1693</a></td>\n' +
            '<td>Unlike put_user() and get_user(), they return the amount of uncopied data (ie. 0 still means success).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1694>1694</a></td>\n' +
            '<td>[Yes, this moronic interface makes me cringe. The flamewar comes up every year or so. --RR.]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1695>1695</a></td>\n' +
            '<td>The functions may sleep implicitly. This should never be called outside user context (it makes no sense), with interrupts disabled, or a spinlock held.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1696>1696</a></td>\n' +
            '<td>kmalloc()/kfree() include/linux/slab.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1697>1697</a></td>\n' +
            '<td>[MAY SLEEP: SEE BELOW]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1698>1698</a></td>\n' +
            '<td>These routines are used to dynamically request pointer-aligned chunks of memory, like malloc and free do in userspace, but kmalloc() takes an extra flag word. Important values:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1699>1699</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1700>1700</a></td>\n' +
            '<td>       GFP_KERNEL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1701>1701</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1702>1702</a></td>\n' +
            '<td>May sleep and swap to free memory. Only allowed in user context, but is the most reliable way to allocate memory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1703>1703</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1704>1704</a></td>\n' +
            '<td>       GFP_ATOMIC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1705>1705</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1706>1706</a></td>\n' +
            '<td>Don' + "'" + 't sleep. Less reliable than GFP_KERNEL, but may be called from interrupt context. You should really have a good out-of-memory error-handling strategy.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1707>1707</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1708>1708</a></td>\n' +
            '<td>       GFP_DMA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1709>1709</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1710>1710</a></td>\n' +
            '<td>Allocate ISA DMA lower than 16MB. If you don' + "'" + 't know what that is you don' + "'" + 't need it. Very unreliable.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1711>1711</a></td>\n' +
            '<td>If you see a sleeping function called from invalid context warning message, then maybe you called a sleeping allocation function from interrupt context without GFP_ATOMIC. You should really fix that. Run, don' + "'" + 't walk.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1712>1712</a></td>\n' +
            '<td>If you are allocating at least PAGE_SIZE (include/asm/page.h) bytes, consider using __get_free_pages() (include/linux/mm.h). It takes an order argument (0 for page sized, 1 for double page, 2 for four pages etc.) and the same memory priority flag word as above.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1713>1713</a></td>\n' +
            '<td>If you are allocating more than a page worth of bytes you can use vmalloc(). It' + "'" + 'll allocate virtual memory in the kernel map. This block is not contiguous in physical memory, but the MMU makes it look like it is for you (so it' + "'" + 'll only look contiguous to the CPUs, not to external device drivers). If you really need large physically contiguous memory for some weird device, you have a problem: it is poorly supported in Linux because after some time memory fragmentation in a running kernel makes it hard. The best way is to allocate the block early in the boot process via the alloc_bootmem() routine.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1714>1714</a></td>\n' +
            '<td>Before inventing your own cache of often-used objects consider using a slab cache in include/linux/slab.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1715>1715</a></td>\n' +
            '<td>current include/asm/current.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1716>1716</a></td>\n' +
            '<td>This global variable (really a macro) contains a pointer to the current task structure, so is only valid in user context. For example, when a process makes a system call, this will point to the task structure of the calling process. It is not NULL in interrupt context.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1717>1717</a></td>\n' +
            '<td>mdelay()/udelay() include/asm/delay.h include/linux/delay.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1718>1718</a></td>\n' +
            '<td>The udelay() and ndelay() functions can be used for small pauses. Do not use large values with them as you risk overflow - the helper function mdelay() is useful here, or consider msleep().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1719>1719</a></td>\n' +
            '<td>cpu_to_be32()/be32_to_cpu()/cpu_to_le32()/le32_to_cpu() include/asm/byteorder.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1720>1720</a></td>\n' +
            '<td>The cpu_to_be32() family (where the "32" can be replaced by 64 or 16, and the "be" can be replaced by "le") are the general way to do endian conversions in the kernel: they return the converted value. All variations supply the reverse as well: be32_to_cpu(), etc.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1721>1721</a></td>\n' +
            '<td>There are two major variations of these functions: the pointer variation, such as cpu_to_be32p(), which take a pointer to the given type, and return the converted value. The other variation is the "in-situ" family, such as cpu_to_be32s(), which convert value referred to by the pointer, and return void.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1722>1722</a></td>\n' +
            '<td>local_irq_save()/local_irq_restore() include/asm/system.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1723>1723</a></td>\n' +
            '<td>These routines disable hard interrupts on the local CPU, and restore them. They are reentrant; saving the previous state in their one unsigned long flags argument. If you know that interrupts are enabled, you can simply use local_irq_disable() and local_irq_enable().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1724>1724</a></td>\n' +
            '<td>local_bh_disable()/local_bh_enable() include/linux/interrupt.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1725>1725</a></td>\n' +
            '<td>These routines disable soft interrupts on the local CPU, and restore them. They are reentrant; if soft interrupts were disabled before, they will still be disabled after this pair of functions has been called. They prevent softirqs and tasklets from running on the current CPU.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1726>1726</a></td>\n' +
            '<td>smp_processor_id() include/asm/smp.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1727>1727</a></td>\n' +
            '<td>get_cpu() disables preemption (so you won' + "'" + 't suddenly get moved to another CPU) and returns the current processor number, between 0 and NR_CPUS. Note that the CPU numbers are not necessarily continuous. You return it again with put_cpu() when you are done.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1728>1728</a></td>\n' +
            '<td>If you know you cannot be preempted by another task (ie. you are in interrupt context, or have preemption disabled) you can use smp_processor_id().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1729>1729</a></td>\n' +
            '<td>__init/__exit/__initdata include/linux/init.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1730>1730</a></td>\n' +
            '<td>After boot, the kernel frees up a special section; functions marked with __init and data structures marked with __initdata are dropped after boot is complete: similarly modules discard this memory after initialization. __exit is used to declare a function which is only required on exit: the function will be dropped if this file is not compiled as a module. See the header file for use. Note that it makes no sense for a function marked with __init to be exported to modules with EXPORT_SYMBOL() - this will break.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1731>1731</a></td>\n' +
            '<td>__initcall()/module_init() include/linux/init.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1732>1732</a></td>\n' +
            '<td>Many parts of the kernel are well served as a module (dynamically-loadable parts of the kernel). Using the module_init() and module_exit() macros it is easy to write code without #ifdefs which can operate both as a module or built into the kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1733>1733</a></td>\n' +
            '<td>The module_init() macro defines which function is to be called at module insertion time (if the file is compiled as a module), or at boot time: if the file is not compiled as a module the module_init() macro becomes equivalent to __initcall(), which through linker magic ensures that the function is called on boot.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1734>1734</a></td>\n' +
            '<td>The function can return a negative error number to cause module loading to fail (unfortunately, this has no effect if the module is compiled into the kernel). This function is called in user context with interrupts enabled, so it can sleep.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1735>1735</a></td>\n' +
            '<td>module_exit() include/linux/init.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1736>1736</a></td>\n' +
            '<td>This macro defines the function to be called at module removal time (or never, in the case of the file compiled into the kernel). It will only be called if the module usage count has reached zero. This function can also sleep, but cannot fail: everything must be cleaned up by the time it returns.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1737>1737</a></td>\n' +
            '<td>Note that this macro is optional: if it is not present, your module will not be removable (except for ' + "'" + 'rmmod -f' + "'" + ').</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1738>1738</a></td>\n' +
            '<td>try_module_get()/module_put() include/linux/module.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1739>1739</a></td>\n' +
            '<td>These manipulate the module usage count, to protect against removal (a module also can' + "'" + 't be removed if another module uses one of its exported symbols: see below). Before calling into module code, you should call try_module_get() on that module: if it fails, then the module is being removed and you should act as if it wasn' + "'" + 't there. Otherwise, you can safely enter the module, and call module_put() when you' + "'" + 're finished.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1740>1740</a></td>\n' +
            '<td>Most registerable structures have an owner field, such as in the file_operations structure. Set this field to the macro THIS_MODULE.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1741>1741</a></td>\n' +
            '<td>Wait Queues include/linux/wait.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1742>1742</a></td>\n' +
            '<td>[SLEEPS]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1743>1743</a></td>\n' +
            '<td>A wait queue is used to wait for someone to wake you up when a certain condition is true. They must be used carefully to ensure there is no race condition. You declare a wait_queue_head_t, and then processes which want to wait for that condition declare a wait_queue_t referring to themselves, and place that in the queue.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1744>1744</a></td>\n' +
            '<td>Declaring</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1745>1745</a></td>\n' +
            '<td>You declare a wait_queue_head_t using the DECLARE_WAIT_QUEUE_HEAD() macro, or using the init_waitqueue_head() routine in your initialization code.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1746>1746</a></td>\n' +
            '<td>Queuing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1747>1747</a></td>\n' +
            '<td>Placing yourself in the waitqueue is fairly complex, because you must put yourself in the queue before checking the condition. There is a macro to do this: wait_event_interruptible() include/linux/wait.h The first argument is the wait queue head, and the second is an expression which is evaluated; the macro returns 0 when this expression is true, or -ERESTARTSYS if a signal is received. The wait_event() version ignores signals.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1748>1748</a></td>\n' +
            '<td>Do not use the sleep_on() function family - it is very easy to accidentally introduce races; almost certainly one of the wait_event() family will do, or a loop around schedule_timeout(). If you choose to loop around schedule_timeout() remember you must set the task state (with set_current_state()) on each iteration to avoid busy-looping.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1749>1749</a></td>\n' +
            '<td>Waking Up Queued Tasks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1750>1750</a></td>\n' +
            '<td>Call wake_up() include/linux/wait.h;, which will wake up every process in the queue. The exception is if one has TASK_EXCLUSIVE set, in which case the remainder of the queue will not be woken. There are other variants of this basic function available in the same header.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1751>1751</a></td>\n' +
            '<td>Atomic Operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1752>1752</a></td>\n' +
            '<td>Certain operations are guaranteed atomic on all platforms. The first class of operations work on atomic_t include/asm/atomic.h; this contains a signed integer (at least 32 bits long), and you must use these functions to manipulate or read atomic_t variables. atomic_read() and atomic_set() get and set the counter, atomic_add(), atomic_sub(), atomic_inc(), atomic_dec(), and atomic_dec_and_test() (returns true if it was decremented to zero).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1753>1753</a></td>\n' +
            '<td>Yes. It returns true (i.e. != 0) if the atomic variable is zero.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1754>1754</a></td>\n' +
            '<td>Note that these functions are slower than normal arithmetic, and so should not be used unnecessarily.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1755>1755</a></td>\n' +
            '<td>The second class of atomic operations is atomic bit operations on an unsigned long, defined in include/linux/bitops.h. These operations generally take a pointer to the bit pattern, and a bit number: 0 is the least significant bit. set_bit(), clear_bit() and change_bit() set, clear, and flip the given bit. test_and_set_bit(), test_and_clear_bit() and test_and_change_bit() do the same thing, except return true if the bit was previously set; these are particularly useful for atomically setting flags.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1756>1756</a></td>\n' +
            '<td>It is possible to call these operations with bit indices greater than BITS_PER_LONG. The resulting behavior is strange on big-endian platforms though so it is a good idea not to do this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1757>1757</a></td>\n' +
            '<td>Symbols</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1758>1758</a></td>\n' +
            '<td>Within the kernel proper, the normal linking rules apply (ie. unless a symbol is declared to be file scope with the static keyword, it can be used anywhere in the kernel). However, for modules, a special exported symbol table is kept which limits the entry points to the kernel proper. Modules can also export symbols.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1759>1759</a></td>\n' +
            '<td>EXPORT_SYMBOL() include/linux/export.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1760>1760</a></td>\n' +
            '<td>This is the classic method of exporting a symbol: dynamically loaded modules will be able to use the symbol as normal.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1761>1761</a></td>\n' +
            '<td>EXPORT_SYMBOL_GPL() include/linux/export.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1762>1762</a></td>\n' +
            '<td>Similar to EXPORT_SYMBOL() except that the symbols exported by EXPORT_SYMBOL_GPL() can only be seen by modules with a MODULE_LICENSE() that specifies a GPL compatible license. It implies that the function is considered an internal implementation issue, and not really an interface.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1763>1763</a></td>\n' +
            '<td>Routines and Conventions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1764>1764</a></td>\n' +
            '<td>Double-linked lists include/linux/list.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1765>1765</a></td>\n' +
            '<td>There used to be three sets of linked-list routines in the kernel headers, but this one is the winner. If you don' + "'" + 't have some particular pressing need for a single list, it' + "'" + 's a good choice.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1766>1766</a></td>\n' +
            '<td>In particular, list_for_each_entry is useful.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1767>1767</a></td>\n' +
            '<td>Return Conventions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1768>1768</a></td>\n' +
            '<td>For code called in user context, it' + "'" + 's very common to defy C convention, and return 0 for success, and a negative error number (eg. -EFAULT) for failure. This can be unintuitive at first, but it' + "'" + 's fairly widespread in the kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1769>1769</a></td>\n' +
            '<td>Using ERR_PTR() include/linux/err.h; to encode a negative error number into a pointer, and IS_ERR() and PTR_ERR() to get it back out again: avoids a separate pointer parameter for the error number. Icky, but in a good way.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1770>1770</a></td>\n' +
            '<td>Breaking Compilation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1771>1771</a></td>\n' +
            '<td>Linus and the other developers sometimes change function or structure names in development kernels; this is not done just to keep everyone on their toes: it reflects a fundamental change (eg. can no longer be called with interrupts on, or does extra checks, or doesn' + "'" + 't do checks which were caught before). Usually this is accompanied by a fairly complete note to the linux-kernel mailing list; search the archive. Simply doing a global replace on the file usually makes things worse.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1772>1772</a></td>\n' +
            '<td>Initializing structure members</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1773>1773</a></td>\n' +
            '<td>The preferred method of initializing structures is to use designated initialisers, as defined by ISO C99, eg:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1774>1774</a></td>\n' +
            '<td>static struct block_device_operations opt_fops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1775>1775</a></td>\n' +
            '<td>        .open               = opt_open,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1776>1776</a></td>\n' +
            '<td>        .release            = opt_release,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1777>1777</a></td>\n' +
            '<td>        .ioctl              = opt_ioctl,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1778>1778</a></td>\n' +
            '<td>        .check_media_change = opt_media_change,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1779>1779</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1780>1780</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1781>1781</a></td>\n' +
            '<td>This makes it easy to grep for, and makes it clear which structure fields are set. You should do this because it looks cool.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1782>1782</a></td>\n' +
            '<td>GNU Extensions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1783>1783</a></td>\n' +
            '<td>GNU Extensions are explicitly allowed in the Linux kernel. Note that some of the more complex ones are not very well supported, due to lack of general use, but the following are considered standard (see the GCC info page section "C Extensions" for more details - Yes, really the info page, the man page is only a short summary of the stuff in info).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1784>1784</a></td>\n' +
            '<td>    Inline functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1785>1785</a></td>\n' +
            '<td>    Statement expressions (ie. the ({ and }) constructs).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1786>1786</a></td>\n' +
            '<td>    Declaring attributes of a function / variable / type (__attribute__)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1787>1787</a></td>\n' +
            '<td>    typeof</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1788>1788</a></td>\n' +
            '<td>    Zero length arrays</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1789>1789</a></td>\n' +
            '<td>    Macro varargs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1790>1790</a></td>\n' +
            '<td>    Arithmetic on void pointers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1791>1791</a></td>\n' +
            '<td>    Non-Constant initializers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1792>1792</a></td>\n' +
            '<td>    Assembler Instructions (not outside arch/ and include/asm/)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1793>1793</a></td>\n' +
            '<td>    Function names as strings (__func__).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1794>1794</a></td>\n' +
            '<td>    __builtin_constant_p()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1795>1795</a></td>\n' +
            '<td>Be wary when using long long in the kernel, the code gcc generates for it is horrible and worse: division and multiplication does not work on i386 because the GCC runtime functions for it are missing from the kernel environment.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1796>1796</a></td>\n' +
            '<td>C++</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1797>1797</a></td>\n' +
            '<td>Using C++ in the kernel is usually a bad idea, because the kernel does not provide the necessary runtime environment and the include files are not tested for it. It is still possible, but not recommended. If you really want to do this, forget about exceptions at least.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1798>1798</a></td>\n' +
            '<td>NUMif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1799>1799</a></td>\n' +
            '<td>It is generally considered cleaner to use macros in header files (or at the top of .c files) to abstract away functions rather than using `#if' + "'" + ' pre-processor statements throughout the source code.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1800>1800</a></td>\n' +
            '<td>Putting Your Stuff in the Kernel</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1801>1801</a></td>\n' +
            '<td>In order to get your stuff into shape for official inclusion, or even to make a neat patch, there' + "'" + 's administrative work to be done:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1802>1802</a></td>\n' +
            '<td>    Figure out whose pond you' + "'" + 've been pissing in. Look at the top of the source files, inside the MAINTAINERS file, and last of all in the CREDITS file. You should coordinate with this person to make sure you' + "'" + 're not duplicating effort, or trying something that' + "'" + 's already been rejected.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1803>1803</a></td>\n' +
            '<td>     Make sure you put your name and EMail address at the top of any files you create or mangle significantly. This is the first place people will look when they find a bug, or when they want to make a change.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1804>1804</a></td>\n' +
            '<td>    Usually you want a configuration option for your kernel hack. Edit Kconfig in the appropriate directory. The Config language is simple to use by cut and paste, and there' + "'" + 's complete documentation in Documentation/kbuild/kconfig-language.txt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1805>1805</a></td>\n' +
            '<td>     In your description of the option, make sure you address both the expert user and the user who knows nothing about your feature. Mention incompatibilities and issues here. Definitely end your description with if in doubt, say N (or, occasionally, `Y' + "'" + '); this is for people who have no idea what you are talking about.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1806>1806</a></td>\n' +
            '<td>    Edit the Makefile: the CONFIG variables are exported here so you can usually just add a "obj-$(CONFIG_xxx) += xxx.o" line. The syntax is documented in Documentation/kbuild/makefiles.txt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1807>1807</a></td>\n' +
            '<td>    Put yourself in CREDITS if you' + "'" + 've done something noteworthy, usually beyond a single file (your name should be at the top of the source files anyway). MAINTAINERS means you want to be consulted when changes are made to a subsystem, and hear about bugs; it implies a more-than-passing commitment to some part of the code.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1808>1808</a></td>\n' +
            '<td>    Finally, don' + "'" + 't forget to read Documentation/SubmittingPatches and possibly Documentation/SubmittingDrivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1809>1809</a></td>\n' +
            '<td>Kernel Cantrips</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1810>1810</a></td>\n' +
            '<td>Some favorites from browsing the source. Feel free to add to this list.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1811>1811</a></td>\n' +
            '<td>arch/x86/include/asm/delay.h:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1812>1812</a></td>\n' +
            '<td>#define ndelay(n) (__builtin_constant_p(n) ? \\</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1813>1813</a></td>\n' +
            '<td>        ((n) &gt; 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \\</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1814>1814</a></td>\n' +
            '<td>        __ndelay(n))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1815>1815</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1816>1816</a></td>\n' +
            '<td>include/linux/fs.h:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1817>1817</a></td>\n' +
            '<td>/*</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1818>1818</a></td>\n' +
            '<td> * Kernel pointers have redundant information, so we can use a</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1819>1819</a></td>\n' +
            '<td> * scheme where we can return either an error code or a dentry</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1820>1820</a></td>\n' +
            '<td> * pointer with the same return value.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1821>1821</a></td>\n' +
            '<td> *</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1822>1822</a></td>\n' +
            '<td> * This should be a per-architecture thing, to allow different</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1823>1823</a></td>\n' +
            '<td> * error and pointer decisions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1824>1824</a></td>\n' +
            '<td> */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1825>1825</a></td>\n' +
            '<td> #define ERR_PTR(err)    ((void *)((long)(err)))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1826>1826</a></td>\n' +
            '<td> #define PTR_ERR(ptr)    ((long)(ptr))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1827>1827</a></td>\n' +
            '<td> #define IS_ERR(ptr)     ((unsigned long)(ptr) &gt; (unsigned long)(-1000))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1828>1828</a></td>\n' +
            '<td>arch/x86/include/asm/uaccess_32.h:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1829>1829</a></td>\n' +
            '<td>#define copy_to_user(to,from,n)                         \\</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1830>1830</a></td>\n' +
            '<td>        (__builtin_constant_p(n) ?                      \\</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1831>1831</a></td>\n' +
            '<td>         __constant_copy_to_user((to),(from),(n)) :     \\</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1832>1832</a></td>\n' +
            '<td>         __generic_copy_to_user((to),(from),(n)))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1833>1833</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1834>1834</a></td>\n' +
            '<td>arch/sparc/kernel/head.S:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1835>1835</a></td>\n' +
            '<td>/*</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1836>1836</a></td>\n' +
            '<td> * Sun people can' + "'" + 't spell worth damn. "compatability" indeed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1837>1837</a></td>\n' +
            '<td> * At least we *know* we can' + "'" + 't spell, and use a spell-checker.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1838>1838</a></td>\n' +
            '<td> */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1839>1839</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1840>1840</a></td>\n' +
            '<td>/* Uh, actually Linus it is I who cannot spell. Too much murky</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1841>1841</a></td>\n' +
            '<td> * Sparc assembly will do this to ya.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1842>1842</a></td>\n' +
            '<td> */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1843>1843</a></td>\n' +
            '<td>C_LABEL(cputypvar):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1844>1844</a></td>\n' +
            '<td>        .asciz "compatibility"</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1845>1845</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1846>1846</a></td>\n' +
            '<td>/* Tested on SS-5, SS-10. Probably someone at Sun applied a spell-checker. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1847>1847</a></td>\n' +
            '<td>        .align 4</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1848>1848</a></td>\n' +
            '<td>C_LABEL(cputypvar_sun4m):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1849>1849</a></td>\n' +
            '<td>        .asciz "compatible"</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1850>1850</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1851>1851</a></td>\n' +
            '<td>arch/sparc/lib/checksum.S:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1852>1852</a></td>\n' +
            '<td>        /* Sun, you just can' + "'" + 't beat me, you just can' + "'" + 't.  Stop trying,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1853>1853</a></td>\n' +
            '<td>         * give up.  I' + "'" + 'm serious, I am going to kick the living shit</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1854>1854</a></td>\n' +
            '<td>         * out of you, game over, lights out.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1855>1855</a></td>\n' +
            '<td>         */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1856>1856</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1857>1857</a></td>\n' +
            '<td>Thanks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1858>1858</a></td>\n' +
            '<td>Thanks to Andi Kleen for the idea, answering my questions, fixing my mistakes, filling content, etc. Philipp Rumpf for more spelling and clarity fixes, and some excellent non-obvious points. Werner Almesberger for giving me a great summary of disable_irq(), and Jes Sorensen and Andrea Arcangeli added caveats. Michael Elizabeth Chastain for checking and adding to the Configure section. Telsa Gwynne for teaching me DocBook.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1859>1859</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1860>1860</a></td>\n' +
            '<td>Welcome, to Rusty' + "'" + 's Remarkably Unreliable Guide to Kernel Locking issues. This document describes the locking systems in the Linux Kernel in 2.6.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1861>1861</a></td>\n' +
            '<td>With the wide availability of HyperThreading, and preemption in the Linux Kernel, everyone hacking on the kernel needs to know the fundamentals of concurrency and locking for SMP.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1862>1862</a></td>\n' +
            '<td>The Problem With Concurrency</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1863>1863</a></td>\n' +
            '<td>(Skip this if you know what a Race Condition is).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1864>1864</a></td>\n' +
            '<td>In a normal program, you can increment a counter like so:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1865>1865</a></td>\n' +
            '<td>      very_important_count++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1866>1866</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1867>1867</a></td>\n' +
            '<td>This is what they would expect to happen:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1868>1868</a></td>\n' +
            '<td>Expected Results</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1869>1869</a></td>\n' +
            '<td>Instance 1    Instance 2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1870>1870</a></td>\n' +
            '<td>read very_important_count (5)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1871>1871</a></td>\n' +
            '<td>add 1 (6)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1872>1872</a></td>\n' +
            '<td>write very_important_count (6)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1873>1873</a></td>\n' +
            '<td>    read very_important_count (6)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1874>1874</a></td>\n' +
            '<td>    add 1 (7)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1875>1875</a></td>\n' +
            '<td>    write very_important_count (7)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1876>1876</a></td>\n' +
            '<td>This is what might happen:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1877>1877</a></td>\n' +
            '<td>Possible Results</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1878>1878</a></td>\n' +
            '<td>Instance 1    Instance 2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1879>1879</a></td>\n' +
            '<td>read very_important_count (5)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1880>1880</a></td>\n' +
            '<td>    read very_important_count (5)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1881>1881</a></td>\n' +
            '<td>add 1 (6)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1882>1882</a></td>\n' +
            '<td>    add 1 (6)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1883>1883</a></td>\n' +
            '<td>write very_important_count (6)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1884>1884</a></td>\n' +
            '<td>    write very_important_count (6)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1885>1885</a></td>\n' +
            '<td>Race Conditions and Critical Regions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1886>1886</a></td>\n' +
            '<td>This overlap, where the result depends on the relative timing of multiple tasks, is called a race condition. The piece of code containing the concurrency issue is called a critical region. And especially since Linux starting running on SMP machines, they became one of the major issues in kernel design and implementation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1887>1887</a></td>\n' +
            '<td>Preemption can have the same effect, even if there is only one CPU: by preempting one task during the critical region, we have exactly the same race condition. In this case the thread which preempts might run the critical region itself.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1888>1888</a></td>\n' +
            '<td>The solution is to recognize when these simultaneous accesses occur, and use locks to make sure that only one instance can enter the critical region at any time. There are many friendly primitives in the Linux kernel to help you do this. And then there are the unfriendly primitives, but I' + "'" + 'll pretend they don' + "'" + 't exist.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1889>1889</a></td>\n' +
            '<td>Locking in the Linux Kernel</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1890>1890</a></td>\n' +
            '<td>If I could give you one piece of advice: never sleep with anyone crazier than yourself. But if I had to give you advice on locking: keep it simple.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1891>1891</a></td>\n' +
            '<td>Be reluctant to introduce new locks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1892>1892</a></td>\n' +
            '<td>Strangely enough, this last one is the exact reverse of my advice when you have slept with someone crazier than yourself. And you should think about getting a big dog.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1893>1893</a></td>\n' +
            '<td>Two Main Types of Kernel Locks: Spinlocks and Mutexes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1894>1894</a></td>\n' +
            '<td>There are two main types of kernel locks. The fundamental type is the spinlock (include/asm/spinlock.h), which is a very simple single-holder lock: if you can' + "'" + 't get the spinlock, you keep trying (spinning) until you can. Spinlocks are very small and fast, and can be used anywhere.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1895>1895</a></td>\n' +
            '<td>The second type is a mutex (include/linux/mutex.h): it is like a spinlock, but you may block holding a mutex. If you can' + "'" + 't lock a mutex, your task will suspend itself, and be woken up when the mutex is released. This means the CPU can do something else while you are waiting. There are many cases when you simply can' + "'" + 't sleep (see ???), and so have to use a spinlock instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1896>1896</a></td>\n' +
            '<td>Neither type of lock is recursive: see ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1897>1897</a></td>\n' +
            '<td>Locks and Uniprocessor Kernels</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1898>1898</a></td>\n' +
            '<td>For kernels compiled without CONFIG_SMP, and without CONFIG_PREEMPT spinlocks do not exist at all. This is an excellent design decision: when no-one else can run at the same time, there is no reason to have a lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1899>1899</a></td>\n' +
            '<td>If the kernel is compiled without CONFIG_SMP, but CONFIG_PREEMPT is set, then spinlocks simply disable preemption, which is sufficient to prevent any races. For most purposes, we can think of preemption as equivalent to SMP, and not worry about it separately.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1900>1900</a></td>\n' +
            '<td>You should always test your locking code with CONFIG_SMP and CONFIG_PREEMPT enabled, even if you don' + "'" + 't have an SMP test box, because it will still catch some kinds of locking bugs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1901>1901</a></td>\n' +
            '<td>Mutexes still exist, because they are required for synchronization between user contexts, as we will see below.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1902>1902</a></td>\n' +
            '<td>Locking Only In User Context</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1903>1903</a></td>\n' +
            '<td>If you have a data structure which is only ever accessed from user context, then you can use a simple mutex (include/linux/mutex.h) to protect it. This is the most trivial case: you initialize the mutex. Then you can call mutex_lock_interruptible() to grab the mutex, and mutex_unlock() to release it. There is also a mutex_lock(), which should be avoided, because it will not return if a signal is received.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1904>1904</a></td>\n' +
            '<td>Example: net/netfilter/nf_sockopt.c allows registration of new setsockopt() and getsockopt() calls, with nf_register_sockopt(). Registration and de-registration are only done on module load and unload (and boot time, where there is no concurrency), and the list of registrations is only consulted for an unknown setsockopt() or getsockopt() system call. The nf_sockopt_mutex is perfect to protect this, especially since the setsockopt and getsockopt calls may well sleep.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1905>1905</a></td>\n' +
            '<td>Locking Between User Context and Softirqs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1906>1906</a></td>\n' +
            '<td>If a softirq shares data with user context, you have two problems. Firstly, the current user context can be interrupted by a softirq, and secondly, the critical region could be entered from another CPU. This is where spin_lock_bh() (include/linux/spinlock.h) is used. It disables softirqs on that CPU, then grabs the lock. spin_unlock_bh() does the reverse. (The ' + "'" + '_bh' + "'" + ' suffix is a historical reference to "Bottom Halves", the old name for software interrupts. It should really be called spin_lock_softirq()' + "'" + ' in a perfect world).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1907>1907</a></td>\n' +
            '<td>Note that you can also use spin_lock_irq() or spin_lock_irqsave() here, which stop hardware interrupts as well: see ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1908>1908</a></td>\n' +
            '<td>This works perfectly for UP as well: the spin lock vanishes, and this macro simply becomes local_bh_disable() (include/linux/interrupt.h), which protects you from the softirq being run.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1909>1909</a></td>\n' +
            '<td>Locking Between User Context and Tasklets</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1910>1910</a></td>\n' +
            '<td>This is exactly the same as above, because tasklets are actually run from a softirq.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1911>1911</a></td>\n' +
            '<td>Locking Between User Context and Timers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1912>1912</a></td>\n' +
            '<td>This, too, is exactly the same as above, because timers are actually run from a softirq. From a locking point of view, tasklets and timers are identical.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1913>1913</a></td>\n' +
            '<td>Locking Between Tasklets/Timers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1914>1914</a></td>\n' +
            '<td>Sometimes a tasklet or timer might want to share data with another tasklet or timer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1915>1915</a></td>\n' +
            '<td>The Same Tasklet/Timer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1916>1916</a></td>\n' +
            '<td>Since a tasklet is never run on two CPUs at once, you don' + "'" + 't need to worry about your tasklet being reentrant (running twice at once), even on SMP.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1917>1917</a></td>\n' +
            '<td>Different Tasklets/Timers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1918>1918</a></td>\n' +
            '<td>If another tasklet/timer wants to share data with your tasklet or timer , you will both need to use spin_lock() and spin_unlock() calls. spin_lock_bh() is unnecessary here, as you are already in a tasklet, and none will be run on the same CPU.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1919>1919</a></td>\n' +
            '<td>Locking Between Softirqs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1920>1920</a></td>\n' +
            '<td>Often a softirq might want to share data with itself or a tasklet/timer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1921>1921</a></td>\n' +
            '<td>The Same Softirq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1922>1922</a></td>\n' +
            '<td>The same softirq can run on the other CPUs: you can use a per-CPU array (see ???) for better performance. If you' + "'" + 're going so far as to use a softirq, you probably care about scalable performance enough to justify the extra complexity.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1923>1923</a></td>\n' +
            '<td>You' + "'" + 'll need to use spin_lock() and spin_unlock() for shared data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1924>1924</a></td>\n' +
            '<td>Different Softirqs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1925>1925</a></td>\n' +
            '<td>You' + "'" + 'll need to use spin_lock() and spin_unlock() for shared data, whether it be a timer, tasklet, different softirq or the same or another softirq: any of them could be running on a different CPU.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1926>1926</a></td>\n' +
            '<td>Hard IRQ Context</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1927>1927</a></td>\n' +
            '<td>Hardware interrupts usually communicate with a tasklet or softirq. Frequently this involves putting work in a queue, which the softirq will take out.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1928>1928</a></td>\n' +
            '<td>Locking Between Hard IRQ and Softirqs/Tasklets</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1929>1929</a></td>\n' +
            '<td>If a hardware irq handler shares data with a softirq, you have two concerns. Firstly, the softirq processing can be interrupted by a hardware interrupt, and secondly, the critical region could be entered by a hardware interrupt on another CPU. This is where spin_lock_irq() is used. It is defined to disable interrupts on that cpu, then grab the lock. spin_unlock_irq() does the reverse.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1930>1930</a></td>\n' +
            '<td>The irq handler does not to use spin_lock_irq(), because the softirq cannot run while the irq handler is running: it can use spin_lock(), which is slightly faster. The only exception would be if a different hardware irq handler uses the same lock: spin_lock_irq() will stop that from interrupting us.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1931>1931</a></td>\n' +
            '<td>This works perfectly for UP as well: the spin lock vanishes, and this macro simply becomes local_irq_disable() (include/asm/smp.h), which protects you from the softirq/tasklet/BH being run.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1932>1932</a></td>\n' +
            '<td>spin_lock_irqsave() (include/linux/spinlock.h) is a variant which saves whether interrupts were on or off in a flags word, which is passed to spin_unlock_irqrestore(). This means that the same code can be used inside an hard irq handler (where interrupts are already off) and in softirqs (where the irq disabling is required).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1933>1933</a></td>\n' +
            '<td>Note that softirqs (and hence tasklets and timers) are run on return from hardware interrupts, so spin_lock_irq() also stops these. In that sense, spin_lock_irqsave() is the most general and powerful locking function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1934>1934</a></td>\n' +
            '<td>Locking Between Two Hard IRQ Handlers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1935>1935</a></td>\n' +
            '<td>It is rare to have to share data between two IRQ handlers, but if you do, spin_lock_irqsave() should be used: it is architecture-specific whether all interrupts are disabled inside irq handlers themselves.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1936>1936</a></td>\n' +
            '<td>Cheat Sheet For Locking</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1937>1937</a></td>\n' +
            '<td>Pete Zaitcev gives the following summary:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1938>1938</a></td>\n' +
            '<td>    If you are in a process context (any syscall) and want to lock other process out, use a mutex. You can take a mutex and sleep (copy_from_user*( or kmalloc(x,GFP_KERNEL)).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1939>1939</a></td>\n' +
            '<td>    Otherwise (== data can be touched in an interrupt), use spin_lock_irqsave() and spin_unlock_irqrestore().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1940>1940</a></td>\n' +
            '<td>    Avoid holding spinlock for more than 5 lines of code and across any function call (except accessors like readb).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1941>1941</a></td>\n' +
            '<td>Table of Minimum Requirements</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1942>1942</a></td>\n' +
            '<td>The following table lists the minimum locking requirements between various contexts. In some cases, the same context can only be running on one CPU at a time, so no locking is required for that context (eg. a particular thread can only run on one CPU at a time, but if it needs shares data with another thread, locking is required).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1943>1943</a></td>\n' +
            '<td>Remember the advice above: you can always use spin_lock_irqsave(), which is a superset of all other spinlock primitives.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1944>1944</a></td>\n' +
            '<td>Table of Locking Requirements</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1945>1945</a></td>\n' +
            '<td>    IRQ Handler A    IRQ Handler B    Softirq A    Softirq B    Tasklet A    Tasklet B    Timer A    Timer B    User Context A    User Context B</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1946>1946</a></td>\n' +
            '<td>IRQ Handler A    None</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1947>1947</a></td>\n' +
            '<td>IRQ Handler B    SLIS    None</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1948>1948</a></td>\n' +
            '<td>Softirq A    SLI    SLI    SL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1949>1949</a></td>\n' +
            '<td>Softirq B    SLI    SLI    SL    SL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1950>1950</a></td>\n' +
            '<td>Tasklet A    SLI    SLI    SL    SL    None</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1951>1951</a></td>\n' +
            '<td>Tasklet B    SLI    SLI    SL    SL    SL    None</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1952>1952</a></td>\n' +
            '<td>Timer A    SLI    SLI    SL    SL    SL    SL    None</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1953>1953</a></td>\n' +
            '<td>Timer B    SLI    SLI    SL    SL    SL    SL    SL    None</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1954>1954</a></td>\n' +
            '<td>User Context A    SLI    SLI    SLBH    SLBH    SLBH    SLBH    SLBH    SLBH    None</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1955>1955</a></td>\n' +
            '<td>User Context B    SLI    SLI    SLBH    SLBH    SLBH    SLBH    SLBH    SLBH    MLI    None</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1956>1956</a></td>\n' +
            '<td>Legend for Locking Requirements Table</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1957>1957</a></td>\n' +
            '<td>SLIS    spin_lock_irqsave</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1958>1958</a></td>\n' +
            '<td>SLI    spin_lock_irq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1959>1959</a></td>\n' +
            '<td>SL    spin_lock</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1960>1960</a></td>\n' +
            '<td>SLBH    spin_lock_bh</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1961>1961</a></td>\n' +
            '<td>MLI    mutex_lock_interruptible</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1962>1962</a></td>\n' +
            '<td>The trylock Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1963>1963</a></td>\n' +
            '<td>There are functions that try to acquire a lock only once and immediately return a value telling about success or failure to acquire the lock. They can be used if you need no access to the data protected with the lock when some other thread is holding the lock. You should acquire the lock later if you then need access to the data protected with the lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1964>1964</a></td>\n' +
            '<td>spin_trylock() does not spin but returns non-zero if it acquires the spinlock on the first try or 0 if not. This function can be used in all contexts like spin_lock: you must have disabled the contexts that might interrupt you and acquire the spin lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1965>1965</a></td>\n' +
            '<td>mutex_trylock() does not suspend your task but returns non-zero if it could lock the mutex on the first try or 0 if not. This function cannot be safely used in hardware or software interrupt contexts despite not sleeping.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1966>1966</a></td>\n' +
            '<td>Common Examples</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1967>1967</a></td>\n' +
            '<td>Let' + "'" + 's step through a simple example: a cache of number to name mappings. The cache keeps a count of how often each of the objects is used, and when it gets full, throws out the least used one.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1968>1968</a></td>\n' +
            '<td>All In User Context</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1969>1969</a></td>\n' +
            '<td>For our first example, we assume that all operations are in user context (ie. from system calls), so we can sleep. This means we can use a mutex to protect the cache and all the objects within it. Here' + "'" + 's the code:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1970>1970</a></td>\n' +
            '<td>#include &lt;linux/list.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1971>1971</a></td>\n' +
            '<td>#include &lt;linux/slab.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1972>1972</a></td>\n' +
            '<td>#include &lt;linux/string.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1973>1973</a></td>\n' +
            '<td>#include &lt;linux/mutex.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1974>1974</a></td>\n' +
            '<td>#include &lt;asm/errno.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1975>1975</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1976>1976</a></td>\n' +
            '<td>struct object</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1977>1977</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1978>1978</a></td>\n' +
            '<td>        struct list_head list;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1979>1979</a></td>\n' +
            '<td>        int id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1980>1980</a></td>\n' +
            '<td>        char name[32];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1981>1981</a></td>\n' +
            '<td>        int popularity;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1982>1982</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1983>1983</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1984>1984</a></td>\n' +
            '<td>/* Protects the cache, cache_num, and the objects within it */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1985>1985</a></td>\n' +
            '<td>static DEFINE_MUTEX(cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1986>1986</a></td>\n' +
            '<td>static LIST_HEAD(cache);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1987>1987</a></td>\n' +
            '<td>static unsigned int cache_num = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1988>1988</a></td>\n' +
            '<td>#define MAX_CACHE_SIZE 10</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1989>1989</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1990>1990</a></td>\n' +
            '<td>/* Must be holding cache_lock */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1991>1991</a></td>\n' +
            '<td>static struct object *__cache_find(int id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1992>1992</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1993>1993</a></td>\n' +
            '<td>        struct object *i;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1994>1994</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1995>1995</a></td>\n' +
            '<td>        list_for_each_entry(i, &amp;cache, list)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1996>1996</a></td>\n' +
            '<td>                if (i-&gt;id == id) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1997>1997</a></td>\n' +
            '<td>                        i-&gt;popularity++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1998>1998</a></td>\n' +
            '<td>                        return i;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=1999>1999</a></td>\n' +
            '<td>                }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2000>2000</a></td>\n' +
            '<td>        return NULL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2001>2001</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2002>2002</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2003>2003</a></td>\n' +
            '<td>/* Must be holding cache_lock */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2004>2004</a></td>\n' +
            '<td>static void __cache_delete(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2005>2005</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2006>2006</a></td>\n' +
            '<td>        BUG_ON(!obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2007>2007</a></td>\n' +
            '<td>        list_del(&amp;obj-&gt;list);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2008>2008</a></td>\n' +
            '<td>        kfree(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2009>2009</a></td>\n' +
            '<td>        cache_num--;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2010>2010</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2011>2011</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2012>2012</a></td>\n' +
            '<td>/* Must be holding cache_lock */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2013>2013</a></td>\n' +
            '<td>static void __cache_add(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2014>2014</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2015>2015</a></td>\n' +
            '<td>        list_add(&amp;obj-&gt;list, &amp;cache);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2016>2016</a></td>\n' +
            '<td>        if (++cache_num &gt; MAX_CACHE_SIZE) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2017>2017</a></td>\n' +
            '<td>                struct object *i, *outcast = NULL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2018>2018</a></td>\n' +
            '<td>                list_for_each_entry(i, &amp;cache, list) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2019>2019</a></td>\n' +
            '<td>                        if (!outcast || i-&gt;popularity &lt; outcast-&gt;popularity)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2020>2020</a></td>\n' +
            '<td>                                outcast = i;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2021>2021</a></td>\n' +
            '<td>                }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2022>2022</a></td>\n' +
            '<td>                __cache_delete(outcast);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2023>2023</a></td>\n' +
            '<td>        }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2024>2024</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2025>2025</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2026>2026</a></td>\n' +
            '<td>int cache_add(int id, const char *name)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2027>2027</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2028>2028</a></td>\n' +
            '<td>        struct object *obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2029>2029</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2030>2030</a></td>\n' +
            '<td>        if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2031>2031</a></td>\n' +
            '<td>                return -ENOMEM;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2032>2032</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2033>2033</a></td>\n' +
            '<td>        strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2034>2034</a></td>\n' +
            '<td>        obj-&gt;id = id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2035>2035</a></td>\n' +
            '<td>        obj-&gt;popularity = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2036>2036</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2037>2037</a></td>\n' +
            '<td>        mutex_lock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2038>2038</a></td>\n' +
            '<td>        __cache_add(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2039>2039</a></td>\n' +
            '<td>        mutex_unlock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2040>2040</a></td>\n' +
            '<td>        return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2041>2041</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2042>2042</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2043>2043</a></td>\n' +
            '<td>void cache_delete(int id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2044>2044</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2045>2045</a></td>\n' +
            '<td>        mutex_lock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2046>2046</a></td>\n' +
            '<td>        __cache_delete(__cache_find(id));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2047>2047</a></td>\n' +
            '<td>        mutex_unlock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2048>2048</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2049>2049</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2050>2050</a></td>\n' +
            '<td>int cache_find(int id, char *name)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2051>2051</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2052>2052</a></td>\n' +
            '<td>        struct object *obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2053>2053</a></td>\n' +
            '<td>        int ret = -ENOENT;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2054>2054</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2055>2055</a></td>\n' +
            '<td>        mutex_lock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2056>2056</a></td>\n' +
            '<td>        obj = __cache_find(id);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2057>2057</a></td>\n' +
            '<td>        if (obj) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2058>2058</a></td>\n' +
            '<td>                ret = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2059>2059</a></td>\n' +
            '<td>                strcpy(name, obj-&gt;name);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2060>2060</a></td>\n' +
            '<td>        }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2061>2061</a></td>\n' +
            '<td>        mutex_unlock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2062>2062</a></td>\n' +
            '<td>        return ret;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2063>2063</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2064>2064</a></td>\n' +
            '<td>Note that we always make sure we have the cache_lock when we add, delete, or look up the cache: both the cache infrastructure itself and the contents of the objects are protected by the lock. In this case it' + "'" + 's easy, since we copy the data for the user, and never let them access the objects directly.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2065>2065</a></td>\n' +
            '<td>There is a slight (and common) optimization here: in cache_add we set up the fields of the object before grabbing the lock. This is safe, as no-one else can access it until we put it in cache.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2066>2066</a></td>\n' +
            '<td>Accessing From Interrupt Context</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2067>2067</a></td>\n' +
            '<td>Now consider the case where cache_find can be called from interrupt context: either a hardware interrupt or a softirq. An example would be a timer which deletes object from the cache.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2068>2068</a></td>\n' +
            '<td>The change is shown below, in standard patch format: the - are lines which are taken away, and the + are lines which are added.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2069>2069</a></td>\n' +
            '<td>--- cache.c.usercontext 2003-12-09 13:58:54.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2070>2070</a></td>\n' +
            '<td>+++ cache.c.interrupt   2003-12-09 14:07:49.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2071>2071</a></td>\n' +
            '<td>@@ -12,7 +12,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2072>2072</a></td>\n' +
            '<td>         int popularity;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2073>2073</a></td>\n' +
            '<td> };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2074>2074</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2075>2075</a></td>\n' +
            '<td>-static DEFINE_MUTEX(cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2076>2076</a></td>\n' +
            '<td>+static DEFINE_SPINLOCK(cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2077>2077</a></td>\n' +
            '<td> static LIST_HEAD(cache);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2078>2078</a></td>\n' +
            '<td> static unsigned int cache_num = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2079>2079</a></td>\n' +
            '<td> #define MAX_CACHE_SIZE 10</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2080>2080</a></td>\n' +
            '<td>@@ -55,6 +55,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2081>2081</a></td>\n' +
            '<td> int cache_add(int id, const char *name)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2082>2082</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2083>2083</a></td>\n' +
            '<td>         struct object *obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2084>2084</a></td>\n' +
            '<td>+        unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2085>2085</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2086>2086</a></td>\n' +
            '<td>         if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2087>2087</a></td>\n' +
            '<td>                 return -ENOMEM;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2088>2088</a></td>\n' +
            '<td>@@ -63,30 +64,33 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2089>2089</a></td>\n' +
            '<td>         obj-&gt;id = id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2090>2090</a></td>\n' +
            '<td>         obj-&gt;popularity = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2091>2091</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2092>2092</a></td>\n' +
            '<td>-        mutex_lock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2093>2093</a></td>\n' +
            '<td>+        spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2094>2094</a></td>\n' +
            '<td>         __cache_add(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2095>2095</a></td>\n' +
            '<td>-        mutex_unlock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2096>2096</a></td>\n' +
            '<td>+        spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2097>2097</a></td>\n' +
            '<td>         return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2098>2098</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2099>2099</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2100>2100</a></td>\n' +
            '<td> void cache_delete(int id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2101>2101</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2102>2102</a></td>\n' +
            '<td>-        mutex_lock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2103>2103</a></td>\n' +
            '<td>+        unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2104>2104</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2105>2105</a></td>\n' +
            '<td>+        spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2106>2106</a></td>\n' +
            '<td>         __cache_delete(__cache_find(id));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2107>2107</a></td>\n' +
            '<td>-        mutex_unlock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2108>2108</a></td>\n' +
            '<td>+        spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2109>2109</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2110>2110</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2111>2111</a></td>\n' +
            '<td> int cache_find(int id, char *name)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2112>2112</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2113>2113</a></td>\n' +
            '<td>         struct object *obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2114>2114</a></td>\n' +
            '<td>         int ret = -ENOENT;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2115>2115</a></td>\n' +
            '<td>+        unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2116>2116</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2117>2117</a></td>\n' +
            '<td>-        mutex_lock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2118>2118</a></td>\n' +
            '<td>+        spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2119>2119</a></td>\n' +
            '<td>         obj = __cache_find(id);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2120>2120</a></td>\n' +
            '<td>         if (obj) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2121>2121</a></td>\n' +
            '<td>                 ret = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2122>2122</a></td>\n' +
            '<td>                 strcpy(name, obj-&gt;name);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2123>2123</a></td>\n' +
            '<td>         }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2124>2124</a></td>\n' +
            '<td>-        mutex_unlock(&amp;cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2125>2125</a></td>\n' +
            '<td>+        spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2126>2126</a></td>\n' +
            '<td>         return ret;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2127>2127</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2128>2128</a></td>\n' +
            '<td>Note that the spin_lock_irqsave will turn off interrupts if they are on, otherwise does nothing (if we are already in an interrupt handler), hence these functions are safe to call from any context.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2129>2129</a></td>\n' +
            '<td>Unfortunately, cache_add calls kmalloc with the GFP_KERNEL flag, which is only legal in user context. I have assumed that cache_add is still only called in user context, otherwise this should become a parameter to cache_add.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2130>2130</a></td>\n' +
            '<td>Exposing Objects Outside This File</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2131>2131</a></td>\n' +
            '<td>If our objects contained more information, it might not be sufficient to copy the information in and out: other parts of the code might want to keep pointers to these objects, for example, rather than looking up the id every time. This produces two problems.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2132>2132</a></td>\n' +
            '<td>The first problem is that we use the cache_lock to protect objects: we' + "'" + 'd need to make this non-static so the rest of the code can use it. This makes locking trickier, as it is no longer all in one place.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2133>2133</a></td>\n' +
            '<td>The second problem is the lifetime problem: if another structure keeps a pointer to an object, it presumably expects that pointer to remain valid. Unfortunately, this is only guaranteed while you hold the lock, otherwise someone might call cache_delete and even worse, add another object, re-using the same address.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2134>2134</a></td>\n' +
            '<td>As there is only one lock, you can' + "'" + 't hold it forever: no-one else would get any work done.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2135>2135</a></td>\n' +
            '<td>The solution to this problem is to use a reference count: everyone who has a pointer to the object increases it when they first get the object, and drops the reference count when they' + "'" + 're finished with it. Whoever drops it to zero knows it is unused, and can actually delete it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2136>2136</a></td>\n' +
            '<td>Here is the code:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2137>2137</a></td>\n' +
            '<td>--- cache.c.interrupt   2003-12-09 14:25:43.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2138>2138</a></td>\n' +
            '<td>+++ cache.c.refcnt  2003-12-09 14:33:05.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2139>2139</a></td>\n' +
            '<td>@@ -7,6 +7,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2140>2140</a></td>\n' +
            '<td> struct object</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2141>2141</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2142>2142</a></td>\n' +
            '<td>         struct list_head list;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2143>2143</a></td>\n' +
            '<td>+        unsigned int refcnt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2144>2144</a></td>\n' +
            '<td>         int id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2145>2145</a></td>\n' +
            '<td>         char name[32];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2146>2146</a></td>\n' +
            '<td>         int popularity;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2147>2147</a></td>\n' +
            '<td>@@ -17,6 +18,35 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2148>2148</a></td>\n' +
            '<td> static unsigned int cache_num = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2149>2149</a></td>\n' +
            '<td> #define MAX_CACHE_SIZE 10</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2150>2150</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2151>2151</a></td>\n' +
            '<td>+static void __object_put(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2152>2152</a></td>\n' +
            '<td>+{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2153>2153</a></td>\n' +
            '<td>+        if (--obj-&gt;refcnt == 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2154>2154</a></td>\n' +
            '<td>+                kfree(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2155>2155</a></td>\n' +
            '<td>+}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2156>2156</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2157>2157</a></td>\n' +
            '<td>+static void __object_get(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2158>2158</a></td>\n' +
            '<td>+{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2159>2159</a></td>\n' +
            '<td>+        obj-&gt;refcnt++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2160>2160</a></td>\n' +
            '<td>+}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2161>2161</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2162>2162</a></td>\n' +
            '<td>+void object_put(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2163>2163</a></td>\n' +
            '<td>+{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2164>2164</a></td>\n' +
            '<td>+        unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2165>2165</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2166>2166</a></td>\n' +
            '<td>+        spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2167>2167</a></td>\n' +
            '<td>+        __object_put(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2168>2168</a></td>\n' +
            '<td>+        spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2169>2169</a></td>\n' +
            '<td>+}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2170>2170</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2171>2171</a></td>\n' +
            '<td>+void object_get(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2172>2172</a></td>\n' +
            '<td>+{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2173>2173</a></td>\n' +
            '<td>+        unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2174>2174</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2175>2175</a></td>\n' +
            '<td>+        spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2176>2176</a></td>\n' +
            '<td>+        __object_get(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2177>2177</a></td>\n' +
            '<td>+        spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2178>2178</a></td>\n' +
            '<td>+}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2179>2179</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2180>2180</a></td>\n' +
            '<td> /* Must be holding cache_lock */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2181>2181</a></td>\n' +
            '<td> static struct object *__cache_find(int id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2182>2182</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2183>2183</a></td>\n' +
            '<td>@@ -35,6 +65,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2184>2184</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2185>2185</a></td>\n' +
            '<td>         BUG_ON(!obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2186>2186</a></td>\n' +
            '<td>         list_del(&amp;obj-&gt;list);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2187>2187</a></td>\n' +
            '<td>+        __object_put(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2188>2188</a></td>\n' +
            '<td>         cache_num--;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2189>2189</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2190>2190</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2191>2191</a></td>\n' +
            '<td>@@ -63,6 +94,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2192>2192</a></td>\n' +
            '<td>         strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2193>2193</a></td>\n' +
            '<td>         obj-&gt;id = id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2194>2194</a></td>\n' +
            '<td>         obj-&gt;popularity = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2195>2195</a></td>\n' +
            '<td>+        obj-&gt;refcnt = 1; /* The cache holds a reference */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2196>2196</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2197>2197</a></td>\n' +
            '<td>         spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2198>2198</a></td>\n' +
            '<td>         __cache_add(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2199>2199</a></td>\n' +
            '<td>@@ -79,18 +111,15 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2200>2200</a></td>\n' +
            '<td>         spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2201>2201</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2202>2202</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2203>2203</a></td>\n' +
            '<td>-int cache_find(int id, char *name)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2204>2204</a></td>\n' +
            '<td>+struct object *cache_find(int id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2205>2205</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2206>2206</a></td>\n' +
            '<td>         struct object *obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2207>2207</a></td>\n' +
            '<td>-        int ret = -ENOENT;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2208>2208</a></td>\n' +
            '<td>         unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2209>2209</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2210>2210</a></td>\n' +
            '<td>         spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2211>2211</a></td>\n' +
            '<td>         obj = __cache_find(id);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2212>2212</a></td>\n' +
            '<td>-        if (obj) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2213>2213</a></td>\n' +
            '<td>-                ret = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2214>2214</a></td>\n' +
            '<td>-                strcpy(name, obj-&gt;name);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2215>2215</a></td>\n' +
            '<td>-        }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2216>2216</a></td>\n' +
            '<td>+        if (obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2217>2217</a></td>\n' +
            '<td>+                __object_get(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2218>2218</a></td>\n' +
            '<td>         spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2219>2219</a></td>\n' +
            '<td>-        return ret;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2220>2220</a></td>\n' +
            '<td>+        return obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2221>2221</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2222>2222</a></td>\n' +
            '<td>We encapsulate the reference counting in the standard ' + "'" + 'get' + "'" + ' and ' + "'" + 'put' + "'" + ' functions. Now we can return the object itself from cache_find which has the advantage that the user can now sleep holding the object (eg. to copy_to_user to name to userspace).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2223>2223</a></td>\n' +
            '<td>The other point to note is that I said a reference should be held for every pointer to the object: thus the reference count is 1 when first inserted into the cache. In some versions the framework does not hold a reference count, but they are more complicated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2224>2224</a></td>\n' +
            '<td>Using Atomic Operations For The Reference Count</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2225>2225</a></td>\n' +
            '<td>In practice, atomic_t would usually be used for refcnt. There are a number of atomic operations defined in include/asm/atomic.h: these are guaranteed to be seen atomically from all CPUs in the system, so no lock is required. In this case, it is simpler than using spinlocks, although for anything non-trivial using spinlocks is clearer. The atomic_inc and atomic_dec_and_test are used instead of the standard increment and decrement operators, and the lock is no longer used to protect the reference count itself.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2226>2226</a></td>\n' +
            '<td>--- cache.c.refcnt  2003-12-09 15:00:35.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2227>2227</a></td>\n' +
            '<td>+++ cache.c.refcnt-atomic   2003-12-11 15:49:42.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2228>2228</a></td>\n' +
            '<td>@@ -7,7 +7,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2229>2229</a></td>\n' +
            '<td> struct object</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2230>2230</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2231>2231</a></td>\n' +
            '<td>         struct list_head list;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2232>2232</a></td>\n' +
            '<td>-        unsigned int refcnt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2233>2233</a></td>\n' +
            '<td>+        atomic_t refcnt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2234>2234</a></td>\n' +
            '<td>         int id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2235>2235</a></td>\n' +
            '<td>         char name[32];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2236>2236</a></td>\n' +
            '<td>         int popularity;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2237>2237</a></td>\n' +
            '<td>@@ -18,33 +18,15 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2238>2238</a></td>\n' +
            '<td> static unsigned int cache_num = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2239>2239</a></td>\n' +
            '<td> #define MAX_CACHE_SIZE 10</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2240>2240</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2241>2241</a></td>\n' +
            '<td>-static void __object_put(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2242>2242</a></td>\n' +
            '<td>-{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2243>2243</a></td>\n' +
            '<td>-        if (--obj-&gt;refcnt == 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2244>2244</a></td>\n' +
            '<td>-                kfree(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2245>2245</a></td>\n' +
            '<td>-}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2246>2246</a></td>\n' +
            '<td>-</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2247>2247</a></td>\n' +
            '<td>-static void __object_get(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2248>2248</a></td>\n' +
            '<td>-{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2249>2249</a></td>\n' +
            '<td>-        obj-&gt;refcnt++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2250>2250</a></td>\n' +
            '<td>-}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2251>2251</a></td>\n' +
            '<td>-</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2252>2252</a></td>\n' +
            '<td> void object_put(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2253>2253</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2254>2254</a></td>\n' +
            '<td>-        unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2255>2255</a></td>\n' +
            '<td>-</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2256>2256</a></td>\n' +
            '<td>-        spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2257>2257</a></td>\n' +
            '<td>-        __object_put(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2258>2258</a></td>\n' +
            '<td>-        spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2259>2259</a></td>\n' +
            '<td>+        if (atomic_dec_and_test(&amp;obj-&gt;refcnt))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2260>2260</a></td>\n' +
            '<td>+                kfree(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2261>2261</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2262>2262</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2263>2263</a></td>\n' +
            '<td> void object_get(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2264>2264</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2265>2265</a></td>\n' +
            '<td>-        unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2266>2266</a></td>\n' +
            '<td>-</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2267>2267</a></td>\n' +
            '<td>-        spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2268>2268</a></td>\n' +
            '<td>-        __object_get(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2269>2269</a></td>\n' +
            '<td>-        spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2270>2270</a></td>\n' +
            '<td>+        atomic_inc(&amp;obj-&gt;refcnt);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2271>2271</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2272>2272</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2273>2273</a></td>\n' +
            '<td> /* Must be holding cache_lock */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2274>2274</a></td>\n' +
            '<td>@@ -65,7 +47,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2275>2275</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2276>2276</a></td>\n' +
            '<td>         BUG_ON(!obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2277>2277</a></td>\n' +
            '<td>         list_del(&amp;obj-&gt;list);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2278>2278</a></td>\n' +
            '<td>-        __object_put(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2279>2279</a></td>\n' +
            '<td>+        object_put(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2280>2280</a></td>\n' +
            '<td>         cache_num--;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2281>2281</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2282>2282</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2283>2283</a></td>\n' +
            '<td>@@ -94,7 +76,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2284>2284</a></td>\n' +
            '<td>         strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2285>2285</a></td>\n' +
            '<td>         obj-&gt;id = id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2286>2286</a></td>\n' +
            '<td>         obj-&gt;popularity = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2287>2287</a></td>\n' +
            '<td>-        obj-&gt;refcnt = 1; /* The cache holds a reference */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2288>2288</a></td>\n' +
            '<td>+        atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2289>2289</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2290>2290</a></td>\n' +
            '<td>         spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2291>2291</a></td>\n' +
            '<td>         __cache_add(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2292>2292</a></td>\n' +
            '<td>@@ -119,7 +101,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2293>2293</a></td>\n' +
            '<td>         spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2294>2294</a></td>\n' +
            '<td>         obj = __cache_find(id);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2295>2295</a></td>\n' +
            '<td>         if (obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2296>2296</a></td>\n' +
            '<td>-                __object_get(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2297>2297</a></td>\n' +
            '<td>+                object_get(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2298>2298</a></td>\n' +
            '<td>         spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2299>2299</a></td>\n' +
            '<td>         return obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2300>2300</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2301>2301</a></td>\n' +
            '<td>Protecting The Objects Themselves</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2302>2302</a></td>\n' +
            '<td>In these examples, we assumed that the objects (except the reference counts) never changed once they are created. If we wanted to allow the name to change, there are three possibilities:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2303>2303</a></td>\n' +
            '<td>    You can make cache_lock non-static, and tell people to grab that lock before changing the name in any object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2304>2304</a></td>\n' +
            '<td>    You can provide a cache_obj_rename which grabs this lock and changes the name for the caller, and tell everyone to use that function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2305>2305</a></td>\n' +
            '<td>    You can make the cache_lock protect only the cache itself, and use another lock to protect the name.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2306>2306</a></td>\n' +
            '<td>Theoretically, you can make the locks as fine-grained as one lock for every field, for every object. In practice, the most common variants are:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2307>2307</a></td>\n' +
            '<td>    One lock which protects the infrastructure (the cache list in this example) and all the objects. This is what we have done so far.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2308>2308</a></td>\n' +
            '<td>    One lock which protects the infrastructure (including the list pointers inside the objects), and one lock inside the object which protects the rest of that object.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2309>2309</a></td>\n' +
            '<td>    Multiple locks to protect the infrastructure (eg. one lock per hash chain), possibly with a separate per-object lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2310>2310</a></td>\n' +
            '<td>Here is the "lock-per-object" implementation:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2311>2311</a></td>\n' +
            '<td>--- cache.c.refcnt-atomic   2003-12-11 15:50:54.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2312>2312</a></td>\n' +
            '<td>+++ cache.c.perobjectlock   2003-12-11 17:15:03.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2313>2313</a></td>\n' +
            '<td>@@ -6,11 +6,17 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2314>2314</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2315>2315</a></td>\n' +
            '<td> struct object</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2316>2316</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2317>2317</a></td>\n' +
            '<td>+        /* These two protected by cache_lock. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2318>2318</a></td>\n' +
            '<td>         struct list_head list;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2319>2319</a></td>\n' +
            '<td>+        int popularity;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2320>2320</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2321>2321</a></td>\n' +
            '<td>         atomic_t refcnt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2322>2322</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2323>2323</a></td>\n' +
            '<td>+        /* Doesn' + "'" + 't change once created. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2324>2324</a></td>\n' +
            '<td>         int id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2325>2325</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2326>2326</a></td>\n' +
            '<td>+        spinlock_t lock; /* Protects the name */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2327>2327</a></td>\n' +
            '<td>         char name[32];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2328>2328</a></td>\n' +
            '<td>-        int popularity;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2329>2329</a></td>\n' +
            '<td> };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2330>2330</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2331>2331</a></td>\n' +
            '<td> static DEFINE_SPINLOCK(cache_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2332>2332</a></td>\n' +
            '<td>@@ -77,6 +84,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2333>2333</a></td>\n' +
            '<td>         obj-&gt;id = id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2334>2334</a></td>\n' +
            '<td>         obj-&gt;popularity = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2335>2335</a></td>\n' +
            '<td>         atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2336>2336</a></td>\n' +
            '<td>+        spin_lock_init(&amp;obj-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2337>2337</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2338>2338</a></td>\n' +
            '<td>         spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2339>2339</a></td>\n' +
            '<td>         __cache_add(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2340>2340</a></td>\n' +
            '<td>Note that I decide that the popularity count should be protected by the cache_lock rather than the per-object lock: this is because it (like the struct list_head inside the object) is logically part of the infrastructure. This way, I don' + "'" + 't need to grab the lock of every object in __cache_add when seeking the least popular.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2341>2341</a></td>\n' +
            '<td>I also decided that the id member is unchangeable, so I don' + "'" + 't need to grab each object lock in __cache_find() to examine the id: the object lock is only used by a caller who wants to read or write the name field.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2342>2342</a></td>\n' +
            '<td>Note also that I added a comment describing what data was protected by which locks. This is extremely important, as it describes the runtime behavior of the code, and can be hard to gain from just reading. And as Alan Cox says, Lock data, not code.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2343>2343</a></td>\n' +
            '<td>Common Problems</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2344>2344</a></td>\n' +
            '<td>Deadlock: Simple and Advanced</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2345>2345</a></td>\n' +
            '<td>There is a coding bug where a piece of code tries to grab a spinlock twice: it will spin forever, waiting for the lock to be released (spinlocks, rwlocks and mutexes are not recursive in Linux). This is trivial to diagnose: not a stay-up-five-nights-talk-to-fluffy-code-bunnies kind of problem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2346>2346</a></td>\n' +
            '<td>For a slightly more complex case, imagine you have a region shared by a softirq and user context. If you use a spin_lock() call to protect it, it is possible that the user context will be interrupted by the softirq while it holds the lock, and the softirq will then spin forever trying to get the same lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2347>2347</a></td>\n' +
            '<td>Both of these are called deadlock, and as shown above, it can occur even with a single CPU (although not on UP compiles, since spinlocks vanish on kernel compiles with CONFIG_SMP=n. You' + "'" + 'll still get data corruption in the second example).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2348>2348</a></td>\n' +
            '<td>This complete lockup is easy to diagnose: on SMP boxes the watchdog timer or compiling with DEBUG_SPINLOCK set (include/linux/spinlock.h) will show this up immediately when it happens.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2349>2349</a></td>\n' +
            '<td>A more complex problem is the so-called ' + "'" + 'deadly embrace' + "'" + ', involving two or more locks. Say you have a hash table: each entry in the table is a spinlock, and a chain of hashed objects. Inside a softirq handler, you sometimes want to alter an object from one place in the hash to another: you grab the spinlock of the old hash chain and the spinlock of the new hash chain, and delete the object from the old one, and insert it in the new one.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2350>2350</a></td>\n' +
            '<td>There are two problems here. First, if your code ever tries to move the object to the same chain, it will deadlock with itself as it tries to lock it twice. Secondly, if the same softirq on another CPU is trying to move another object in the reverse direction, the following could happen:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2351>2351</a></td>\n' +
            '<td>Consequences</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2352>2352</a></td>\n' +
            '<td>CPU 1    CPU 2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2353>2353</a></td>\n' +
            '<td>Grab lock A -&gt; OK    Grab lock B -&gt; OK</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2354>2354</a></td>\n' +
            '<td>Grab lock B -&gt; spin    Grab lock A -&gt; spin</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2355>2355</a></td>\n' +
            '<td>The two CPUs will spin forever, waiting for the other to give up their lock. It will look, smell, and feel like a crash.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2356>2356</a></td>\n' +
            '<td>Preventing Deadlock</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2357>2357</a></td>\n' +
            '<td>Textbooks will tell you that if you always lock in the same order, you will never get this kind of deadlock. Practice will tell you that this approach doesn' + "'" + 't scale: when I create a new lock, I don' + "'" + 't understand enough of the kernel to figure out where in the 5000 lock hierarchy it will fit.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2358>2358</a></td>\n' +
            '<td>The best locks are encapsulated: they never get exposed in headers, and are never held around calls to non-trivial functions outside the same file. You can read through this code and see that it will never deadlock, because it never tries to grab another lock while it has that one. People using your code don' + "'" + 't even need to know you are using a lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2359>2359</a></td>\n' +
            '<td>A classic problem here is when you provide callbacks or hooks: if you call these with the lock held, you risk simple deadlock, or a deadly embrace (who knows what the callback will do?). Remember, the other programmers are out to get you, so don' + "'" + 't do this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2360>2360</a></td>\n' +
            '<td>Overzealous Prevention Of Deadlocks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2361>2361</a></td>\n' +
            '<td>Deadlocks are problematic, but not as bad as data corruption. Code which grabs a read lock, searches a list, fails to find what it wants, drops the read lock, grabs a write lock and inserts the object has a race condition.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2362>2362</a></td>\n' +
            '<td>If you don' + "'" + 't see why, please stay the fuck away from my code.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2363>2363</a></td>\n' +
            '<td>Racing Timers: A Kernel Pastime</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2364>2364</a></td>\n' +
            '<td>Timers can produce their own special problems with races. Consider a collection of objects (list, hash, etc) where each object has a timer which is due to destroy it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2365>2365</a></td>\n' +
            '<td>If you want to destroy the entire collection (say on module removal), you might do the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2366>2366</a></td>\n' +
            '<td>        /* THIS CODE BAD BAD BAD BAD: IF IT WAS ANY WORSE IT WOULD USE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2367>2367</a></td>\n' +
            '<td>           HUNGARIAN NOTATION */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2368>2368</a></td>\n' +
            '<td>        spin_lock_bh(&amp;list_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2369>2369</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2370>2370</a></td>\n' +
            '<td>        while (list) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2371>2371</a></td>\n' +
            '<td>                struct foo *next = list-&gt;next;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2372>2372</a></td>\n' +
            '<td>                del_timer(&amp;list-&gt;timer);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2373>2373</a></td>\n' +
            '<td>                kfree(list);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2374>2374</a></td>\n' +
            '<td>                list = next;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2375>2375</a></td>\n' +
            '<td>        }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2376>2376</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2377>2377</a></td>\n' +
            '<td>        spin_unlock_bh(&amp;list_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2378>2378</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2379>2379</a></td>\n' +
            '<td>Sooner or later, this will crash on SMP, because a timer can have just gone off before the spin_lock_bh(), and it will only get the lock after we spin_unlock_bh(), and then try to free the element (which has already been freed!).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2380>2380</a></td>\n' +
            '<td>This can be avoided by checking the result of del_timer(): if it returns 1, the timer has been deleted. If 0, it means (in this case) that it is currently running, so we can do:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2381>2381</a></td>\n' +
            '<td>        retry:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2382>2382</a></td>\n' +
            '<td>                spin_lock_bh(&amp;list_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2383>2383</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2384>2384</a></td>\n' +
            '<td>                while (list) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2385>2385</a></td>\n' +
            '<td>                        struct foo *next = list-&gt;next;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2386>2386</a></td>\n' +
            '<td>                        if (!del_timer(&amp;list-&gt;timer)) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2387>2387</a></td>\n' +
            '<td>                                /* Give timer a chance to delete this */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2388>2388</a></td>\n' +
            '<td>                                spin_unlock_bh(&amp;list_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2389>2389</a></td>\n' +
            '<td>                                goto retry;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2390>2390</a></td>\n' +
            '<td>                        }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2391>2391</a></td>\n' +
            '<td>                        kfree(list);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2392>2392</a></td>\n' +
            '<td>                        list = next;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2393>2393</a></td>\n' +
            '<td>                }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2394>2394</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2395>2395</a></td>\n' +
            '<td>                spin_unlock_bh(&amp;list_lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2396>2396</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2397>2397</a></td>\n' +
            '<td>Another common problem is deleting timers which restart themselves (by calling add_timer() at the end of their timer function). Because this is a fairly common case which is prone to races, you should use del_timer_sync() (include/linux/timer.h) to handle this case. It returns the number of times the timer had to be deleted before we finally stopped it from adding itself back in.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2398>2398</a></td>\n' +
            '<td>Locking Speed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2399>2399</a></td>\n' +
            '<td>There are three main things to worry about when considering speed of some code which does locking. First is concurrency: how many things are going to be waiting while someone else is holding a lock. Second is the time taken to actually acquire and release an uncontended lock. Third is using fewer, or smarter locks. I' + "'" + 'm assuming that the lock is used fairly often: otherwise, you wouldn' + "'" + 't be concerned about efficiency.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2400>2400</a></td>\n' +
            '<td>Concurrency depends on how long the lock is usually held: you should hold the lock for as long as needed, but no longer. In the cache example, we always create the object without the lock held, and then grab the lock only when we are ready to insert it in the list.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2401>2401</a></td>\n' +
            '<td>Acquisition times depend on how much damage the lock operations do to the pipeline (pipeline stalls) and how likely it is that this CPU was the last one to grab the lock (ie. is the lock cache-hot for this CPU): on a machine with more CPUs, this likelihood drops fast. Consider a 700MHz Intel Pentium III: an instruction takes about 0.7ns, an atomic increment takes about 58ns, a lock which is cache-hot on this CPU takes 160ns, and a cacheline transfer from another CPU takes an additional 170 to 360ns. (These figures from Paul McKenney' + "'" + 's Linux Journal RCU article).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2402>2402</a></td>\n' +
            '<td>These two aims conflict: holding a lock for a short time might be done by splitting locks into parts (such as in our final per-object-lock example), but this increases the number of lock acquisitions, and the results are often slower than having a single lock. This is another reason to advocate locking simplicity.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2403>2403</a></td>\n' +
            '<td>The third concern is addressed below: there are some methods to reduce the amount of locking which needs to be done.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2404>2404</a></td>\n' +
            '<td>Read/Write Lock Variants</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2405>2405</a></td>\n' +
            '<td>Both spinlocks and mutexes have read/write variants: rwlock_t and struct rw_semaphore. These divide users into two classes: the readers and the writers. If you are only reading the data, you can get a read lock, but to write to the data you need the write lock. Many people can hold a read lock, but a writer must be sole holder.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2406>2406</a></td>\n' +
            '<td>If your code divides neatly along reader/writer lines (as our cache code does), and the lock is held by readers for significant lengths of time, using these locks can help. They are slightly slower than the normal locks though, so in practice rwlock_t is not usually worthwhile.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2407>2407</a></td>\n' +
            '<td>Avoiding Locks: Read Copy Update</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2408>2408</a></td>\n' +
            '<td>There is a special method of read/write locking called Read Copy Update. Using RCU, the readers can avoid taking a lock altogether: as we expect our cache to be read more often than updated (otherwise the cache is a waste of time), it is a candidate for this optimization.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2409>2409</a></td>\n' +
            '<td>How do we get rid of read locks? Getting rid of read locks means that writers may be changing the list underneath the readers. That is actually quite simple: we can read a linked list while an element is being added if the writer adds the element very carefully. For example, adding new to a single linked list called list:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2410>2410</a></td>\n' +
            '<td>        new-&gt;next = list-&gt;next;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2411>2411</a></td>\n' +
            '<td>        wmb();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2412>2412</a></td>\n' +
            '<td>        list-&gt;next = new;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2413>2413</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2414>2414</a></td>\n' +
            '<td>The wmb() is a write memory barrier. It ensures that the first operation (setting the new element' + "'" + 's next pointer) is complete and will be seen by all CPUs, before the second operation is (putting the new element into the list). This is important, since modern compilers and modern CPUs can both reorder instructions unless told otherwise: we want a reader to either not see the new element at all, or see the new element with the next pointer correctly pointing at the rest of the list.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2415>2415</a></td>\n' +
            '<td>Fortunately, there is a function to do this for standard struct list_head lists: list_add_rcu() (include/linux/list.h).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2416>2416</a></td>\n' +
            '<td>Removing an element from the list is even simpler: we replace the pointer to the old element with a pointer to its successor, and readers will either see it, or skip over it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2417>2417</a></td>\n' +
            '<td>        list-&gt;next = old-&gt;next;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2418>2418</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2419>2419</a></td>\n' +
            '<td>There is list_del_rcu() (include/linux/list.h) which does this (the normal version poisons the old object, which we don' + "'" + 't want).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2420>2420</a></td>\n' +
            '<td>The reader must also be careful: some CPUs can look through the next pointer to start reading the contents of the next element early, but don' + "'" + 't realize that the pre-fetched contents is wrong when the next pointer changes underneath them. Once again, there is a list_for_each_entry_rcu() (include/linux/list.h) to help you. Of course, writers can just use list_for_each_entry(), since there cannot be two simultaneous writers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2421>2421</a></td>\n' +
            '<td>Our final dilemma is this: when can we actually destroy the removed element? Remember, a reader might be stepping through this element in the list right now: if we free this element and the next pointer changes, the reader will jump off into garbage and crash. We need to wait until we know that all the readers who were traversing the list when we deleted the element are finished. We use call_rcu() to register a callback which will actually destroy the object once all pre-existing readers are finished. Alternatively, synchronize_rcu() may be used to block until all pre-existing are finished.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2422>2422</a></td>\n' +
            '<td>But how does Read Copy Update know when the readers are finished? The method is this: firstly, the readers always traverse the list inside rcu_read_lock()/rcu_read_unlock() pairs: these simply disable preemption so the reader won' + "'" + 't go to sleep while reading the list.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2423>2423</a></td>\n' +
            '<td>RCU then waits until every other CPU has slept at least once: since readers cannot sleep, we know that any readers which were traversing the list during the deletion are finished, and the callback is triggered. The real Read Copy Update code is a little more optimized than this, but this is the fundamental idea.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2424>2424</a></td>\n' +
            '<td>--- cache.c.perobjectlock   2003-12-11 17:15:03.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2425>2425</a></td>\n' +
            '<td>+++ cache.c.rcupdate    2003-12-11 17:55:14.000000000 +1100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2426>2426</a></td>\n' +
            '<td>@@ -1,15 +1,18 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2427>2427</a></td>\n' +
            '<td> #include &lt;linux/list.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2428>2428</a></td>\n' +
            '<td> #include &lt;linux/slab.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2429>2429</a></td>\n' +
            '<td> #include &lt;linux/string.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2430>2430</a></td>\n' +
            '<td>+#include &lt;linux/rcupdate.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2431>2431</a></td>\n' +
            '<td> #include &lt;linux/mutex.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2432>2432</a></td>\n' +
            '<td> #include &lt;asm/errno.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2433>2433</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2434>2434</a></td>\n' +
            '<td> struct object</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2435>2435</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2436>2436</a></td>\n' +
            '<td>-        /* These two protected by cache_lock. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2437>2437</a></td>\n' +
            '<td>+        /* This is protected by RCU */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2438>2438</a></td>\n' +
            '<td>         struct list_head list;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2439>2439</a></td>\n' +
            '<td>         int popularity;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2440>2440</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2441>2441</a></td>\n' +
            '<td>+        struct rcu_head rcu;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2442>2442</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2443>2443</a></td>\n' +
            '<td>         atomic_t refcnt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2444>2444</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2445>2445</a></td>\n' +
            '<td>         /* Doesn' + "'" + 't change once created. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2446>2446</a></td>\n' +
            '<td>@@ -40,7 +43,7 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2447>2447</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2448>2448</a></td>\n' +
            '<td>         struct object *i;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2449>2449</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2450>2450</a></td>\n' +
            '<td>-        list_for_each_entry(i, &amp;cache, list) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2451>2451</a></td>\n' +
            '<td>+        list_for_each_entry_rcu(i, &amp;cache, list) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2452>2452</a></td>\n' +
            '<td>                 if (i-&gt;id == id) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2453>2453</a></td>\n' +
            '<td>                         i-&gt;popularity++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2454>2454</a></td>\n' +
            '<td>                         return i;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2455>2455</a></td>\n' +
            '<td>@@ -49,19 +52,25 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2456>2456</a></td>\n' +
            '<td>         return NULL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2457>2457</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2458>2458</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2459>2459</a></td>\n' +
            '<td>+/* Final discard done once we know no readers are looking. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2460>2460</a></td>\n' +
            '<td>+static void cache_delete_rcu(void *arg)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2461>2461</a></td>\n' +
            '<td>+{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2462>2462</a></td>\n' +
            '<td>+        object_put(arg);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2463>2463</a></td>\n' +
            '<td>+}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2464>2464</a></td>\n' +
            '<td>+</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2465>2465</a></td>\n' +
            '<td> /* Must be holding cache_lock */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2466>2466</a></td>\n' +
            '<td> static void __cache_delete(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2467>2467</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2468>2468</a></td>\n' +
            '<td>         BUG_ON(!obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2469>2469</a></td>\n' +
            '<td>-        list_del(&amp;obj-&gt;list);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2470>2470</a></td>\n' +
            '<td>-        object_put(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2471>2471</a></td>\n' +
            '<td>+        list_del_rcu(&amp;obj-&gt;list);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2472>2472</a></td>\n' +
            '<td>         cache_num--;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2473>2473</a></td>\n' +
            '<td>+        call_rcu(&amp;obj-&gt;rcu, cache_delete_rcu);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2474>2474</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2475>2475</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2476>2476</a></td>\n' +
            '<td> /* Must be holding cache_lock */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2477>2477</a></td>\n' +
            '<td> static void __cache_add(struct object *obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2478>2478</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2479>2479</a></td>\n' +
            '<td>-        list_add(&amp;obj-&gt;list, &amp;cache);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2480>2480</a></td>\n' +
            '<td>+        list_add_rcu(&amp;obj-&gt;list, &amp;cache);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2481>2481</a></td>\n' +
            '<td>         if (++cache_num &gt; MAX_CACHE_SIZE) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2482>2482</a></td>\n' +
            '<td>                 struct object *i, *outcast = NULL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2483>2483</a></td>\n' +
            '<td>                 list_for_each_entry(i, &amp;cache, list) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2484>2484</a></td>\n' +
            '<td>@@ -104,12 +114,11 @@</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2485>2485</a></td>\n' +
            '<td> struct object *cache_find(int id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2486>2486</a></td>\n' +
            '<td> {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2487>2487</a></td>\n' +
            '<td>         struct object *obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2488>2488</a></td>\n' +
            '<td>-        unsigned long flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2489>2489</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2490>2490</a></td>\n' +
            '<td>-        spin_lock_irqsave(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2491>2491</a></td>\n' +
            '<td>+        rcu_read_lock();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2492>2492</a></td>\n' +
            '<td>         obj = __cache_find(id);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2493>2493</a></td>\n' +
            '<td>         if (obj)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2494>2494</a></td>\n' +
            '<td>                 object_get(obj);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2495>2495</a></td>\n' +
            '<td>-        spin_unlock_irqrestore(&amp;cache_lock, flags);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2496>2496</a></td>\n' +
            '<td>+        rcu_read_unlock();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2497>2497</a></td>\n' +
            '<td>         return obj;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2498>2498</a></td>\n' +
            '<td> }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2499>2499</a></td>\n' +
            '<td>Note that the reader will alter the popularity member in __cache_find(), and now it doesn' + "'" + 't hold a lock. One solution would be to make it an atomic_t, but for this usage, we don' + "'" + 't really care about races: an approximate result is good enough, so I didn' + "'" + 't change it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2500>2500</a></td>\n' +
            '<td>The result is that cache_find() requires no synchronization with any other functions, so is almost as fast on SMP as it would be on UP.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2501>2501</a></td>\n' +
            '<td>There is a furthur optimization possible here: remember our original cache code, where there were no reference counts and the caller simply held the lock whenever using the object? This is still possible: if you hold the lock, no one can delete the object, so you don' + "'" + 't need to get and put the reference count.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2502>2502</a></td>\n' +
            '<td>Now, because the ' + "'" + 'read lock' + "'" + ' in RCU is simply disabling preemption, a caller which always has preemption disabled between calling cache_find() and object_put() does not need to actually get and put the reference count: we could expose __cache_find() by making it non-static, and such callers could simply call that.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2503>2503</a></td>\n' +
            '<td>The benefit here is that the reference count is not written to: the object is not altered in any way, which is much faster on SMP machines due to caching.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2504>2504</a></td>\n' +
            '<td>Per-CPU Data</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2505>2505</a></td>\n' +
            '<td>Another technique for avoiding locking which is used fairly widely is to duplicate information for each CPU. For example, if you wanted to keep a count of a common condition, you could use a spin lock and a single counter. Nice and simple.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2506>2506</a></td>\n' +
            '<td>If that was too slow (it' + "'" + 's usually not, but if you' + "'" + 've got a really big machine to test on and can show that it is), you could instead use a counter for each CPU, then none of them need an exclusive lock. See DEFINE_PER_CPU(), get_cpu_var() and put_cpu_var() (include/linux/percpu.h).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2507>2507</a></td>\n' +
            '<td>Of particular use for simple per-cpu counters is the local_t type, and the cpu_local_inc() and related functions, which are more efficient than simple code on some architectures (include/asm/local.h).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2508>2508</a></td>\n' +
            '<td>Note that there is no simple, reliable way of getting an exact value of such a counter, without introducing more locks. This is not a problem for some uses.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2509>2509</a></td>\n' +
            '<td>Data Which Mostly Used By An IRQ Handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2510>2510</a></td>\n' +
            '<td>If data is always accessed from within the same IRQ handler, you don' + "'" + 't need a lock at all: the kernel already guarantees that the irq handler will not run simultaneously on multiple CPUs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2511>2511</a></td>\n' +
            '<td>Manfred Spraul points out that you can still do this, even if the data is very occasionally accessed in user context or softirqs/tasklets. The irq handler doesn' + "'" + 't use a lock, and all other accesses are done as so:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2512>2512</a></td>\n' +
            '<td>    spin_lock(&amp;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2513>2513</a></td>\n' +
            '<td>    disable_irq(irq);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2514>2514</a></td>\n' +
            '<td>    ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2515>2515</a></td>\n' +
            '<td>    enable_irq(irq);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2516>2516</a></td>\n' +
            '<td>    spin_unlock(&amp;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2517>2517</a></td>\n' +
            '<td>The disable_irq() prevents the irq handler from running (and waits for it to finish if it' + "'" + 's currently running on other CPUs). The spinlock prevents any other accesses happening at the same time. Naturally, this is slower than just a spin_lock_irq() call, so it only makes sense if this type of access happens extremely rarely.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2518>2518</a></td>\n' +
            '<td>What Functions Are Safe To Call From Interrupts?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2519>2519</a></td>\n' +
            '<td>Many functions in the kernel sleep (ie. call schedule()) directly or indirectly: you can never call them while holding a spinlock, or with preemption disabled. This also means you need to be in user context: calling them from an interrupt is illegal.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2520>2520</a></td>\n' +
            '<td>Some Functions Which Sleep</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2521>2521</a></td>\n' +
            '<td>The most common ones are listed below, but you usually have to read the code to find out if other calls are safe. If everyone else who calls it can sleep, you probably need to be able to sleep, too. In particular, registration and deregistration functions usually expect to be called from user context, and can sleep.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2522>2522</a></td>\n' +
            '<td>    Accesses to userspace:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2523>2523</a></td>\n' +
            '<td>    copy_from_user()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2524>2524</a></td>\n' +
            '<td>    copy_to_user()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2525>2525</a></td>\n' +
            '<td>    get_user()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2526>2526</a></td>\n' +
            '<td>    put_user()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2527>2527</a></td>\n' +
            '<td>    kmalloc(GFP_KERNEL)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2528>2528</a></td>\n' +
            '<td>    mutex_lock_interruptible() and mutex_lock()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2529>2529</a></td>\n' +
            '<td>     There is a mutex_trylock() which does not sleep. Still, it must not be used inside interrupt context since its implementation is not safe for that. mutex_unlock() will also never sleep. It cannot be used in interrupt context either since a mutex must be released by the same task that acquired it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2530>2530</a></td>\n' +
            '<td>Some Functions Which Don' + "'" + 't Sleep</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2531>2531</a></td>\n' +
            '<td>Some functions are safe to call from any context, or holding almost any lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2532>2532</a></td>\n' +
            '<td>    printk()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2533>2533</a></td>\n' +
            '<td>    kfree()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2534>2534</a></td>\n' +
            '<td>    add_timer() and del_timer()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2535>2535</a></td>\n' +
            '<td>Mutex API reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2536>2536</a></td>\n' +
            '<td>!Iinclude/linux/mutex.h !Ekernel/locking/mutex.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2537>2537</a></td>\n' +
            '<td>Futex API reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2538>2538</a></td>\n' +
            '<td>!Ikernel/futex.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2539>2539</a></td>\n' +
            '<td>Further reading</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2540>2540</a></td>\n' +
            '<td>    Documentation/spinlocks.txt: Linus Torvalds' + "'" + ' spinlocking tutorial in the kernel sources.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2541>2541</a></td>\n' +
            '<td>    Unix Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2542>2542</a></td>\n' +
            '<td>     Curt Schimmel' + "'" + 's very good introduction to kernel level locking (not written for Linux, but nearly everything applies). The book is expensive, but really worth every penny to understand SMP locking. [ISBN: 0201633388]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2543>2543</a></td>\n' +
            '<td>Thanks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2544>2544</a></td>\n' +
            '<td>Thanks to Telsa Gwynne for DocBooking, neatening and adding style.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2545>2545</a></td>\n' +
            '<td>Thanks to Martin Pool, Philipp Rumpf, Stephen Rothwell, Paul Mackerras, Ruedi Aschwanden, Alan Cox, Manfred Spraul, Tim Waugh, Pete Zaitcev, James Morris, Robert Love, Paul McKenney, John Ashby for proofreading, correcting, flaming, commenting.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2546>2546</a></td>\n' +
            '<td>Thanks to the cabal for having no influence on this document.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2547>2547</a></td>\n' +
            '<td>Glossary</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2548>2548</a></td>\n' +
            '<td>preemption</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2549>2549</a></td>\n' +
            '<td>Prior to 2.5, or when CONFIG_PREEMPT is unset, processes in user context inside the kernel would not preempt each other (ie. you had that CPU until you gave it up, except for interrupts). With the addition of CONFIG_PREEMPT in 2.5.4, this changed: when in user context, higher priority tasks can "cut in": spinlocks were changed to disable preemption, even on UP.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2550>2550</a></td>\n' +
            '<td>bh</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2551>2551</a></td>\n' +
            '<td>Bottom Half: for historical reasons, functions with ' + "'" + '_bh' + "'" + ' in them often now refer to any software interrupt, e.g. spin_lock_bh() blocks any software interrupt on the current CPU. Bottom halves are deprecated, and will eventually be replaced by tasklets. Only one bottom half will be running at any time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2552>2552</a></td>\n' +
            '<td>Hardware Interrupt / Hardware IRQ</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2553>2553</a></td>\n' +
            '<td>Hardware interrupt request. in_irq() returns true in a hardware interrupt handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2554>2554</a></td>\n' +
            '<td>Interrupt Context</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2555>2555</a></td>\n' +
            '<td>Not user context: processing a hardware irq or software irq. Indicated by the in_interrupt() macro returning true.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2556>2556</a></td>\n' +
            '<td>SMP</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2557>2557</a></td>\n' +
            '<td>Symmetric Multi-Processor: kernels compiled for multiple-CPU machines. (CONFIG_SMP=y).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2558>2558</a></td>\n' +
            '<td>Software Interrupt / softirq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2559>2559</a></td>\n' +
            '<td>Software interrupt handler. in_irq() returns false; in_softirq() returns true. Tasklets and softirqs both fall into the category of ' + "'" + 'software interrupts' + "'" + '.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2560>2560</a></td>\n' +
            '<td>Strictly speaking a softirq is one of up to 32 enumerated software interrupts which can run on multiple CPUs at once. Sometimes used to refer to tasklets as well (ie. all software interrupts).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2561>2561</a></td>\n' +
            '<td>tasklet</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2562>2562</a></td>\n' +
            '<td>A dynamically-registrable software interrupt, which is guaranteed to only run on one CPU at a time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2563>2563</a></td>\n' +
            '<td>timer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2564>2564</a></td>\n' +
            '<td>A dynamically-registrable software interrupt, which is run at (or close to) a given time. When running, it is just like a tasklet (in fact, they are called from the TIMER_SOFTIRQ).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2565>2565</a></td>\n' +
            '<td>UP</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2566>2566</a></td>\n' +
            '<td>Uni-Processor: Non-SMP. (CONFIG_SMP=n).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2567>2567</a></td>\n' +
            '<td>User Context</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2568>2568</a></td>\n' +
            '<td>The kernel executing on behalf of a particular process (ie. a system call or trap) or kernel thread. You can tell which process with the current macro.) Not to be confused with userspace. Can be interrupted by software or hardware interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2569>2569</a></td>\n' +
            '<td>Userspace</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2570>2570</a></td>\n' +
            '<td>A process executing its own code outside the kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2571>2571</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2572>2572</a></td>\n' +
            '<td>The kernel has two different debugger front ends (kdb and kgdb) which interface to the debug core. It is possible to use either of the debugger front ends and dynamically transition between them if you configure the kernel properly at compile and runtime.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2573>2573</a></td>\n' +
            '<td>Kdb is simplistic shell-style interface which you can use on a system console with a keyboard or serial console. You can use it to inspect memory, registers, process lists, dmesg, and even set breakpoints to stop in a certain location. Kdb is not a source level debugger, although you can set breakpoints and execute some basic kernel run control. Kdb is mainly aimed at doing some analysis to aid in development or diagnosing kernel problems. You can access some symbols by name in kernel built-ins or in kernel modules if the code was built with CONFIG_KALLSYMS.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2574>2574</a></td>\n' +
            '<td>Kgdb is intended to be used as a source level debugger for the Linux kernel. It is used along with gdb to debug a Linux kernel. The expectation is that gdb can be used to "break in" to the kernel to inspect memory, variables and look through call stack information similar to the way an application developer would use gdb to debug an application. It is possible to place breakpoints in kernel code and perform some limited execution stepping.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2575>2575</a></td>\n' +
            '<td>Two machines are required for using kgdb. One of these machines is a development machine and the other is the target machine. The kernel to be debugged runs on the target machine. The development machine runs an instance of gdb against the vmlinux file which contains the symbols (not boot image such as bzImage, zImage, uImage...). In gdb the developer specifies the connection parameters and connects to kgdb. The type of connection a developer makes with gdb depends on the availability of kgdb I/O modules compiled as built-ins or loadable kernel modules in the test machine' + "'" + 's kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2576>2576</a></td>\n' +
            '<td>Compiling a kernel</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2577>2577</a></td>\n' +
            '<td>    In order to enable compilation of kdb, you must first enable kgdb.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2578>2578</a></td>\n' +
            '<td>    The kgdb test compile options are described in the kgdb test suite chapter.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2579>2579</a></td>\n' +
            '<td>Kernel config options for kgdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2580>2580</a></td>\n' +
            '<td>To enable CONFIG_KGDB you should look under "Kernel debugging" and select "KGDB: kernel debugger".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2581>2581</a></td>\n' +
            '<td>While it is not a hard requirement that you have symbols in your vmlinux file, gdb tends not to be very useful without the symbolic data, so you will want to turn on CONFIG_DEBUG_INFO which is called "Compile the kernel with debug info" in the config menu.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2582>2582</a></td>\n' +
            '<td>It is advised, but not required that you turn on the CONFIG_FRAME_POINTER kernel option which is called "Compile the kernel with frame pointers" in the config menu. This option inserts code to into the compiled executable which saves the frame information in registers or on the stack at different points which allows a debugger such as gdb to more accurately construct stack back traces while debugging the kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2583>2583</a></td>\n' +
            '<td>If the architecture that you are using supports the kernel option CONFIG_DEBUG_RODATA, you should consider turning it off. This option will prevent the use of software breakpoints because it marks certain regions of the kernel' + "'" + 's memory space as read-only. If kgdb supports it for the architecture you are using, you can use hardware breakpoints if you desire to run with the CONFIG_DEBUG_RODATA option turned on, else you need to turn off this option.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2584>2584</a></td>\n' +
            '<td>Next you should choose one of more I/O drivers to interconnect debugging host and debugged target. Early boot debugging requires a KGDB I/O driver that supports early debugging and the driver must be built into the kernel directly. Kgdb I/O driver configuration takes place via kernel or module parameters which you can learn more about in the in the section that describes the parameter "kgdboc".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2585>2585</a></td>\n' +
            '<td>Here is an example set of .config symbols to enable or disable for kgdb:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2586>2586</a></td>\n' +
            '<td>    # CONFIG_DEBUG_RODATA is not set</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2587>2587</a></td>\n' +
            '<td>    CONFIG_FRAME_POINTER=y</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2588>2588</a></td>\n' +
            '<td>    CONFIG_KGDB=y</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2589>2589</a></td>\n' +
            '<td>    CONFIG_KGDB_SERIAL_CONSOLE=y</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2590>2590</a></td>\n' +
            '<td>Kernel config options for kdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2591>2591</a></td>\n' +
            '<td>Kdb is quite a bit more complex than the simple gdbstub sitting on top of the kernel' + "'" + 's debug core. Kdb must implement a shell, and also adds some helper functions in other parts of the kernel, responsible for printing out interesting data such as what you would see if you ran "lsmod", or "ps". In order to build kdb into the kernel you follow the same steps as you would for kgdb.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2592>2592</a></td>\n' +
            '<td>The main config option for kdb is CONFIG_KGDB_KDB which is called "KGDB_KDB: include kdb frontend for kgdb" in the config menu. In theory you would have already also selected an I/O driver such as the CONFIG_KGDB_SERIAL_CONSOLE interface if you plan on using kdb on a serial port, when you were configuring kgdb.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2593>2593</a></td>\n' +
            '<td>If you want to use a PS/2-style keyboard with kdb, you would select CONFIG_KDB_KEYBOARD which is called "KGDB_KDB: keyboard as input device" in the config menu. The CONFIG_KDB_KEYBOARD option is not used for anything in the gdb interface to kgdb. The CONFIG_KDB_KEYBOARD option only works with kdb.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2594>2594</a></td>\n' +
            '<td>Here is an example set of .config symbols to enable/disable kdb:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2595>2595</a></td>\n' +
            '<td>    # CONFIG_DEBUG_RODATA is not set</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2596>2596</a></td>\n' +
            '<td>    CONFIG_FRAME_POINTER=y</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2597>2597</a></td>\n' +
            '<td>    CONFIG_KGDB=y</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2598>2598</a></td>\n' +
            '<td>    CONFIG_KGDB_SERIAL_CONSOLE=y</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2599>2599</a></td>\n' +
            '<td>    CONFIG_KGDB_KDB=y</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2600>2600</a></td>\n' +
            '<td>    CONFIG_KDB_KEYBOARD=y</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2601>2601</a></td>\n' +
            '<td>Kernel Debugger Boot Arguments</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2602>2602</a></td>\n' +
            '<td>This section describes the various runtime kernel parameters that affect the configuration of the kernel debugger. The following chapter covers using kdb and kgdb as well as provides some examples of the configuration parameters.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2603>2603</a></td>\n' +
            '<td>Kernel parameter: kgdboc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2604>2604</a></td>\n' +
            '<td>The kgdboc driver was originally an abbreviation meant to stand for "kgdb over console". Today it is the primary mechanism to configure how to communicate from gdb to kgdb as well as the devices you want to use to interact with the kdb shell.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2605>2605</a></td>\n' +
            '<td>For kgdb/gdb, kgdboc is designed to work with a single serial port. It is intended to cover the circumstance where you want to use a serial console as your primary console as well as using it to perform kernel debugging. It is also possible to use kgdb on a serial port which is not designated as a system console. Kgdboc may be configured as a kernel built-in or a kernel loadable module. You can only make use of kgdbwait and early debugging if you build kgdboc into the kernel as a built-in.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2606>2606</a></td>\n' +
            '<td>Optionally you can elect to activate kms (Kernel Mode Setting) integration. When you use kms with kgdboc and you have a video driver that has atomic mode setting hooks, it is possible to enter the debugger on the graphics console. When the kernel execution is resumed, the previous graphics mode will be restored. This integration can serve as a useful tool to aid in diagnosing crashes or doing analysis of memory with kdb while allowing the full graphics console applications to run.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2607>2607</a></td>\n' +
            '<td>kgdboc arguments</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2608>2608</a></td>\n' +
            '<td>Usage: kgdboc=[kms][[,]kbd][[,]serial_device][,baud]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2609>2609</a></td>\n' +
            '<td>The order listed above must be observed if you use any of the optional configurations together.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2610>2610</a></td>\n' +
            '<td>Abbreviations:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2611>2611</a></td>\n' +
            '<td>    kms = Kernel Mode Setting</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2612>2612</a></td>\n' +
            '<td>    kbd = Keyboard</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2613>2613</a></td>\n' +
            '<td>You can configure kgdboc to use the keyboard, and or a serial device depending on if you are using kdb and or kgdb, in one of the following scenarios. The order listed above must be observed if you use any of the optional configurations together. Using kms + only gdb is generally not a useful combination.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2614>2614</a></td>\n' +
            '<td>Using loadable module or built-in</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2615>2615</a></td>\n' +
            '<td>1.    As a kernel built-in:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2616>2616</a></td>\n' +
            '<td>     Use the kernel boot argument: kgdboc=&lt;tty-device&gt;,[baud]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2617>2617</a></td>\n' +
            '<td>2.    As a kernel loadable module:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2618>2618</a></td>\n' +
            '<td>     Use the command: modprobe kgdboc kgdboc=&lt;tty-device&gt;,[baud]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2619>2619</a></td>\n' +
            '<td>     Here are two examples of how you might format the kgdboc string. The first is for an x86 target using the first serial port. The second example is for the ARM Versatile AB using the second serial port.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2620>2620</a></td>\n' +
            '<td>1.    kgdboc=ttyS0,115200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2621>2621</a></td>\n' +
            '<td>2.    kgdboc=ttyAMA1,115200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2622>2622</a></td>\n' +
            '<td>Configure kgdboc at runtime with sysfs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2623>2623</a></td>\n' +
            '<td>At run time you can enable or disable kgdboc by echoing a parameters into the sysfs. Here are two examples:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2624>2624</a></td>\n' +
            '<td>1.    Enable kgdboc on ttyS0</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2625>2625</a></td>\n' +
            '<td>     echo ttyS0 &gt; /sys/module/kgdboc/parameters/kgdboc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2626>2626</a></td>\n' +
            '<td>2.    Disable kgdboc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2627>2627</a></td>\n' +
            '<td>     echo "" &gt; /sys/module/kgdboc/parameters/kgdboc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2628>2628</a></td>\n' +
            '<td>NOTE: You do not need to specify the baud if you are configuring the console on tty which is already configured or open.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2629>2629</a></td>\n' +
            '<td>More examples</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2630>2630</a></td>\n' +
            '<td>You can configure kgdboc to use the keyboard, and or a serial device depending on if you are using kdb and or kgdb, in one of the following scenarios.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2631>2631</a></td>\n' +
            '<td>You can configure kgdboc to use the keyboard, and or a serial device depending on if you are using kdb and or kgdb, in one of the following scenarios.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2632>2632</a></td>\n' +
            '<td>1.    kdb and kgdb over only a serial port</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2633>2633</a></td>\n' +
            '<td>     kgdboc=&lt;serial_device&gt;[,baud]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2634>2634</a></td>\n' +
            '<td>     Example: kgdboc=ttyS0,115200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2635>2635</a></td>\n' +
            '<td>2.    kdb and kgdb with keyboard and a serial port</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2636>2636</a></td>\n' +
            '<td>     kgdboc=kbd,&lt;serial_device&gt;[,baud]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2637>2637</a></td>\n' +
            '<td>     Example: kgdboc=kbd,ttyS0,115200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2638>2638</a></td>\n' +
            '<td>3.    kdb with a keyboard</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2639>2639</a></td>\n' +
            '<td>     kgdboc=kbd</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2640>2640</a></td>\n' +
            '<td>4.    kdb with kernel mode setting</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2641>2641</a></td>\n' +
            '<td>     kgdboc=kms,kbd</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2642>2642</a></td>\n' +
            '<td>5.    kdb with kernel mode setting and kgdb over a serial port</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2643>2643</a></td>\n' +
            '<td>     kgdboc=kms,kbd,ttyS0,115200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2644>2644</a></td>\n' +
            '<td>NOTE: Kgdboc does not support interrupting the target via the gdb remote protocol. You must manually send a sysrq-g unless you have a proxy that splits console output to a terminal program. A console proxy has a separate TCP port for the debugger and a separate TCP port for the "human" console. The proxy can take care of sending the sysrq-g for you.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2645>2645</a></td>\n' +
            '<td>When using kgdboc with no debugger proxy, you can end up connecting the debugger at one of two entry points. If an exception occurs after you have loaded kgdboc, a message should print on the console stating it is waiting for the debugger. In this case you disconnect your terminal program and then connect the debugger in its place. If you want to interrupt the target system and forcibly enter a debug session you have to issue a Sysrq sequence and then type the letter g. Then you disconnect the terminal session and connect gdb. Your options if you don' + "'" + 't like this are to hack gdb to send the sysrq-g for you as well as on the initial connect, or to use a debugger proxy that allows an unmodified gdb to do the debugging.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2646>2646</a></td>\n' +
            '<td>Kernel parameter: kgdbwait</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2647>2647</a></td>\n' +
            '<td>The Kernel command line option kgdbwait makes kgdb wait for a debugger connection during booting of a kernel. You can only use this option you compiled a kgdb I/O driver into the kernel and you specified the I/O driver configuration as a kernel command line option. The kgdbwait parameter should always follow the configuration parameter for the kgdb I/O driver in the kernel command line else the I/O driver will not be configured prior to asking the kernel to use it to wait.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2648>2648</a></td>\n' +
            '<td>The kernel will stop and wait as early as the I/O driver and architecture allows when you use this option. If you build the kgdb I/O driver as a loadable kernel module kgdbwait will not do anything.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2649>2649</a></td>\n' +
            '<td>Kernel parameter: kgdbcon</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2650>2650</a></td>\n' +
            '<td>The kgdbcon feature allows you to see printk() messages inside gdb while gdb is connected to the kernel. Kdb does not make use of the kgdbcon feature.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2651>2651</a></td>\n' +
            '<td>Kgdb supports using the gdb serial protocol to send console messages to the debugger when the debugger is connected and running. There are two ways to activate this feature.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2652>2652</a></td>\n' +
            '<td>1.    Activate with the kernel command line option:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2653>2653</a></td>\n' +
            '<td>     kgdbcon</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2654>2654</a></td>\n' +
            '<td>2.    Use sysfs before configuring an I/O driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2655>2655</a></td>\n' +
            '<td>     echo 1 &gt; /sys/module/kgdb/parameters/kgdb_use_con</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2656>2656</a></td>\n' +
            '<td>     NOTE: If you do this after you configure the kgdb I/O driver, the setting will not take effect until the next point the I/O is reconfigured.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2657>2657</a></td>\n' +
            '<td>IMPORTANT NOTE: You cannot use kgdboc + kgdbcon on a tty that is an active system console. An example incorrect usage is console=ttyS0,115200 kgdboc=ttyS0 kgdbcon</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2658>2658</a></td>\n' +
            '<td>It is possible to use this option with kgdboc on a tty that is not a system console.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2659>2659</a></td>\n' +
            '<td>Run time parameter: kgdbreboot</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2660>2660</a></td>\n' +
            '<td>The kgdbreboot feature allows you to change how the debugger deals with the reboot notification. You have 3 choices for the behavior. The default behavior is always set to 0.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2661>2661</a></td>\n' +
            '<td>1.    echo -1 &gt; /sys/module/debug_core/parameters/kgdbreboot</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2662>2662</a></td>\n' +
            '<td>     Ignore the reboot notification entirely.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2663>2663</a></td>\n' +
            '<td>2.    echo 0 &gt; /sys/module/debug_core/parameters/kgdbreboot</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2664>2664</a></td>\n' +
            '<td>     Send the detach message to any attached debugger client.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2665>2665</a></td>\n' +
            '<td>3.    echo 1 &gt; /sys/module/debug_core/parameters/kgdbreboot</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2666>2666</a></td>\n' +
            '<td>     Enter the debugger on reboot notify.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2667>2667</a></td>\n' +
            '<td>Using kdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2668>2668</a></td>\n' +
            '<td>Quick start for kdb on a serial port</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2669>2669</a></td>\n' +
            '<td>This is a quick example of how to use kdb.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2670>2670</a></td>\n' +
            '<td>1.    Boot kernel with arguments:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2671>2671</a></td>\n' +
            '<td>    console=ttyS0,115200 kgdboc=ttyS0,115200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2672>2672</a></td>\n' +
            '<td>     OR</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2673>2673</a></td>\n' +
            '<td>     Configure kgdboc after the kernel booted; assuming you are using a serial port console:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2674>2674</a></td>\n' +
            '<td>    echo ttyS0 &gt; /sys/module/kgdboc/parameters/kgdboc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2675>2675</a></td>\n' +
            '<td>2.    Enter the kernel debugger manually or by waiting for an oops or fault. There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g, which means you must have enabled CONFIG_MAGIC_SYSRQ=y in your kernel config.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2676>2676</a></td>\n' +
            '<td>    When logged in as root or with a super user session you can run:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2677>2677</a></td>\n' +
            '<td>     echo g &gt; /proc/sysrq-trigger</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2678>2678</a></td>\n' +
            '<td>    Example using minicom 2.2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2679>2679</a></td>\n' +
            '<td>     Press: Control-a</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2680>2680</a></td>\n' +
            '<td>     Press: f</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2681>2681</a></td>\n' +
            '<td>     Press: g</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2682>2682</a></td>\n' +
            '<td>    When you have telneted to a terminal server that supports sending a remote break</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2683>2683</a></td>\n' +
            '<td>     Press: Control-]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2684>2684</a></td>\n' +
            '<td>     Type in:send break</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2685>2685</a></td>\n' +
            '<td>     Press: Enter</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2686>2686</a></td>\n' +
            '<td>     Press: g</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2687>2687</a></td>\n' +
            '<td>3.    From the kdb prompt you can run the "help" command to see a complete list of the commands that are available.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2688>2688</a></td>\n' +
            '<td>     Some useful commands in kdb include:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2689>2689</a></td>\n' +
            '<td>    lsmod -- Shows where kernel modules are loaded</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2690>2690</a></td>\n' +
            '<td>    ps -- Displays only the active processes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2691>2691</a></td>\n' +
            '<td>    ps A -- Shows all the processes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2692>2692</a></td>\n' +
            '<td>    summary -- Shows kernel version info and memory usage</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2693>2693</a></td>\n' +
            '<td>    bt -- Get a backtrace of the current process using dump_stack()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2694>2694</a></td>\n' +
            '<td>    dmesg -- View the kernel syslog buffer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2695>2695</a></td>\n' +
            '<td>    go -- Continue the system</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2696>2696</a></td>\n' +
            '<td>4.    When you are done using kdb you need to consider rebooting the system or using the "go" command to resuming normal kernel execution. If you have paused the kernel for a lengthy period of time, applications that rely on timely networking or anything to do with real wall clock time could be adversely affected, so you should take this into consideration when using the kernel debugger.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2697>2697</a></td>\n' +
            '<td>Quick start for kdb using a keyboard connected console</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2698>2698</a></td>\n' +
            '<td>This is a quick example of how to use kdb with a keyboard.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2699>2699</a></td>\n' +
            '<td>1.    Boot kernel with arguments:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2700>2700</a></td>\n' +
            '<td>    kgdboc=kbd</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2701>2701</a></td>\n' +
            '<td>     OR</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2702>2702</a></td>\n' +
            '<td>     Configure kgdboc after the kernel booted:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2703>2703</a></td>\n' +
            '<td>    echo kbd &gt; /sys/module/kgdboc/parameters/kgdboc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2704>2704</a></td>\n' +
            '<td>2.    Enter the kernel debugger manually or by waiting for an oops or fault. There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g, which means you must have enabled CONFIG_MAGIC_SYSRQ=y in your kernel config.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2705>2705</a></td>\n' +
            '<td>    When logged in as root or with a super user session you can run:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2706>2706</a></td>\n' +
            '<td>     echo g &gt; /proc/sysrq-trigger</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2707>2707</a></td>\n' +
            '<td>    Example using a laptop keyboard</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2708>2708</a></td>\n' +
            '<td>     Press and hold down: Alt</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2709>2709</a></td>\n' +
            '<td>     Press and hold down: Fn</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2710>2710</a></td>\n' +
            '<td>     Press and release the key with the label: SysRq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2711>2711</a></td>\n' +
            '<td>     Release: Fn</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2712>2712</a></td>\n' +
            '<td>     Press and release: g</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2713>2713</a></td>\n' +
            '<td>     Release: Alt</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2714>2714</a></td>\n' +
            '<td>    Example using a PS/2 101-key keyboard</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2715>2715</a></td>\n' +
            '<td>     Press and hold down: Alt</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2716>2716</a></td>\n' +
            '<td>     Press and release the key with the label: SysRq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2717>2717</a></td>\n' +
            '<td>     Press and release: g</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2718>2718</a></td>\n' +
            '<td>     Release: Alt</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2719>2719</a></td>\n' +
            '<td>3.    Now type in a kdb command such as "help", "dmesg", "bt" or "go" to continue kernel execution.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2720>2720</a></td>\n' +
            '<td>Using kgdb / gdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2721>2721</a></td>\n' +
            '<td>In order to use kgdb you must activate it by passing configuration information to one of the kgdb I/O drivers. If you do not pass any configuration information kgdb will not do anything at all. Kgdb will only actively hook up to the kernel trap hooks if a kgdb I/O driver is loaded and configured. If you unconfigure a kgdb I/O driver, kgdb will unregister all the kernel hook points.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2722>2722</a></td>\n' +
            '<td>All kgdb I/O drivers can be reconfigured at run time, if CONFIG_SYSFS and CONFIG_MODULES are enabled, by echo' + "'" + 'ing a new config string to /sys/module/&lt;driver&gt;/parameter/&lt;option&gt;. The driver can be unconfigured by passing an empty string. You cannot change the configuration while the debugger is attached. Make sure to detach the debugger with the detach command prior to trying to unconfigure a kgdb I/O driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2723>2723</a></td>\n' +
            '<td>Connecting with gdb to a serial port</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2724>2724</a></td>\n' +
            '<td>1.    Configure kgdboc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2725>2725</a></td>\n' +
            '<td>     Boot kernel with arguments:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2726>2726</a></td>\n' +
            '<td>    kgdboc=ttyS0,115200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2727>2727</a></td>\n' +
            '<td>     OR</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2728>2728</a></td>\n' +
            '<td>     Configure kgdboc after the kernel booted:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2729>2729</a></td>\n' +
            '<td>    echo ttyS0 &gt; /sys/module/kgdboc/parameters/kgdboc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2730>2730</a></td>\n' +
            '<td>2.    Stop kernel execution (break into the debugger)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2731>2731</a></td>\n' +
            '<td>     In order to connect to gdb via kgdboc, the kernel must first be stopped. There are several ways to stop the kernel which include using kgdbwait as a boot argument, via a sysrq-g, or running the kernel until it takes an exception where it waits for the debugger to attach.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2732>2732</a></td>\n' +
            '<td>    When logged in as root or with a super user session you can run:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2733>2733</a></td>\n' +
            '<td>     echo g &gt; /proc/sysrq-trigger</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2734>2734</a></td>\n' +
            '<td>    Example using minicom 2.2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2735>2735</a></td>\n' +
            '<td>     Press: Control-a</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2736>2736</a></td>\n' +
            '<td>     Press: f</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2737>2737</a></td>\n' +
            '<td>     Press: g</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2738>2738</a></td>\n' +
            '<td>    When you have telneted to a terminal server that supports sending a remote break</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2739>2739</a></td>\n' +
            '<td>     Press: Control-]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2740>2740</a></td>\n' +
            '<td>     Type in:send break</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2741>2741</a></td>\n' +
            '<td>     Press: Enter</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2742>2742</a></td>\n' +
            '<td>     Press: g</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2743>2743</a></td>\n' +
            '<td>3.    Connect from from gdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2744>2744</a></td>\n' +
            '<td>     Example (using a directly connected port):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2745>2745</a></td>\n' +
            '<td>         % gdb ./vmlinux</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2746>2746</a></td>\n' +
            '<td>    (gdb) set remotebaud 115200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2747>2747</a></td>\n' +
            '<td>    (gdb) target remote /dev/ttyS0</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2748>2748</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2749>2749</a></td>\n' +
            '<td>     Example (kgdb to a terminal server on TCP port 2012):</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2750>2750</a></td>\n' +
            '<td>         % gdb ./vmlinux</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2751>2751</a></td>\n' +
            '<td>    (gdb) target remote 192.168.2.2:2012</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2752>2752</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2753>2753</a></td>\n' +
            '<td>     Once connected, you can debug a kernel the way you would debug an application program.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2754>2754</a></td>\n' +
            '<td>     If you are having problems connecting or something is going seriously wrong while debugging, it will most often be the case that you want to enable gdb to be verbose about its target communications. You do this prior to issuing the target</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2755>2755</a></td>\n' +
            '<td>    remote command by typing in: set debug remote 1</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2756>2756</a></td>\n' +
            '<td>Remember if you continue in gdb, and need to "break in" again, you need to issue an other sysrq-g. It is easy to create a simple entry point by putting a breakpoint at sys_sync and then you can run "sync" from a shell or script to break into the debugger.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2757>2757</a></td>\n' +
            '<td>kgdb and kdb interoperability</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2758>2758</a></td>\n' +
            '<td>It is possible to transition between kdb and kgdb dynamically. The debug core will remember which you used the last time and automatically start in the same mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2759>2759</a></td>\n' +
            '<td>Switching between kdb and kgdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2760>2760</a></td>\n' +
            '<td>Switching from kgdb to kdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2761>2761</a></td>\n' +
            '<td>There are two ways to switch from kgdb to kdb: you can use gdb to issue a maintenance packet, or you can blindly type the command $3#33. Whenever kernel debugger stops in kgdb mode it will print the message KGDB or $3#33 for KDB. It is important to note that you have to type the sequence correctly in one pass. You cannot type a backspace or delete because kgdb will interpret that as part of the debug stream.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2762>2762</a></td>\n' +
            '<td>1.    Change from kgdb to kdb by blindly typing:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2763>2763</a></td>\n' +
            '<td>     $3#33</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2764>2764</a></td>\n' +
            '<td>2.    Change from kgdb to kdb with gdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2765>2765</a></td>\n' +
            '<td>     maintenance packet 3</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2766>2766</a></td>\n' +
            '<td>     NOTE: Now you must kill gdb. Typically you press control-z and issue the command: kill -9 %</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2767>2767</a></td>\n' +
            '<td>Change from kdb to kgdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2768>2768</a></td>\n' +
            '<td>There are two ways you can change from kdb to kgdb. You can manually enter kgdb mode by issuing the kgdb command from the kdb shell prompt, or you can connect gdb while the kdb shell prompt is active. The kdb shell looks for the typical first commands that gdb would issue with the gdb remote protocol and if it sees one of those commands it automatically changes into kgdb mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2769>2769</a></td>\n' +
            '<td>1.    From kdb issue the command:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2770>2770</a></td>\n' +
            '<td>     kgdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2771>2771</a></td>\n' +
            '<td>     Now disconnect your terminal program and connect gdb in its place</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2772>2772</a></td>\n' +
            '<td>2.    At the kdb prompt, disconnect the terminal program and connect gdb in its place.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2773>2773</a></td>\n' +
            '<td>Running kdb commands from gdb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2774>2774</a></td>\n' +
            '<td>It is possible to run a limited set of kdb commands from gdb, using the gdb monitor command. You don' + "'" + 't want to execute any of the run control or breakpoint operations, because it can disrupt the state of the kernel debugger. You should be using gdb for breakpoints and run control operations if you have gdb connected. The more useful commands to run are things like lsmod, dmesg, ps or possibly some of the memory information commands. To see all the kdb commands you can run monitor help.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2775>2775</a></td>\n' +
            '<td>Example:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2776>2776</a></td>\n' +
            '<td>(gdb) monitor ps</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2777>2777</a></td>\n' +
            '<td>1 idle process (state I) and</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2778>2778</a></td>\n' +
            '<td>27 sleeping system daemon (state M) processes suppressed,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2779>2779</a></td>\n' +
            '<td>use ' + "'" + 'ps A' + "'" + ' to see all.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2780>2780</a></td>\n' +
            '<td>Task Addr       Pid   Parent [*] cpu State Thread     Command</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2781>2781</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2782>2782</a></td>\n' +
            '<td>0xc78291d0        1        0  0    0   S  0xc7829404  init</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2783>2783</a></td>\n' +
            '<td>0xc7954150      942        1  0    0   S  0xc7954384  dropbear</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2784>2784</a></td>\n' +
            '<td>0xc78789c0      944        1  0    0   S  0xc7878bf4  sh</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2785>2785</a></td>\n' +
            '<td>(gdb)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2786>2786</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2787>2787</a></td>\n' +
            '<td>kgdb Test Suite</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2788>2788</a></td>\n' +
            '<td>When kgdb is enabled in the kernel config you can also elect to enable the config parameter KGDB_TESTS. Turning this on will enable a special kgdb I/O module which is designed to test the kgdb internal functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2789>2789</a></td>\n' +
            '<td>The kgdb tests are mainly intended for developers to test the kgdb internals as well as a tool for developing a new kgdb architecture specific implementation. These tests are not really for end users of the Linux kernel. The primary source of documentation would be to look in the drivers/misc/kgdbts.c file.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2790>2790</a></td>\n' +
            '<td>The kgdb test suite can also be configured at compile time to run the core set of tests by setting the kernel config parameter KGDB_TESTS_ON_BOOT. This particular option is aimed at automated regression testing and does not require modifying the kernel boot config arguments. If this is turned on, the kgdb test suite can be disabled by specifying "kgdbts=" as a kernel boot argument.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2791>2791</a></td>\n' +
            '<td>Kernel Debugger Internals</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2792>2792</a></td>\n' +
            '<td>Architecture Specifics</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2793>2793</a></td>\n' +
            '<td>The kernel debugger is organized into a number of components:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2794>2794</a></td>\n' +
            '<td>1.    The debug core</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2795>2795</a></td>\n' +
            '<td>     The debug core is found in kernel/debugger/debug_core.c. It contains:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2796>2796</a></td>\n' +
            '<td>    A generic OS exception handler which includes sync' + "'" + 'ing the processors into a stopped state on an multi-CPU system.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2797>2797</a></td>\n' +
            '<td>    The API to talk to the kgdb I/O drivers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2798>2798</a></td>\n' +
            '<td>    The API to make calls to the arch-specific kgdb implementation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2799>2799</a></td>\n' +
            '<td>    The logic to perform safe memory reads and writes to memory while using the debugger</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2800>2800</a></td>\n' +
            '<td>    A full implementation for software breakpoints unless overridden by the arch</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2801>2801</a></td>\n' +
            '<td>    The API to invoke either the kdb or kgdb frontend to the debug core.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2802>2802</a></td>\n' +
            '<td>    The structures and callback API for atomic kernel mode setting.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2803>2803</a></td>\n' +
            '<td>     NOTE: kgdboc is where the kms callbacks are invoked.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2804>2804</a></td>\n' +
            '<td>2.    kgdb arch-specific implementation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2805>2805</a></td>\n' +
            '<td>     This implementation is generally found in arch/*/kernel/kgdb.c. As an example, arch/x86/kernel/kgdb.c contains the specifics to implement HW breakpoint as well as the initialization to dynamically register and unregister for the trap handlers on this architecture. The arch-specific portion implements:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2806>2806</a></td>\n' +
            '<td>    contains an arch-specific trap catcher which invokes kgdb_handle_exception() to start kgdb about doing its work</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2807>2807</a></td>\n' +
            '<td>    translation to and from gdb specific packet format to pt_regs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2808>2808</a></td>\n' +
            '<td>    Registration and unregistration of architecture specific trap hooks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2809>2809</a></td>\n' +
            '<td>    Any special exception handling and cleanup</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2810>2810</a></td>\n' +
            '<td>    NMI exception handling and cleanup</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2811>2811</a></td>\n' +
            '<td>    (optional)HW breakpoints</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2812>2812</a></td>\n' +
            '<td>3.    gdbstub frontend (aka kgdb)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2813>2813</a></td>\n' +
            '<td>     The gdbstub is located in kernel/debug/gdbstub.c. It contains:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2814>2814</a></td>\n' +
            '<td>    All the logic to implement the gdb serial protocol</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2815>2815</a></td>\n' +
            '<td>4.    kdb frontend</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2816>2816</a></td>\n' +
            '<td>     The kdb debugger shell is broken down into a number of components. The kdb core is located in kernel/debug/kdb. There are a number of helper functions in some of the other kernel components to make it possible for kdb to examine and report information about the kernel without taking locks that could cause a kernel deadlock. The kdb core contains implements the following functionality.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2817>2817</a></td>\n' +
            '<td>    A simple shell</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2818>2818</a></td>\n' +
            '<td>    The kdb core command set</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2819>2819</a></td>\n' +
            '<td>    A registration API to register additional kdb shell commands.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2820>2820</a></td>\n' +
            '<td>    A good example of a self-contained kdb module is the "ftdump" command for dumping the ftrace buffer. See: kernel/trace/trace_kdb.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2821>2821</a></td>\n' +
            '<td>    For an example of how to dynamically register a new kdb command you can build the kdb_hello.ko kernel module from samples/kdb/kdb_hello.c. To build this example you can set CONFIG_SAMPLES=y and CONFIG_SAMPLE_KDB=m in your kernel config. Later run "modprobe kdb_hello" and the next time you enter the kdb shell, you can run the "hello" command.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2822>2822</a></td>\n' +
            '<td>    The implementation for kdb_printf() which emits messages directly to I/O drivers, bypassing the kernel log.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2823>2823</a></td>\n' +
            '<td>    SW / HW breakpoint management for the kdb shell</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2824>2824</a></td>\n' +
            '<td>5.    kgdb I/O driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2825>2825</a></td>\n' +
            '<td>     Each kgdb I/O driver has to provide an implementation for the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2826>2826</a></td>\n' +
            '<td>    configuration via built-in or module</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2827>2827</a></td>\n' +
            '<td>    dynamic configuration and kgdb hook registration calls</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2828>2828</a></td>\n' +
            '<td>    read and write character interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2829>2829</a></td>\n' +
            '<td>    A cleanup handler for unconfiguring from the kgdb core</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2830>2830</a></td>\n' +
            '<td>    (optional) Early debug methodology</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2831>2831</a></td>\n' +
            '<td>     Any given kgdb I/O driver has to operate very closely with the hardware and must do it in such a way that does not enable interrupts or change other parts of the system context without completely restoring them. The kgdb core will repeatedly "poll" a kgdb I/O driver for characters when it needs input. The I/O driver is expected to return immediately if there is no data available. Doing so allows for the future possibility to touch watch dog hardware in such a way as to have a target system not reset when these are enabled.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2832>2832</a></td>\n' +
            '<td>If you are intent on adding kgdb architecture specific support for a new architecture, the architecture should define HAVE_ARCH_KGDB in the architecture specific Kconfig file. This will enable kgdb for the architecture, and at that point you must create an architecture specific kgdb implementation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2833>2833</a></td>\n' +
            '<td>There are a few flags which must be set on every architecture in their &lt;asm/kgdb.h&gt; file. These are:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2834>2834</a></td>\n' +
            '<td>    NUMREGBYTES: The size in bytes of all of the registers, so that we can ensure they will all fit into a packet.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2835>2835</a></td>\n' +
            '<td>     BUFMAX: The size in bytes of the buffer GDB will read into. This must be larger than NUMREGBYTES.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2836>2836</a></td>\n' +
            '<td>     CACHE_FLUSH_IS_SAFE: Set to 1 if it is always safe to call flush_cache_range or flush_icache_range. On some architectures, these functions may not be safe to call on SMP since we keep other CPUs in a holding pattern.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2837>2837</a></td>\n' +
            '<td>There are also the following functions for the common backend, found in kernel/kgdb.c, that must be supplied by the architecture-specific backend unless marked as (optional), in which case a default function maybe used if the architecture does not need to provide a specific implementation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2838>2838</a></td>\n' +
            '<td>!Iinclude/linux/kgdb.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2839>2839</a></td>\n' +
            '<td>kgdboc internals</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2840>2840</a></td>\n' +
            '<td>kgdboc and uarts</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2841>2841</a></td>\n' +
            '<td>The kgdboc driver is actually a very thin driver that relies on the underlying low level to the hardware driver having "polling hooks" which the to which the tty driver is attached. In the initial implementation of kgdboc it the serial_core was changed to expose a low level UART hook for doing polled mode reading and writing of a single character while in an atomic context. When kgdb makes an I/O request to the debugger, kgdboc invokes a callback in the serial core which in turn uses the callback in the UART driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2842>2842</a></td>\n' +
            '<td>When using kgdboc with a UART, the UART driver must implement two callbacks in the struct uart_ops. Example from drivers/8250.c:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2843>2843</a></td>\n' +
            '<td>#ifdef CONFIG_CONSOLE_POLL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2844>2844</a></td>\n' +
            '<td>    .poll_get_char = serial8250_get_poll_char,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2845>2845</a></td>\n' +
            '<td>    .poll_put_char = serial8250_put_poll_char,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2846>2846</a></td>\n' +
            '<td>#endif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2847>2847</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2848>2848</a></td>\n' +
            '<td>Any implementation specifics around creating a polling driver use the #ifdef CONFIG_CONSOLE_POLL, as shown above. Keep in mind that polling hooks have to be implemented in such a way that they can be called from an atomic context and have to restore the state of the UART chip on return such that the system can return to normal when the debugger detaches. You need to be very careful with any kind of lock you consider, because failing here is most likely going to mean pressing the reset button.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2849>2849</a></td>\n' +
            '<td>kgdboc and keyboards</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2850>2850</a></td>\n' +
            '<td>The kgdboc driver contains logic to configure communications with an attached keyboard. The keyboard infrastructure is only compiled into the kernel when CONFIG_KDB_KEYBOARD=y is set in the kernel configuration.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2851>2851</a></td>\n' +
            '<td>The core polled keyboard driver driver for PS/2 type keyboards is in drivers/char/kdb_keyboard.c. This driver is hooked into the debug core when kgdboc populates the callback in the array called kdb_poll_funcs[]. The kdb_get_kbd_char() is the top-level function which polls hardware for single character input.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2852>2852</a></td>\n' +
            '<td>kgdboc and kms</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2853>2853</a></td>\n' +
            '<td>The kgdboc driver contains logic to request the graphics display to switch to a text context when you are using "kgdboc=kms,kbd", provided that you have a video driver which has a frame buffer console and atomic kernel mode setting support.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2854>2854</a></td>\n' +
            '<td>Every time the kernel debugger is entered it calls kgdboc_pre_exp_handler() which in turn calls con_debug_enter() in the virtual console layer. On resuming kernel execution, the kernel debugger calls kgdboc_post_exp_handler() which in turn calls con_debug_leave().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2855>2855</a></td>\n' +
            '<td>Any video driver that wants to be compatible with the kernel debugger and the atomic kms callbacks must implement the mode_set_base_atomic, fb_debug_enter and fb_debug_leave operations. For the fb_debug_enter and fb_debug_leave the option exists to use the generic drm fb helper functions or implement something custom for the hardware. The following example shows the initialization of the .mode_set_base_atomic operation in drivers/gpu/drm/i915/intel_display.c:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2856>2856</a></td>\n' +
            '<td>static const struct drm_crtc_helper_funcs intel_helper_funcs = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2857>2857</a></td>\n' +
            '<td>[...]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2858>2858</a></td>\n' +
            '<td>        .mode_set_base_atomic = intel_pipe_set_base_atomic,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2859>2859</a></td>\n' +
            '<td>[...]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2860>2860</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2861>2861</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2862>2862</a></td>\n' +
            '<td>Here is an example of how the i915 driver initializes the fb_debug_enter and fb_debug_leave functions to use the generic drm helpers in drivers/gpu/drm/i915/intel_fb.c:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2863>2863</a></td>\n' +
            '<td>static struct fb_ops intelfb_ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2864>2864</a></td>\n' +
            '<td>[...]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2865>2865</a></td>\n' +
            '<td>       .fb_debug_enter = drm_fb_helper_debug_enter,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2866>2866</a></td>\n' +
            '<td>       .fb_debug_leave = drm_fb_helper_debug_leave,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2867>2867</a></td>\n' +
            '<td>[...]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2868>2868</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2869>2869</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2870>2870</a></td>\n' +
            '<td>Credits</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2871>2871</a></td>\n' +
            '<td>The following people have contributed to this document:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2872>2872</a></td>\n' +
            '<td>1.    Amit Kaleamitkale@linsyssoft.com</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2873>2873</a></td>\n' +
            '<td>2.    Tom Rinitrini@kernel.crashing.org</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2874>2874</a></td>\n' +
            '<td>In March 2008 this document was completely rewritten by:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2875>2875</a></td>\n' +
            '<td>    Jason Wesseljason.wessel@windriver.com</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2876>2876</a></td>\n' +
            '<td>In Jan 2010 this document was updated to include kdb.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2877>2877</a></td>\n' +
            '<td>    Jason Wesseljason.wessel@windriver.com</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2878>2878</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2879>2879</a></td>\n' +
            '<td>libATA is a library used inside the Linux kernel to support ATA host controllers and devices. libATA provides an ATA driver API, class transports for ATA and ATAPI devices, and SCSI&lt;-&gt;ATA translation for ATA devices according to the T10 SAT specification.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2880>2880</a></td>\n' +
            '<td>This Guide documents the libATA driver API, library functions, library internals, and a couple sample ATA low-level drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2881>2881</a></td>\n' +
            '<td>libata Driver API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2882>2882</a></td>\n' +
            '<td>struct ata_port_operations is defined for every low-level libata hardware driver, and it controls how the low-level driver interfaces with the ATA and SCSI layers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2883>2883</a></td>\n' +
            '<td>FIS-based drivers will hook into the system with -&gt;qc_prep() and -&gt;qc_issue() high-level hooks. Hardware which behaves in a manner similar to PCI IDE hardware may utilize several generic helpers, defining at a bare minimum the bus I/O addresses of the ATA shadow register blocks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2884>2884</a></td>\n' +
            '<td>struct ata_port_operations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2885>2885</a></td>\n' +
            '<td>Disable ATA port</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2886>2886</a></td>\n' +
            '<td>void (*port_disable) (struct ata_port *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2887>2887</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2888>2888</a></td>\n' +
            '<td>Called from ata_bus_probe() error path, as well as when unregistering from the SCSI module (rmmod, hot unplug). This function should do whatever needs to be done to take the port out of use. In most cases, ata_port_disable() can be used as this hook.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2889>2889</a></td>\n' +
            '<td>Called from ata_bus_probe() on a failed probe. Called from ata_scsi_release().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2890>2890</a></td>\n' +
            '<td>Post-IDENTIFY device configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2891>2891</a></td>\n' +
            '<td>void (*dev_config) (struct ata_port *, struct ata_device *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2892>2892</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2893>2893</a></td>\n' +
            '<td>Called after IDENTIFY [PACKET] DEVICE is issued to each device found. Typically used to apply device-specific fixups prior to issue of SET FEATURES - XFER MODE, and prior to operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2894>2894</a></td>\n' +
            '<td>This entry may be specified as NULL in ata_port_operations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2895>2895</a></td>\n' +
            '<td>Set PIO/DMA mode</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2896>2896</a></td>\n' +
            '<td>void (*set_piomode) (struct ata_port *, struct ata_device *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2897>2897</a></td>\n' +
            '<td>void (*set_dmamode) (struct ata_port *, struct ata_device *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2898>2898</a></td>\n' +
            '<td>void (*post_set_mode) (struct ata_port *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2899>2899</a></td>\n' +
            '<td>unsigned int (*mode_filter) (struct ata_port *, struct ata_device *, unsigned int);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2900>2900</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2901>2901</a></td>\n' +
            '<td>Hooks called prior to the issue of SET FEATURES - XFER MODE command. The optional -&gt;mode_filter() hook is called when libata has built a mask of the possible modes. This is passed to the -&gt;mode_filter() function which should return a mask of valid modes after filtering those unsuitable due to hardware limits. It is not valid to use this interface to add modes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2902>2902</a></td>\n' +
            '<td>dev-&gt;pio_mode and dev-&gt;dma_mode are guaranteed to be valid when -&gt;set_piomode() and when -&gt;set_dmamode() is called. The timings for any other drive sharing the cable will also be valid at this point. That is the library records the decisions for the modes of each drive on a channel before it attempts to set any of them.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2903>2903</a></td>\n' +
            '<td>-&gt;post_set_mode() is called unconditionally, after the SET FEATURES - XFER MODE command completes successfully.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2904>2904</a></td>\n' +
            '<td>-&gt;set_piomode() is always called (if present), but -&gt;set_dma_mode() is only called if DMA is possible.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2905>2905</a></td>\n' +
            '<td>Taskfile read/write</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2906>2906</a></td>\n' +
            '<td>void (*sff_tf_load) (struct ata_port *ap, struct ata_taskfile *tf);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2907>2907</a></td>\n' +
            '<td>void (*sff_tf_read) (struct ata_port *ap, struct ata_taskfile *tf);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2908>2908</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2909>2909</a></td>\n' +
            '<td>-&gt;tf_load() is called to load the given taskfile into hardware registers / DMA buffers. -&gt;tf_read() is called to read the hardware registers / DMA buffers, to obtain the current set of taskfile register values. Most drivers for taskfile-based hardware (PIO or MMIO) use ata_sff_tf_load() and ata_sff_tf_read() for these hooks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2910>2910</a></td>\n' +
            '<td>PIO data read/write</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2911>2911</a></td>\n' +
            '<td>void (*sff_data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2912>2912</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2913>2913</a></td>\n' +
            '<td>All bmdma-style drivers must implement this hook. This is the low-level operation that actually copies the data bytes during a PIO data transfer. Typically the driver will choose one of ata_sff_data_xfer_noirq(), ata_sff_data_xfer(), or ata_sff_data_xfer32().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2914>2914</a></td>\n' +
            '<td>ATA command execute</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2915>2915</a></td>\n' +
            '<td>void (*sff_exec_command)(struct ata_port *ap, struct ata_taskfile *tf);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2916>2916</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2917>2917</a></td>\n' +
            '<td>causes an ATA command, previously loaded with -&gt;tf_load(), to be initiated in hardware. Most drivers for taskfile-based hardware use ata_sff_exec_command() for this hook.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2918>2918</a></td>\n' +
            '<td>Per-cmd ATAPI DMA capabilities filter</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2919>2919</a></td>\n' +
            '<td>int (*check_atapi_dma) (struct ata_queued_cmd *qc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2920>2920</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2921>2921</a></td>\n' +
            '<td>Allow low-level driver to filter ATA PACKET commands, returning a status indicating whether or not it is OK to use DMA for the supplied PACKET command.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2922>2922</a></td>\n' +
            '<td>This hook may be specified as NULL, in which case libata will assume that atapi dma can be supported.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2923>2923</a></td>\n' +
            '<td>Read specific ATA shadow registers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2924>2924</a></td>\n' +
            '<td>u8   (*sff_check_status)(struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2925>2925</a></td>\n' +
            '<td>u8   (*sff_check_altstatus)(struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2926>2926</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2927>2927</a></td>\n' +
            '<td>Reads the Status/AltStatus ATA shadow register from hardware. On some hardware, reading the Status register has the side effect of clearing the interrupt condition. Most drivers for taskfile-based hardware use ata_sff_check_status() for this hook.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2928>2928</a></td>\n' +
            '<td>Write specific ATA shadow register</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2929>2929</a></td>\n' +
            '<td>void (*sff_set_devctl)(struct ata_port *ap, u8 ctl);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2930>2930</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2931>2931</a></td>\n' +
            '<td>Write the device control ATA shadow register to the hardware. Most drivers don' + "'" + 't need to define this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2932>2932</a></td>\n' +
            '<td>Select ATA device on bus</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2933>2933</a></td>\n' +
            '<td>void (*sff_dev_select)(struct ata_port *ap, unsigned int device);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2934>2934</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2935>2935</a></td>\n' +
            '<td>Issues the low-level hardware command(s) that causes one of N hardware devices to be considered ' + "'" + 'selected' + "'" + ' (active and available for use) on the ATA bus. This generally has no meaning on FIS-based devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2936>2936</a></td>\n' +
            '<td>Most drivers for taskfile-based hardware use ata_sff_dev_select() for this hook.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2937>2937</a></td>\n' +
            '<td>Private tuning method</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2938>2938</a></td>\n' +
            '<td>void (*set_mode) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2939>2939</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2940>2940</a></td>\n' +
            '<td>By default libata performs drive and controller tuning in accordance with the ATA timing rules and also applies blacklists and cable limits. Some controllers need special handling and have custom tuning rules, typically raid controllers that use ATA commands but do not actually do drive timing.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2941>2941</a></td>\n' +
            '<td>Warning</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2942>2942</a></td>\n' +
            '<td>This hook should not be used to replace the standard controller tuning logic when a controller has quirks. Replacing the default tuning logic in that case would bypass handling for drive and bridge quirks that may be important to data reliability. If a controller needs to filter the mode selection it should use the mode_filter hook instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2943>2943</a></td>\n' +
            '<td>Control PCI IDE BMDMA engine</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2944>2944</a></td>\n' +
            '<td>void (*bmdma_setup) (struct ata_queued_cmd *qc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2945>2945</a></td>\n' +
            '<td>void (*bmdma_start) (struct ata_queued_cmd *qc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2946>2946</a></td>\n' +
            '<td>void (*bmdma_stop) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2947>2947</a></td>\n' +
            '<td>u8   (*bmdma_status) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2948>2948</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2949>2949</a></td>\n' +
            '<td>When setting up an IDE BMDMA transaction, these hooks arm (-&gt;bmdma_setup), fire (-&gt;bmdma_start), and halt (-&gt;bmdma_stop) the hardware' + "'" + 's DMA engine. -&gt;bmdma_status is used to read the standard PCI IDE DMA Status register.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2950>2950</a></td>\n' +
            '<td>These hooks are typically either no-ops, or simply not implemented, in FIS-based drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2951>2951</a></td>\n' +
            '<td>Most legacy IDE drivers use ata_bmdma_setup() for the bmdma_setup() hook. ata_bmdma_setup() will write the pointer to the PRD table to the IDE PRD Table Address register, enable DMA in the DMA Command register, and call exec_command() to begin the transfer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2952>2952</a></td>\n' +
            '<td>Most legacy IDE drivers use ata_bmdma_start() for the bmdma_start() hook. ata_bmdma_start() will write the ATA_DMA_START flag to the DMA Command register.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2953>2953</a></td>\n' +
            '<td>Many legacy IDE drivers use ata_bmdma_stop() for the bmdma_stop() hook. ata_bmdma_stop() clears the ATA_DMA_START flag in the DMA command register.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2954>2954</a></td>\n' +
            '<td>Many legacy IDE drivers use ata_bmdma_status() as the bmdma_status() hook.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2955>2955</a></td>\n' +
            '<td>High-level taskfile hooks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2956>2956</a></td>\n' +
            '<td>void (*qc_prep) (struct ata_queued_cmd *qc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2957>2957</a></td>\n' +
            '<td>int (*qc_issue) (struct ata_queued_cmd *qc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2958>2958</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2959>2959</a></td>\n' +
            '<td>Higher-level hooks, these two hooks can potentially supercede several of the above taskfile/DMA engine hooks. -&gt;qc_prep is called after the buffers have been DMA-mapped, and is typically used to populate the hardware' + "'" + 's DMA scatter-gather table. Most drivers use the standard ata_qc_prep() helper function, but more advanced drivers roll their own.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2960>2960</a></td>\n' +
            '<td>-&gt;qc_issue is used to make a command active, once the hardware and S/G tables have been prepared. IDE BMDMA drivers use the helper function ata_qc_issue_prot() for taskfile protocol-based dispatch. More advanced drivers implement their own -&gt;qc_issue.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2961>2961</a></td>\n' +
            '<td>ata_qc_issue_prot() calls -&gt;tf_load(), -&gt;bmdma_setup(), and -&gt;bmdma_start() as necessary to initiate a transfer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2962>2962</a></td>\n' +
            '<td>Exception and probe handling (EH)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2963>2963</a></td>\n' +
            '<td>void (*eng_timeout) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2964>2964</a></td>\n' +
            '<td>void (*phy_reset) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2965>2965</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2966>2966</a></td>\n' +
            '<td>Deprecated. Use -&gt;error_handler() instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2967>2967</a></td>\n' +
            '<td>void (*freeze) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2968>2968</a></td>\n' +
            '<td>void (*thaw) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2969>2969</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2970>2970</a></td>\n' +
            '<td>ata_port_freeze() is called when HSM violations or some other condition disrupts normal operation of the port. A frozen port is not allowed to perform any operation until the port is thawed, which usually follows a successful reset.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2971>2971</a></td>\n' +
            '<td>The optional -&gt;freeze() callback can be used for freezing the port hardware-wise (e.g. mask interrupt and stop DMA engine). If a port cannot be frozen hardware-wise, the interrupt handler must ack and clear interrupts unconditionally while the port is frozen.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2972>2972</a></td>\n' +
            '<td>The optional -&gt;thaw() callback is called to perform the opposite of -&gt;freeze(): prepare the port for normal operation once again. Unmask interrupts, start DMA engine, etc.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2973>2973</a></td>\n' +
            '<td>void (*error_handler) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2974>2974</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2975>2975</a></td>\n' +
            '<td>-&gt;error_handler() is a driver' + "'" + 's hook into probe, hotplug, and recovery and other exceptional conditions. The primary responsibility of an implementation is to call ata_do_eh() or ata_bmdma_drive_eh() with a set of EH hooks as arguments:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2976>2976</a></td>\n' +
            '<td>' + "'" + 'prereset' + "'" + ' hook (may be NULL) is called during an EH reset, before any other actions are taken.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2977>2977</a></td>\n' +
            '<td>' + "'" + 'postreset' + "'" + ' hook (may be NULL) is called after the EH reset is performed. Based on existing conditions, severity of the problem, and hardware capabilities,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2978>2978</a></td>\n' +
            '<td>Either ' + "'" + 'softreset' + "'" + ' (may be NULL) or ' + "'" + 'hardreset' + "'" + ' (may be NULL) will be called to perform the low-level EH reset.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2979>2979</a></td>\n' +
            '<td>void (*post_internal_cmd) (struct ata_queued_cmd *qc);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2980>2980</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2981>2981</a></td>\n' +
            '<td>Perform any hardware-specific actions necessary to finish processing after executing a probe-time or EH-time command via ata_exec_internal().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2982>2982</a></td>\n' +
            '<td>Hardware interrupt handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2983>2983</a></td>\n' +
            '<td>irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2984>2984</a></td>\n' +
            '<td>void (*irq_clear) (struct ata_port *);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2985>2985</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2986>2986</a></td>\n' +
            '<td>-&gt;irq_handler is the interrupt handling routine registered with the system, by libata. -&gt;irq_clear is called during probe just before the interrupt handler is registered, to be sure hardware is quiet.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2987>2987</a></td>\n' +
            '<td>The second argument, dev_instance, should be cast to a pointer to struct ata_host_set.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2988>2988</a></td>\n' +
            '<td>Most legacy IDE drivers use ata_sff_interrupt() for the irq_handler hook, which scans all ports in the host_set, determines which queued command was active (if any), and calls ata_sff_host_intr(ap,qc).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2989>2989</a></td>\n' +
            '<td>Most legacy IDE drivers use ata_sff_irq_clear() for the irq_clear() hook, which simply clears the interrupt and error flags in the DMA status register.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2990>2990</a></td>\n' +
            '<td>SATA phy read/write</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2991>2991</a></td>\n' +
            '<td>int (*scr_read) (struct ata_port *ap, unsigned int sc_reg,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2992>2992</a></td>\n' +
            '<td>         u32 *val);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2993>2993</a></td>\n' +
            '<td>int (*scr_write) (struct ata_port *ap, unsigned int sc_reg,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2994>2994</a></td>\n' +
            '<td>                   u32 val);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2995>2995</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2996>2996</a></td>\n' +
            '<td>Read and write standard SATA phy registers. Currently only used if -&gt;phy_reset hook called the sata_phy_reset() helper function. sc_reg is one of SCR_STATUS, SCR_CONTROL, SCR_ERROR, or SCR_ACTIVE.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2997>2997</a></td>\n' +
            '<td>Init and shutdown</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2998>2998</a></td>\n' +
            '<td>int (*port_start) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=2999>2999</a></td>\n' +
            '<td>void (*port_stop) (struct ata_port *ap);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3000>3000</a></td>\n' +
            '<td>void (*host_stop) (struct ata_host_set *host_set);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3001>3001</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3002>3002</a></td>\n' +
            '<td>-&gt;port_start() is called just after the data structures for each port are initialized. Typically this is used to alloc per-port DMA buffers / tables / rings, enable DMA engines, and similar tasks. Some drivers also use this entry point as a chance to allocate driver-private memory for ap-&gt;private_data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3003>3003</a></td>\n' +
            '<td>Many drivers use ata_port_start() as this hook or call it from their own port_start() hooks. ata_port_start() allocates space for a legacy IDE PRD table and returns.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3004>3004</a></td>\n' +
            '<td>-&gt;port_stop() is called after -&gt;host_stop(). Its sole function is to release DMA/memory resources, now that they are no longer actively being used. Many drivers also free driver-private data from port at this time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3005>3005</a></td>\n' +
            '<td>-&gt;host_stop() is called after all -&gt;port_stop() calls have completed. The hook must finalize hardware shutdown, release DMA and other resources, etc. This hook may be specified as NULL, in which case it is not called.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3006>3006</a></td>\n' +
            '<td>Error handling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3007>3007</a></td>\n' +
            '<td>This chapter describes how errors are handled under libata. Readers are advised to read SCSI EH (Documentation/scsi/scsi_eh.txt) and ATA exceptions doc first.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3008>3008</a></td>\n' +
            '<td>Origins of commands</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3009>3009</a></td>\n' +
            '<td>In libata, a command is represented with struct ata_queued_cmd or qc. qc' + "'" + 's are preallocated during port initialization and repetitively used for command executions. Currently only one qc is allocated per port but yet-to-be-merged NCQ branch allocates one for each tag and maps each qc to NCQ tag 1-to-1.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3010>3010</a></td>\n' +
            '<td>libata commands can originate from two sources - libata itself and SCSI midlayer. libata internal commands are used for initialization and error handling. All normal blk requests and commands for SCSI emulation are passed as SCSI commands through queuecommand callback of SCSI host template.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3011>3011</a></td>\n' +
            '<td>How commands are issued</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3012>3012</a></td>\n' +
            '<td>Internal commands</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3013>3013</a></td>\n' +
            '<td>First, qc is allocated and initialized using ata_qc_new_init(). Although ata_qc_new_init() doesn' + "'" + 't implement any wait or retry mechanism when qc is not available, internal commands are currently issued only during initialization and error recovery, so no other command is active and allocation is guaranteed to succeed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3014>3014</a></td>\n' +
            '<td>Once allocated qc' + "'" + 's taskfile is initialized for the command to be executed. qc currently has two mechanisms to notify completion. One is via qc-&gt;complete_fn() callback and the other is completion qc-&gt;waiting. qc-&gt;complete_fn() callback is the asynchronous path used by normal SCSI translated commands and qc-&gt;waiting is the synchronous (issuer sleeps in process context) path used by internal commands.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3015>3015</a></td>\n' +
            '<td>Once initialization is complete, host_set lock is acquired and the qc is issued.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3016>3016</a></td>\n' +
            '<td>SCSI commands</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3017>3017</a></td>\n' +
            '<td>All libata drivers use ata_scsi_queuecmd() as hostt-&gt;queuecommand callback. scmds can either be simulated or translated. No qc is involved in processing a simulated scmd. The result is computed right away and the scmd is completed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3018>3018</a></td>\n' +
            '<td>For a translated scmd, ata_qc_new_init() is invoked to allocate a qc and the scmd is translated into the qc. SCSI midlayer' + "'" + 's completion notification function pointer is stored into qc-&gt;scsidone.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3019>3019</a></td>\n' +
            '<td>qc-&gt;complete_fn() callback is used for completion notification. ATA commands use ata_scsi_qc_complete() while ATAPI commands use atapi_qc_complete(). Both functions end up calling qc-&gt;scsidone to notify upper layer when the qc is finished. After translation is completed, the qc is issued with ata_qc_issue().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3020>3020</a></td>\n' +
            '<td>Note that SCSI midlayer invokes hostt-&gt;queuecommand while holding host_set lock, so all above occur while holding host_set lock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3021>3021</a></td>\n' +
            '<td>How commands are processed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3022>3022</a></td>\n' +
            '<td>Depending on which protocol and which controller are used, commands are processed differently. For the purpose of discussion, a controller which uses taskfile interface and all standard callbacks is assumed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3023>3023</a></td>\n' +
            '<td>Currently 6 ATA command protocols are used. They can be sorted into the following four categories according to how they are processed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3024>3024</a></td>\n' +
            '<td>ATA NO DATA or DMA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3025>3025</a></td>\n' +
            '<td>ATA_PROT_NODATA and ATA_PROT_DMA fall into this category. These types of commands don' + "'" + 't require any software intervention once issued. Device will raise interrupt on completion.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3026>3026</a></td>\n' +
            '<td>ATA PIO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3027>3027</a></td>\n' +
            '<td>ATA_PROT_PIO is in this category. libata currently implements PIO with polling. ATA_NIEN bit is set to turn off interrupt and pio_task on ata_wq performs polling and IO.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3028>3028</a></td>\n' +
            '<td>ATAPI NODATA or DMA</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3029>3029</a></td>\n' +
            '<td>ATA_PROT_ATAPI_NODATA and ATA_PROT_ATAPI_DMA are in this category. packet_task is used to poll BSY bit after issuing PACKET command. Once BSY is turned off by the device, packet_task transfers CDB and hands off processing to interrupt handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3030>3030</a></td>\n' +
            '<td>ATAPI PIO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3031>3031</a></td>\n' +
            '<td>ATA_PROT_ATAPI is in this category. ATA_NIEN bit is set and, as in ATAPI NODATA or DMA, packet_task submits cdb. However, after submitting cdb, further processing (data transfer) is handed off to pio_task.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3032>3032</a></td>\n' +
            '<td>How commands are completed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3033>3033</a></td>\n' +
            '<td>Once issued, all qc' + "'" + 's are either completed with ata_qc_complete() or time out. For commands which are handled by interrupts, ata_host_intr() invokes ata_qc_complete(), and, for PIO tasks, pio_task invokes ata_qc_complete(). In error cases, packet_task may also complete commands.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3034>3034</a></td>\n' +
            '<td>ata_qc_complete() does the following.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3035>3035</a></td>\n' +
            '<td>1.    DMA memory is unmapped.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3036>3036</a></td>\n' +
            '<td>2.    ATA_QCFLAG_ACTIVE is clared from qc-&gt;flags.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3037>3037</a></td>\n' +
            '<td>3.    qc-&gt;complete_fn() callback is invoked. If the return value of the callback is not zero. Completion is short circuited and ata_qc_complete() returns.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3038>3038</a></td>\n' +
            '<td>4.    __ata_qc_complete() is called, which does</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3039>3039</a></td>\n' +
            '<td>1.    qc-&gt;flags is cleared to zero.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3040>3040</a></td>\n' +
            '<td>2.    ap-&gt;active_tag and qc-&gt;tag are poisoned.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3041>3041</a></td>\n' +
            '<td>3.    qc-&gt;waiting is claread &amp; completed (in that order).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3042>3042</a></td>\n' +
            '<td>4.    qc is deallocated by clearing appropriate bit in ap-&gt;qactive.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3043>3043</a></td>\n' +
            '<td>So, it basically notifies upper layer and deallocates qc. One exception is short-circuit path in #3 which is used by atapi_qc_complete().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3044>3044</a></td>\n' +
            '<td>For all non-ATAPI commands, whether it fails or not, almost the same code path is taken and very little error handling takes place. A qc is completed with success status if it succeeded, with failed status otherwise.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3045>3045</a></td>\n' +
            '<td>However, failed ATAPI commands require more handling as REQUEST SENSE is needed to acquire sense data. If an ATAPI command fails, ata_qc_complete() is invoked with error status, which in turn invokes atapi_qc_complete() via qc-&gt;complete_fn() callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3046>3046</a></td>\n' +
            '<td>This makes atapi_qc_complete() set scmd-&gt;result to SAM_STAT_CHECK_CONDITION, complete the scmd and return 1. As the sense data is empty but scmd-&gt;result is CHECK CONDITION, SCSI midlayer will invoke EH for the scmd, and returning 1 makes ata_qc_complete() to return without deallocating the qc. This leads us to ata_scsi_error() with partially completed qc.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3047>3047</a></td>\n' +
            '<td>ata_scsi_error()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3048>3048</a></td>\n' +
            '<td>ata_scsi_error() is the current transportt-&gt;eh_strategy_handler() for libata. As discussed above, this will be entered in two cases - timeout and ATAPI error completion. This function calls low level libata driver' + "'" + 's eng_timeout() callback, the standard callback for which is ata_eng_timeout(). It checks if a qc is active and calls ata_qc_timeout() on the qc if so. Actual error handling occurs in ata_qc_timeout().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3049>3049</a></td>\n' +
            '<td>If EH is invoked for timeout, ata_qc_timeout() stops BMDMA and completes the qc. Note that as we' + "'" + 're currently in EH, we cannot call scsi_done. As described in SCSI EH doc, a recovered scmd should be either retried with scsi_queue_insert() or finished with scsi_finish_command(). Here, we override qc-&gt;scsidone with scsi_finish_command() and calls ata_qc_complete().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3050>3050</a></td>\n' +
            '<td>If EH is invoked due to a failed ATAPI qc, the qc here is completed but not deallocated. The purpose of this half-completion is to use the qc as place holder to make EH code reach this place. This is a bit hackish, but it works.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3051>3051</a></td>\n' +
            '<td>Once control reaches here, the qc is deallocated by invoking __ata_qc_complete() explicitly. Then, internal qc for REQUEST SENSE is issued. Once sense data is acquired, scmd is finished by directly invoking scsi_finish_command() on the scmd. Note that as we already have completed and deallocated the qc which was associated with the scmd, we don' + "'" + 't need to/cannot call ata_qc_complete() again.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3052>3052</a></td>\n' +
            '<td>Problems with the current EH</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3053>3053</a></td>\n' +
            '<td>    Error representation is too crude. Currently any and all error conditions are represented with ATA STATUS and ERROR registers. Errors which aren' + "'" + 't ATA device errors are treated as ATA device errors by setting ATA_ERR bit. Better error descriptor which can properly represent ATA and other errors/exceptions is needed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3054>3054</a></td>\n' +
            '<td>    When handling timeouts, no action is taken to make device forget about the timed out command and ready for new commands.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3055>3055</a></td>\n' +
            '<td>    EH handling via ata_scsi_error() is not properly protected from usual command processing. On EH entrance, the device is not in quiescent state. Timed out commands may succeed or fail any time. pio_task and atapi_task may still be running.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3056>3056</a></td>\n' +
            '<td>    Too weak error recovery. Devices / controllers causing HSM mismatch errors and other errors quite often require reset to return to known state. Also, advanced error handling is necessary to support features like NCQ and hotplug.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3057>3057</a></td>\n' +
            '<td>    ATA errors are directly handled in the interrupt handler and PIO errors in pio_task. This is problematic for advanced error handling for the following reasons.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3058>3058</a></td>\n' +
            '<td>     First, advanced error handling often requires context and internal qc execution.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3059>3059</a></td>\n' +
            '<td>     Second, even a simple failure (say, CRC error) needs information gathering and could trigger complex error handling (say, resetting &amp; reconfiguring). Having multiple code paths to gather information, enter EH and trigger actions makes life painful.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3060>3060</a></td>\n' +
            '<td>     Third, scattered EH code makes implementing low level drivers difficult. Low level drivers override libata callbacks. If EH is scattered over several places, each affected callbacks should perform its part of error handling. This can be error prone and painful.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3061>3061</a></td>\n' +
            '<td>libata Library</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3062>3062</a></td>\n' +
            '<td>!Edrivers/ata/libata-core.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3063>3063</a></td>\n' +
            '<td>libata Core Internals</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3064>3064</a></td>\n' +
            '<td>!Idrivers/ata/libata-core.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3065>3065</a></td>\n' +
            '<td>libata SCSI translation/emulation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3066>3066</a></td>\n' +
            '<td>!Edrivers/ata/libata-scsi.c !Idrivers/ata/libata-scsi.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3067>3067</a></td>\n' +
            '<td>ATA errors and exceptions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3068>3068</a></td>\n' +
            '<td>This chapter tries to identify what error/exception conditions exist for ATA/ATAPI devices and describe how they should be handled in implementation-neutral way.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3069>3069</a></td>\n' +
            '<td>The term ' + "'" + 'error' + "'" + ' is used to describe conditions where either an explicit error condition is reported from device or a command has timed out.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3070>3070</a></td>\n' +
            '<td>The term ' + "'" + 'exception' + "'" + ' is either used to describe exceptional conditions which are not errors (say, power or hotplug events), or to describe both errors and non-error exceptional conditions. Where explicit distinction between error and exception is necessary, the term ' + "'" + 'non-error exception' + "'" + ' is used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3071>3071</a></td>\n' +
            '<td>Exception categories</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3072>3072</a></td>\n' +
            '<td>Exceptions are described primarily with respect to legacy taskfile + bus master IDE interface. If a controller provides other better mechanism for error reporting, mapping those into categories described below shouldn' + "'" + 't be difficult.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3073>3073</a></td>\n' +
            '<td>In the following sections, two recovery actions - reset and reconfiguring transport - are mentioned. These are described further in ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3074>3074</a></td>\n' +
            '<td>HSM violation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3075>3075</a></td>\n' +
            '<td>This error is indicated when STATUS value doesn' + "'" + 't match HSM requirement during issuing or execution any ATA/ATAPI command.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3076>3076</a></td>\n' +
            '<td>    ATA_STATUS doesn' + "'" + 't contain !BSY &amp;&amp; DRDY &amp;&amp; !DRQ while trying to issue a command.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3077>3077</a></td>\n' +
            '<td>    !BSY &amp;&amp; !DRQ during PIO data transfer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3078>3078</a></td>\n' +
            '<td>    DRQ on command completion.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3079>3079</a></td>\n' +
            '<td>    !BSY &amp;&amp; ERR after CDB transfer starts but before the last byte of CDB is transferred. ATA/ATAPI standard states that "The device shall not terminate the PACKET command with an error before the last byte of the command packet has been written" in the error outputs description of PACKET command and the state diagram doesn' + "'" + 't include such transitions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3080>3080</a></td>\n' +
            '<td>In these cases, HSM is violated and not much information regarding the error can be acquired from STATUS or ERROR register. IOW, this error can be anything - driver bug, faulty device, controller and/or cable.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3081>3081</a></td>\n' +
            '<td>As HSM is violated, reset is necessary to restore known state. Reconfiguring transport for lower speed might be helpful too as transmission errors sometimes cause this kind of errors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3082>3082</a></td>\n' +
            '<td>ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3083>3083</a></td>\n' +
            '<td>These are errors detected and reported by ATA/ATAPI devices indicating device problems. For this type of errors, STATUS and ERROR register values are valid and describe error condition. Note that some of ATA bus errors are detected by ATA/ATAPI devices and reported using the same mechanism as device errors. Those cases are described later in this section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3084>3084</a></td>\n' +
            '<td>For ATA commands, this type of errors are indicated by !BSY &amp;&amp; ERR during command execution and on completion.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3085>3085</a></td>\n' +
            '<td>For ATAPI commands,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3086>3086</a></td>\n' +
            '<td>    !BSY &amp;&amp; ERR &amp;&amp; ABRT right after issuing PACKET indicates that PACKET command is not supported and falls in this category.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3087>3087</a></td>\n' +
            '<td>    !BSY &amp;&amp; ERR(==CHK) &amp;&amp; !ABRT after the last byte of CDB is transferred indicates CHECK CONDITION and doesn' + "'" + 't fall in this category.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3088>3088</a></td>\n' +
            '<td>    !BSY &amp;&amp; ERR(==CHK) &amp;&amp; ABRT after the last byte of CDB is transferred *probably* indicates CHECK CONDITION and doesn' + "'" + 't fall in this category.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3089>3089</a></td>\n' +
            '<td>Of errors detected as above, the followings are not ATA/ATAPI device errors but ATA bus errors and should be handled according to ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3090>3090</a></td>\n' +
            '<td>CRC error during data transfer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3091>3091</a></td>\n' +
            '<td>This is indicated by ICRC bit in the ERROR register and means that corruption occurred during data transfer. Up to ATA/ATAPI-7, the standard specifies that this bit is only applicable to UDMA transfers but ATA/ATAPI-8 draft revision 1f says that the bit may be applicable to multiword DMA and PIO.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3092>3092</a></td>\n' +
            '<td>ABRT error during data transfer or on completion</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3093>3093</a></td>\n' +
            '<td>Up to ATA/ATAPI-7, the standard specifies that ABRT could be set on ICRC errors and on cases where a device is not able to complete a command. Combined with the fact that MWDMA and PIO transfer errors aren' + "'" + 't allowed to use ICRC bit up to ATA/ATAPI-7, it seems to imply that ABRT bit alone could indicate transfer errors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3094>3094</a></td>\n' +
            '<td>However, ATA/ATAPI-8 draft revision 1f removes the part that ICRC errors can turn on ABRT. So, this is kind of gray area. Some heuristics are needed here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3095>3095</a></td>\n' +
            '<td>ATA/ATAPI device errors can be further categorized as follows.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3096>3096</a></td>\n' +
            '<td>Media errors</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3097>3097</a></td>\n' +
            '<td>This is indicated by UNC bit in the ERROR register. ATA devices reports UNC error only after certain number of retries cannot recover the data, so there' + "'" + 's nothing much else to do other than notifying upper layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3098>3098</a></td>\n' +
            '<td>READ and WRITE commands report CHS or LBA of the first failed sector but ATA/ATAPI standard specifies that the amount of transferred data on error completion is indeterminate, so we cannot assume that sectors preceding the failed sector have been transferred and thus cannot complete those sectors successfully as SCSI does.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3099>3099</a></td>\n' +
            '<td>Media changed / media change requested error</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3100>3100</a></td>\n' +
            '<td>&lt;&lt;TODO: fill here&gt;&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3101>3101</a></td>\n' +
            '<td>Address error</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3102>3102</a></td>\n' +
            '<td>This is indicated by IDNF bit in the ERROR register. Report to upper layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3103>3103</a></td>\n' +
            '<td>Other errors</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3104>3104</a></td>\n' +
            '<td>This can be invalid command or parameter indicated by ABRT ERROR bit or some other error condition. Note that ABRT bit can indicate a lot of things including ICRC and Address errors. Heuristics needed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3105>3105</a></td>\n' +
            '<td>Depending on commands, not all STATUS/ERROR bits are applicable. These non-applicable bits are marked with "na" in the output descriptions but up to ATA/ATAPI-7 no definition of "na" can be found. However, ATA/ATAPI-8 draft revision 1f describes "N/A" as follows.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3106>3106</a></td>\n' +
            '<td>3.2.3.3a N/A</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3107>3107</a></td>\n' +
            '<td>A keyword the indicates a field has no defined value in this standard and should not be checked by the host or device. N/A fields should be cleared to zero.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3108>3108</a></td>\n' +
            '<td>So, it seems reasonable to assume that "na" bits are cleared to zero by devices and thus need no explicit masking.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3109>3109</a></td>\n' +
            '<td>ATAPI device CHECK CONDITION</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3110>3110</a></td>\n' +
            '<td>ATAPI device CHECK CONDITION error is indicated by set CHK bit (ERR bit) in the STATUS register after the last byte of CDB is transferred for a PACKET command. For this kind of errors, sense data should be acquired to gather information regarding the errors. REQUEST SENSE packet command should be used to acquire sense data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3111>3111</a></td>\n' +
            '<td>Once sense data is acquired, this type of errors can be handled similary to other SCSI errors. Note that sense data may indicate ATA bus error (e.g. Sense Key 04h HARDWARE ERROR &amp;&amp; ASC/ASCQ 47h/00h SCSI PARITY ERROR). In such cases, the error should be considered as an ATA bus error and handled according to ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3112>3112</a></td>\n' +
            '<td>ATA device error (NCQ)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3113>3113</a></td>\n' +
            '<td>NCQ command error is indicated by cleared BSY and set ERR bit during NCQ command phase (one or more NCQ commands outstanding). Although STATUS and ERROR registers will contain valid values describing the error, READ LOG EXT is required to clear the error condition, determine which command has failed and acquire more information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3114>3114</a></td>\n' +
            '<td>READ LOG EXT Log Page 10h reports which tag has failed and taskfile register values describing the error. With this information the failed command can be handled as a normal ATA command error as in ??? and all other in-flight commands must be retried. Note that this retry should not be counted - it' + "'" + 's likely that commands retried this way would have completed normally if it were not for the failed command.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3115>3115</a></td>\n' +
            '<td>Note that ATA bus errors can be reported as ATA device NCQ errors. This should be handled as described in ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3116>3116</a></td>\n' +
            '<td>If READ LOG EXT Log Page 10h fails or reports NQ, we' + "'" + 're thoroughly screwed. This condition should be treated according to ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3117>3117</a></td>\n' +
            '<td>ATA bus error</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3118>3118</a></td>\n' +
            '<td>ATA bus error means that data corruption occurred during transmission over ATA bus (SATA or PATA). This type of errors can be indicated by</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3119>3119</a></td>\n' +
            '<td>    ICRC or ABRT error as described in ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3120>3120</a></td>\n' +
            '<td>    Controller-specific error completion with error information indicating transmission error.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3121>3121</a></td>\n' +
            '<td>    On some controllers, command timeout. In this case, there may be a mechanism to determine that the timeout is due to transmission error.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3122>3122</a></td>\n' +
            '<td>    Unknown/random errors, timeouts and all sorts of weirdities.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3123>3123</a></td>\n' +
            '<td>As described above, transmission errors can cause wide variety of symptoms ranging from device ICRC error to random device lockup, and, for many cases, there is no way to tell if an error condition is due to transmission error or not; therefore, it' + "'" + 's necessary to employ some kind of heuristic when dealing with errors and timeouts. For example, encountering repetitive ABRT errors for known supported command is likely to indicate ATA bus error.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3124>3124</a></td>\n' +
            '<td>Once it' + "'" + 's determined that ATA bus errors have possibly occurred, lowering ATA bus transmission speed is one of actions which may alleviate the problem. See ??? for more information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3125>3125</a></td>\n' +
            '<td>PCI bus error</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3126>3126</a></td>\n' +
            '<td>Data corruption or other failures during transmission over PCI (or other system bus). For standard BMDMA, this is indicated by Error bit in the BMDMA Status register. This type of errors must be logged as it indicates something is very wrong with the system. Resetting host controller is recommended.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3127>3127</a></td>\n' +
            '<td>Late completion</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3128>3128</a></td>\n' +
            '<td>This occurs when timeout occurs and the timeout handler finds out that the timed out command has completed successfully or with error. This is usually caused by lost interrupts. This type of errors must be logged. Resetting host controller is recommended.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3129>3129</a></td>\n' +
            '<td>Unknown error (timeout)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3130>3130</a></td>\n' +
            '<td>This is when timeout occurs and the command is still processing or the host and device are in unknown state. When this occurs, HSM could be in any valid or invalid state. To bring the device to known state and make it forget about the timed out command, resetting is necessary. The timed out command may be retried.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3131>3131</a></td>\n' +
            '<td>Timeouts can also be caused by transmission errors. Refer to ??? for more details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3132>3132</a></td>\n' +
            '<td>Hotplug and power management exceptions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3133>3133</a></td>\n' +
            '<td>&lt;&lt;TODO: fill here&gt;&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3134>3134</a></td>\n' +
            '<td>EH recovery actions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3135>3135</a></td>\n' +
            '<td>This section discusses several important recovery actions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3136>3136</a></td>\n' +
            '<td>Clearing error condition</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3137>3137</a></td>\n' +
            '<td>Many controllers require its error registers to be cleared by error handler. Different controllers may have different requirements.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3138>3138</a></td>\n' +
            '<td>For SATA, it' + "'" + 's strongly recommended to clear at least SError register during error handling.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3139>3139</a></td>\n' +
            '<td>Reset</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3140>3140</a></td>\n' +
            '<td>During EH, resetting is necessary in the following cases.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3141>3141</a></td>\n' +
            '<td>    HSM is in unknown or invalid state</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3142>3142</a></td>\n' +
            '<td>    HBA is in unknown or invalid state</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3143>3143</a></td>\n' +
            '<td>    EH needs to make HBA/device forget about in-flight commands</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3144>3144</a></td>\n' +
            '<td>    HBA/device behaves weirdly</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3145>3145</a></td>\n' +
            '<td>Resetting during EH might be a good idea regardless of error condition to improve EH robustness. Whether to reset both or either one of HBA and device depends on situation but the following scheme is recommended.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3146>3146</a></td>\n' +
            '<td>    When it' + "'" + 's known that HBA is in ready state but ATA/ATAPI device is in unknown state, reset only device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3147>3147</a></td>\n' +
            '<td>    If HBA is in unknown state, reset both HBA and device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3148>3148</a></td>\n' +
            '<td>HBA resetting is implementation specific. For a controller complying to taskfile/BMDMA PCI IDE, stopping active DMA transaction may be sufficient iff BMDMA state is the only HBA context. But even mostly taskfile/BMDMA PCI IDE complying controllers may have implementation specific requirements and mechanism to reset themselves. This must be addressed by specific drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3149>3149</a></td>\n' +
            '<td>OTOH, ATA/ATAPI standard describes in detail ways to reset ATA/ATAPI devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3150>3150</a></td>\n' +
            '<td>PATA hardware reset</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3151>3151</a></td>\n' +
            '<td>This is hardware initiated device reset signalled with asserted PATA RESET- signal. There is no standard way to initiate hardware reset from software although some hardware provides registers that allow driver to directly tweak the RESET- signal.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3152>3152</a></td>\n' +
            '<td>Software reset</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3153>3153</a></td>\n' +
            '<td>This is achieved by turning CONTROL SRST bit on for at least 5us. Both PATA and SATA support it but, in case of SATA, this may require controller-specific support as the second Register FIS to clear SRST should be transmitted while BSY bit is still set. Note that on PATA, this resets both master and slave devices on a channel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3154>3154</a></td>\n' +
            '<td>EXECUTE DEVICE DIAGNOSTIC command</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3155>3155</a></td>\n' +
            '<td>Although ATA/ATAPI standard doesn' + "'" + 't describe exactly, EDD implies some level of resetting, possibly similar level with software reset. Host-side EDD protocol can be handled with normal command processing and most SATA controllers should be able to handle EDD' + "'" + 's just like other commands. As in software reset, EDD affects both devices on a PATA bus.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3156>3156</a></td>\n' +
            '<td>Although EDD does reset devices, this doesn' + "'" + 't suit error handling as EDD cannot be issued while BSY is set and it' + "'" + 's unclear how it will act when device is in unknown/weird state.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3157>3157</a></td>\n' +
            '<td>ATAPI DEVICE RESET command</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3158>3158</a></td>\n' +
            '<td>This is very similar to software reset except that reset can be restricted to the selected device without affecting the other device sharing the cable.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3159>3159</a></td>\n' +
            '<td>SATA phy reset</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3160>3160</a></td>\n' +
            '<td>This is the preferred way of resetting a SATA device. In effect, it' + "'" + 's identical to PATA hardware reset. Note that this can be done with the standard SCR Control register. As such, it' + "'" + 's usually easier to implement than software reset.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3161>3161</a></td>\n' +
            '<td>One more thing to consider when resetting devices is that resetting clears certain configuration parameters and they need to be set to their previous or newly adjusted values after reset.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3162>3162</a></td>\n' +
            '<td>Parameters affected are.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3163>3163</a></td>\n' +
            '<td>    CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3164>3164</a></td>\n' +
            '<td>    Parameters set with SET FEATURES including transfer mode setting</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3165>3165</a></td>\n' +
            '<td>    Block count set with SET MULTIPLE MODE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3166>3166</a></td>\n' +
            '<td>    Other parameters (SET MAX, MEDIA LOCK...)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3167>3167</a></td>\n' +
            '<td>ATA/ATAPI standard specifies that some parameters must be maintained across hardware or software reset, but doesn' + "'" + 't strictly specify all of them. Always reconfiguring needed parameters after reset is required for robustness. Note that this also applies when resuming from deep sleep (power-off).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3168>3168</a></td>\n' +
            '<td>Also, ATA/ATAPI standard requires that IDENTIFY DEVICE / IDENTIFY PACKET DEVICE is issued after any configuration parameter is updated or a hardware reset and the result used for further operation. OS driver is required to implement revalidation mechanism to support this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3169>3169</a></td>\n' +
            '<td>Reconfigure transport</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3170>3170</a></td>\n' +
            '<td>For both PATA and SATA, a lot of corners are cut for cheap connectors, cables or controllers and it' + "'" + 's quite common to see high transmission error rate. This can be mitigated by lowering transmission speed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3171>3171</a></td>\n' +
            '<td>The following is a possible scheme Jeff Garzik suggested.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3172>3172</a></td>\n' +
            '<td>If more than $N (3?) transmission errors happen in 15 minutes,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3173>3173</a></td>\n' +
            '<td>    if SATA, decrease SATA PHY speed. if speed cannot be decreased,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3174>3174</a></td>\n' +
            '<td>    decrease UDMA xfer speed. if at UDMA0, switch to PIO4,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3175>3175</a></td>\n' +
            '<td>    decrease PIO xfer speed. if at PIO3, complain, but continue</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3176>3176</a></td>\n' +
            '<td>ata_piix Internals</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3177>3177</a></td>\n' +
            '<td>!Idrivers/ata/ata_piix.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3178>3178</a></td>\n' +
            '<td>sata_sil Internals</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3179>3179</a></td>\n' +
            '<td>!Idrivers/ata/sata_sil.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3180>3180</a></td>\n' +
            '<td>Thanks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3181>3181</a></td>\n' +
            '<td>The bulk of the ATA knowledge comes thanks to long conversations with Andre Hedrick (www.linux-ide.org), and long hours pondering the ATA and SCSI specifications.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3182>3182</a></td>\n' +
            '<td>Thanks to Alan Cox for pointing out similarities between SATA and SCSI, and in general for motivation to hack on libata.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3183>3183</a></td>\n' +
            '<td>libata' + "'" + 's device detection method, ata_pio_devchk, and in general all the early probing was based on extensive study of Hale Landis' + "'" + 's probe/reset code in his ATADRVR driver (www.ata-atapi.com).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3184>3184</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3185>3185</a></td>\n' +
            '<td>The generic Reed-Solomon Library provides encoding, decoding and error correction functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3186>3186</a></td>\n' +
            '<td>Reed-Solomon codes are used in communication and storage applications to ensure data integrity.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3187>3187</a></td>\n' +
            '<td>This documentation is provided for developers who want to utilize the functions provided by the library.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3188>3188</a></td>\n' +
            '<td>Known Bugs And Assumptions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3189>3189</a></td>\n' +
            '<td>None.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3190>3190</a></td>\n' +
            '<td>Usage</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3191>3191</a></td>\n' +
            '<td>This chapter provides examples of how to use the library.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3192>3192</a></td>\n' +
            '<td>Initializing</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3193>3193</a></td>\n' +
            '<td>The init function init_rs returns a pointer to an rs decoder structure, which holds the necessary information for encoding, decoding and error correction with the given polynomial. It either uses an existing matching decoder or creates a new one. On creation all the lookup tables for fast en/decoding are created. The function may take a while, so make sure not to call it in critical code paths.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3194>3194</a></td>\n' +
            '<td>/* the Reed Solomon control structure */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3195>3195</a></td>\n' +
            '<td>static struct rs_control *rs_decoder;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3196>3196</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3197>3197</a></td>\n' +
            '<td>/* Symbolsize is 10 (bits)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3198>3198</a></td>\n' +
            '<td> * Primitive polynomial is x^10+x^3+1</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3199>3199</a></td>\n' +
            '<td> * first consecutive root is 0</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3200>3200</a></td>\n' +
            '<td> * primitive element to generate roots = 1</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3201>3201</a></td>\n' +
            '<td> * generator polynomial degree (number of roots) = 6</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3202>3202</a></td>\n' +
            '<td> */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3203>3203</a></td>\n' +
            '<td>rs_decoder = init_rs (10, 0x409, 0, 1, 6);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3204>3204</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3205>3205</a></td>\n' +
            '<td>Encoding</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3206>3206</a></td>\n' +
            '<td>The encoder calculates the Reed-Solomon code over the given data length and stores the result in the parity buffer. Note that the parity buffer must be initialized before calling the encoder.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3207>3207</a></td>\n' +
            '<td>The expanded data can be inverted on the fly by providing a non-zero inversion mask. The expanded data is XOR' + "'" + 'ed with the mask. This is used e.g. for FLASH ECC, where the all 0xFF is inverted to an all 0x00. The Reed-Solomon code for all 0x00 is all 0x00. The code is inverted before storing to FLASH so it is 0xFF too. This prevents that reading from an erased FLASH results in ECC errors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3208>3208</a></td>\n' +
            '<td>The databytes are expanded to the given symbol size on the fly. There is no support for encoding continuous bitstreams with a symbol size != 8 at the moment. If it is necessary it should be not a big deal to implement such functionality.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3209>3209</a></td>\n' +
            '<td>/* Parity buffer. Size = number of roots */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3210>3210</a></td>\n' +
            '<td>uint16_t par[6];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3211>3211</a></td>\n' +
            '<td>/* Initialize the parity buffer */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3212>3212</a></td>\n' +
            '<td>memset(par, 0, sizeof(par));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3213>3213</a></td>\n' +
            '<td>/* Encode 512 byte in data8. Store parity in buffer par */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3214>3214</a></td>\n' +
            '<td>encode_rs8 (rs_decoder, data8, 512, par, 0);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3215>3215</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3216>3216</a></td>\n' +
            '<td>Decoding</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3217>3217</a></td>\n' +
            '<td>The decoder calculates the syndrome over the given data length and the received parity symbols and corrects errors in the data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3218>3218</a></td>\n' +
            '<td>If a syndrome is available from a hardware decoder then the syndrome calculation is skipped.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3219>3219</a></td>\n' +
            '<td>The correction of the data buffer can be suppressed by providing a correction pattern buffer and an error location buffer to the decoder. The decoder stores the calculated error location and the correction bitmask in the given buffers. This is useful for hardware decoders which use a weird bit ordering scheme.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3220>3220</a></td>\n' +
            '<td>The databytes are expanded to the given symbol size on the fly. There is no support for decoding continuous bitstreams with a symbolsize != 8 at the moment. If it is necessary it should be not a big deal to implement such functionality.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3221>3221</a></td>\n' +
            '<td>Decoding with syndrome calculation, direct data correction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3222>3222</a></td>\n' +
            '<td>/* Parity buffer. Size = number of roots */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3223>3223</a></td>\n' +
            '<td>uint16_t par[6];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3224>3224</a></td>\n' +
            '<td>uint8_t  data[512];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3225>3225</a></td>\n' +
            '<td>int numerr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3226>3226</a></td>\n' +
            '<td>/* Receive data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3227>3227</a></td>\n' +
            '<td>.....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3228>3228</a></td>\n' +
            '<td>/* Receive parity */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3229>3229</a></td>\n' +
            '<td>.....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3230>3230</a></td>\n' +
            '<td>/* Decode 512 byte in data8.*/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3231>3231</a></td>\n' +
            '<td>numerr = decode_rs8 (rs_decoder, data8, par, 512, NULL, 0, NULL, 0, NULL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3232>3232</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3233>3233</a></td>\n' +
            '<td>Decoding with syndrome given by hardware decoder, direct data correction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3234>3234</a></td>\n' +
            '<td>/* Parity buffer. Size = number of roots */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3235>3235</a></td>\n' +
            '<td>uint16_t par[6], syn[6];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3236>3236</a></td>\n' +
            '<td>uint8_t  data[512];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3237>3237</a></td>\n' +
            '<td>int numerr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3238>3238</a></td>\n' +
            '<td>/* Receive data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3239>3239</a></td>\n' +
            '<td>.....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3240>3240</a></td>\n' +
            '<td>/* Receive parity */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3241>3241</a></td>\n' +
            '<td>.....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3242>3242</a></td>\n' +
            '<td>/* Get syndrome from hardware decoder */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3243>3243</a></td>\n' +
            '<td>.....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3244>3244</a></td>\n' +
            '<td>/* Decode 512 byte in data8.*/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3245>3245</a></td>\n' +
            '<td>numerr = decode_rs8 (rs_decoder, data8, par, 512, syn, 0, NULL, 0, NULL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3246>3246</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3247>3247</a></td>\n' +
            '<td>Decoding with syndrome given by hardware decoder, no direct data correction.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3248>3248</a></td>\n' +
            '<td>Note: It' + "'" + 's not necessary to give data and received parity to the decoder.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3249>3249</a></td>\n' +
            '<td>/* Parity buffer. Size = number of roots */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3250>3250</a></td>\n' +
            '<td>uint16_t par[6], syn[6], corr[8];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3251>3251</a></td>\n' +
            '<td>uint8_t  data[512];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3252>3252</a></td>\n' +
            '<td>int numerr, errpos[8];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3253>3253</a></td>\n' +
            '<td>/* Receive data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3254>3254</a></td>\n' +
            '<td>.....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3255>3255</a></td>\n' +
            '<td>/* Receive parity */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3256>3256</a></td>\n' +
            '<td>.....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3257>3257</a></td>\n' +
            '<td>/* Get syndrome from hardware decoder */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3258>3258</a></td>\n' +
            '<td>.....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3259>3259</a></td>\n' +
            '<td>/* Decode 512 byte in data8.*/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3260>3260</a></td>\n' +
            '<td>numerr = decode_rs8 (rs_decoder, NULL, NULL, 512, syn, 0, errpos, 0, corr);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3261>3261</a></td>\n' +
            '<td>for (i = 0; i &lt; numerr; i++) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3262>3262</a></td>\n' +
            '<td>    do_error_correction_in_your_buffer(errpos[i], corr[i]);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3263>3263</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3264>3264</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3265>3265</a></td>\n' +
            '<td>Cleanup</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3266>3266</a></td>\n' +
            '<td>The function free_rs frees the allocated resources, if the caller is the last user of the decoder.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3267>3267</a></td>\n' +
            '<td>/* Release resources */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3268>3268</a></td>\n' +
            '<td>free_rs(rs_decoder);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3269>3269</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3270>3270</a></td>\n' +
            '<td>Structures</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3271>3271</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the structures which are used in the Reed-Solomon Library and are relevant for a developer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3272>3272</a></td>\n' +
            '<td>!Iinclude/linux/rslib.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3273>3273</a></td>\n' +
            '<td>Public Functions Provided</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3274>3274</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the Reed-Solomon functions which are exported.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3275>3275</a></td>\n' +
            '<td>!Elib/reed_solomon/reed_solomon.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3276>3276</a></td>\n' +
            '<td>Credits</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3277>3277</a></td>\n' +
            '<td>The library code for encoding and decoding was written by Phil Karn.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3278>3278</a></td>\n' +
            '<td>        Copyright 2002, Phil Karn, KA9Q</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3279>3279</a></td>\n' +
            '<td>        May be used under the terms of the GNU General Public License (GPL)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3280>3280</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3281>3281</a></td>\n' +
            '<td>The wrapper functions and interfaces are written by Thomas Gleixner.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3282>3282</a></td>\n' +
            '<td>Many users have provided bugfixes, improvements and helping hands for testing. Thanks a lot.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3283>3283</a></td>\n' +
            '<td>The following people have contributed to this document:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3284>3284</a></td>\n' +
            '<td>Thomas Gleixnertglx@linutronix.de</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3285>3285</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3286>3286</a></td>\n' +
            '<td>In March 2001, the National Security Agency (NSA) gave a presentation about Security-Enhanced Linux (SELinux) at the 2.5 Linux Kernel Summit. SELinux is an implementation of flexible and fine-grained nondiscretionary access controls in the Linux kernel, originally implemented as its own particular kernel patch. Several other security projects (e.g. RSBAC, Medusa) have also developed flexible access control architectures for the Linux kernel, and various projects have developed particular access control models for Linux (e.g. LIDS, DTE, SubDomain). Each project has developed and maintained its own kernel patch to support its security needs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3287>3287</a></td>\n' +
            '<td>In response to the NSA presentation, Linus Torvalds made a set of remarks that described a security framework he would be willing to consider for inclusion in the mainstream Linux kernel. He described a general framework that would provide a set of security hooks to control operations on kernel objects and a set of opaque security fields in kernel data structures for maintaining security attributes. This framework could then be used by loadable kernel modules to implement any desired model of security. Linus also suggested the possibility of migrating the Linux capabilities code into such a module.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3288>3288</a></td>\n' +
            '<td>The Linux Security Modules (LSM) project was started by WireX to develop such a framework. LSM is a joint development effort by several security projects, including Immunix, SELinux, SGI and Janus, and several individuals, including Greg Kroah-Hartman and James Morris, to develop a Linux kernel patch that implements this framework. The patch is currently tracking the 2.4 series and is targeted for integration into the 2.5 development series. This technical report provides an overview of the framework and the example capabilities security module provided by the LSM kernel patch.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3289>3289</a></td>\n' +
            '<td>LSM Framework</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3290>3290</a></td>\n' +
            '<td>The LSM kernel patch provides a general kernel framework to support security modules. In particular, the LSM framework is primarily focused on supporting access control modules, although future development is likely to address other security needs such as auditing. By itself, the framework does not provide any additional security; it merely provides the infrastructure to support security modules. The LSM kernel patch also moves most of the capabilities logic into an optional security module, with the system defaulting to the traditional superuser logic. This capabilities module is discussed further in ???.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3291>3291</a></td>\n' +
            '<td>The LSM kernel patch adds security fields to kernel data structures and inserts calls to hook functions at critical points in the kernel code to manage the security fields and to perform access control. It also adds functions for registering and unregistering security modules, and adds a general security system call to support new system calls for security-aware applications.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3292>3292</a></td>\n' +
            '<td>The LSM security fields are simply void* pointers. For process and program execution security information, security fields were added to struct task_struct and struct linux_binprm. For filesystem security information, a security field was added to struct super_block. For pipe, file, and socket security information, security fields were added to struct inode and struct file. For packet and network device security information, security fields were added to struct sk_buff and struct net_device. For System V IPC security information, security fields were added to struct kern_ipc_perm and struct msg_msg; additionally, the definitions for struct msg_msg, struct msg_queue, and struct shmid_kernel were moved to header files (include/linux/msg.h and include/linux/shm.h as appropriate) to allow the security modules to use these definitions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3293>3293</a></td>\n' +
            '<td>Each LSM hook is a function pointer in a global table, security_ops. This table is a security_operations structure as defined by include/linux/security.h. Detailed documentation for each hook is included in this header file. At present, this structure consists of a collection of substructures that group related hooks based on the kernel object (e.g. task, inode, file, sk_buff, etc) as well as some top-level hook function pointers for system operations. This structure is likely to be flattened in the future for performance. The placement of the hook calls in the kernel code is described by the "called:" lines in the per-hook documentation in the header file. The hook calls can also be easily found in the kernel code by looking for the string "security_ops-&gt;".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3294>3294</a></td>\n' +
            '<td>Linus mentioned per-process security hooks in his original remarks as a possible alternative to global security hooks. However, if LSM were to start from the perspective of per-process hooks, then the base framework would have to deal with how to handle operations that involve multiple processes (e.g. kill), since each process might have its own hook for controlling the operation. This would require a general mechanism for composing hooks in the base framework. Additionally, LSM would still need global hooks for operations that have no process context (e.g. network input operations). Consequently, LSM provides global security hooks, but a security module is free to implement per-process hooks (where that makes sense) by storing a security_ops table in each process' + "'" + ' security field and then invoking these per-process hooks from the global hooks. The problem of composition is thus deferred to the module.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3295>3295</a></td>\n' +
            '<td>The global security_ops table is initialized to a set of hook functions provided by a dummy security module that provides traditional superuser logic. A register_security function (in security/security.c) is provided to allow a security module to set security_ops to refer to its own hook functions, and an unregister_security function is provided to revert security_ops to the dummy module hooks. This mechanism is used to set the primary security module, which is responsible for making the final decision for each hook.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3296>3296</a></td>\n' +
            '<td>LSM also provides a simple mechanism for stacking additional security modules with the primary security module. It defines register_security and unregister_security hooks in the security_operations structure and provides mod_reg_security and mod_unreg_security functions that invoke these hooks after performing some sanity checking. A security module can call these functions in order to stack with other modules. However, the actual details of how this stacking is handled are deferred to the module, which can implement these hooks in any way it wishes (including always returning an error if it does not wish to support stacking). In this manner, LSM again defers the problem of composition to the module.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3297>3297</a></td>\n' +
            '<td>Although the LSM hooks are organized into substructures based on kernel object, all of the hooks can be viewed as falling into two major categories: hooks that are used to manage the security fields and hooks that are used to perform access control. Examples of the first category of hooks include the alloc_security and free_security hooks defined for each kernel data structure that has a security field. These hooks are used to allocate and free security structures for kernel objects. The first category of hooks also includes hooks that set information in the security field after allocation, such as the post_lookup hook in struct inode_security_ops. This hook is used to set security information for inodes after successful lookup operations. An example of the second category of hooks is the permission hook in struct inode_security_ops. This hook checks permission when accessing an inode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3298>3298</a></td>\n' +
            '<td>LSM Capabilities Module</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3299>3299</a></td>\n' +
            '<td>The LSM kernel patch moves most of the existing POSIX.1e capabilities logic into an optional security module stored in the file security/capability.c. This change allows users who do not want to use capabilities to omit this code entirely from their kernel, instead using the dummy module for traditional superuser logic or any other module that they desire. This change also allows the developers of the capabilities logic to maintain and enhance their code more freely, without needing to integrate patches back into the base kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3300>3300</a></td>\n' +
            '<td>In addition to moving the capabilities logic, the LSM kernel patch could move the capability-related fields from the kernel data structures into the new security fields managed by the security modules. However, at present, the LSM kernel patch leaves the capability fields in the kernel data structures. In his original remarks, Linus suggested that this might be preferable so that other security modules can be easily stacked with the capabilities module without needing to chain multiple security structures on the security field. It also avoids imposing extra overhead on the capabilities module to manage the security fields. However, the LSM framework could certainly support such a move if it is determined to be desirable, with only a few additional changes described below.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3301>3301</a></td>\n' +
            '<td>At present, the capabilities logic for computing process capabilities on execve and set*uid, checking capabilities for a particular process, saving and checking capabilities for netlink messages, and handling the capget and capset system calls have been moved into the capabilities module. There are still a few locations in the base kernel where capability-related fields are directly examined or modified, but the current version of the LSM patch does allow a security module to completely replace the assignment and testing of capabilities. These few locations would need to be changed if the capability-related fields were moved into the security field. The following is a list of known locations that still perform such direct examination or modification of capability-related fields:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3302>3302</a></td>\n' +
            '<td>    fs/open.c:sys_access</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3303>3303</a></td>\n' +
            '<td>    fs/lockd/host.c:nlm_bind_host</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3304>3304</a></td>\n' +
            '<td>    fs/nfsd/auth.c:nfsd_setuser</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3305>3305</a></td>\n' +
            '<td>    fs/proc/array.c:task_cap</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3306>3306</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3307>3307</a></td>\n' +
            '<td>This document covers the Linux Kernel to Userspace API' + "'" + 's used by video and radio straming devices, including video cameras, analog and digital TV receiver cards, AM/FM receiver cards, streaming capture devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3308>3308</a></td>\n' +
            '<td>It is divided into four parts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3309>3309</a></td>\n' +
            '<td>The first part covers radio, capture, cameras and analog TV devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3310>3310</a></td>\n' +
            '<td>The second part covers the API used for digital TV and Internet reception via one of the several digital tv standards. While it is called as DVB API, in fact it covers several different video standards including DVB-T, DVB-S, DVB-C and ATSC. The API is currently being updated to documment support also for DVB-S2, ISDB-T and ISDB-S.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3311>3311</a></td>\n' +
            '<td>The third part covers the Remote Controller API.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3312>3312</a></td>\n' +
            '<td>The fourth part covers the Media Controller API.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3313>3313</a></td>\n' +
            '<td>For additional information and for the latest development code, see: http://linuxtv.org.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3314>3314</a></td>\n' +
            '<td>For discussing improvements, reporting troubles, sending new drivers, etc, please mail to: Linux Media Mailing List (LMML)..</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3315>3315</a></td>\n' +
            '<td>SUB-V4L2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3316>3316</a></td>\n' +
            '<td>SUB-DVBAPI</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3317>3317</a></td>\n' +
            '<td>2009-2012</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3318>3318</a></td>\n' +
            '<td>Mauro Carvalho Chehab</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3319>3319</a></td>\n' +
            '<td>1.0.0</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3320>3320</a></td>\n' +
            '<td>Initial revision</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3321>3321</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3322>3322</a></td>\n' +
            '<td>SUB-REMOTE_CONTROLLERS</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3323>3323</a></td>\n' +
            '<td>SUB-MEDIA-CONTROLLER</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3324>3324</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3325>3325</a></td>\n' +
            '<td>SUB-GEN-ERRORS</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3326>3326</a></td>\n' +
            '<td>SUB-FDL-APPENDIX</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3327>3327</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3328>3328</a></td>\n' +
            '<td>The generic NAND driver supports almost all NAND and AG-AND based chips and connects them to the Memory Technology Devices (MTD) subsystem of the Linux Kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3329>3329</a></td>\n' +
            '<td>This documentation is provided for developers who want to implement board drivers or filesystem drivers suitable for NAND devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3330>3330</a></td>\n' +
            '<td>Known Bugs And Assumptions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3331>3331</a></td>\n' +
            '<td>None.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3332>3332</a></td>\n' +
            '<td>Documentation hints</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3333>3333</a></td>\n' +
            '<td>The function and structure docs are autogenerated. Each function and struct member has a short description which is marked with an [XXX] identifier. The following chapters explain the meaning of those identifiers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3334>3334</a></td>\n' +
            '<td>Function identifiers [XXX]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3335>3335</a></td>\n' +
            '<td>The functions are marked with [XXX] identifiers in the short comment. The identifiers explain the usage and scope of the functions. Following identifiers are used:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3336>3336</a></td>\n' +
            '<td>    [MTD Interface]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3337>3337</a></td>\n' +
            '<td>     These functions provide the interface to the MTD kernel API. They are not replacable and provide functionality which is complete hardware independent.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3338>3338</a></td>\n' +
            '<td>    [NAND Interface]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3339>3339</a></td>\n' +
            '<td>     These functions are exported and provide the interface to the NAND kernel API.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3340>3340</a></td>\n' +
            '<td>    [GENERIC]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3341>3341</a></td>\n' +
            '<td>     Generic functions are not replacable and provide functionality which is complete hardware independent.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3342>3342</a></td>\n' +
            '<td>    [DEFAULT]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3343>3343</a></td>\n' +
            '<td>     Default functions provide hardware related functionality which is suitable for most of the implementations. These functions can be replaced by the board driver if neccecary. Those functions are called via pointers in the NAND chip description structure. The board driver can set the functions which should be replaced by board dependent functions before calling nand_scan(). If the function pointer is NULL on entry to nand_scan() then the pointer is set to the default function which is suitable for the detected chip type.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3344>3344</a></td>\n' +
            '<td>Struct member identifiers [XXX]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3345>3345</a></td>\n' +
            '<td>The struct members are marked with [XXX] identifiers in the comment. The identifiers explain the usage and scope of the members. Following identifiers are used:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3346>3346</a></td>\n' +
            '<td>    [INTERN]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3347>3347</a></td>\n' +
            '<td>     These members are for NAND driver internal use only and must not be modified. Most of these values are calculated from the chip geometry information which is evaluated during nand_scan().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3348>3348</a></td>\n' +
            '<td>    [REPLACEABLE]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3349>3349</a></td>\n' +
            '<td>     Replaceable members hold hardware related functions which can be provided by the board driver. The board driver can set the functions which should be replaced by board dependent functions before calling nand_scan(). If the function pointer is NULL on entry to nand_scan() then the pointer is set to the default function which is suitable for the detected chip type.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3350>3350</a></td>\n' +
            '<td>    [BOARDSPECIFIC]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3351>3351</a></td>\n' +
            '<td>     Board specific members hold hardware related information which must be provided by the board driver. The board driver must set the function pointers and datafields before calling nand_scan().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3352>3352</a></td>\n' +
            '<td>    [OPTIONAL]</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3353>3353</a></td>\n' +
            '<td>     Optional members can hold information relevant for the board driver. The generic NAND driver code does not use this information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3354>3354</a></td>\n' +
            '<td>Basic board driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3355>3355</a></td>\n' +
            '<td>For most boards it will be sufficient to provide just the basic functions and fill out some really board dependent members in the nand chip description structure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3356>3356</a></td>\n' +
            '<td>Basic defines</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3357>3357</a></td>\n' +
            '<td>At least you have to provide a mtd structure and a storage for the ioremap' + "'" + 'ed chip address. You can allocate the mtd structure using kmalloc or you can allocate it statically. In case of static allocation you have to allocate a nand_chip structure too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3358>3358</a></td>\n' +
            '<td>Kmalloc based example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3359>3359</a></td>\n' +
            '<td>static struct mtd_info *board_mtd;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3360>3360</a></td>\n' +
            '<td>static void __iomem *baseaddr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3361>3361</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3362>3362</a></td>\n' +
            '<td>Static example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3363>3363</a></td>\n' +
            '<td>static struct mtd_info board_mtd;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3364>3364</a></td>\n' +
            '<td>static struct nand_chip board_chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3365>3365</a></td>\n' +
            '<td>static void __iomem *baseaddr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3366>3366</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3367>3367</a></td>\n' +
            '<td>Partition defines</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3368>3368</a></td>\n' +
            '<td>If you want to divide your device into partitions, then define a partitioning scheme suitable to your board.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3369>3369</a></td>\n' +
            '<td>#define NUM_PARTITIONS 2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3370>3370</a></td>\n' +
            '<td>static struct mtd_partition partition_info[] = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3371>3371</a></td>\n' +
            '<td>    { .name = "Flash partition 1",</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3372>3372</a></td>\n' +
            '<td>      .offset =  0,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3373>3373</a></td>\n' +
            '<td>      .size =    8 * 1024 * 1024 },</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3374>3374</a></td>\n' +
            '<td>    { .name = "Flash partition 2",</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3375>3375</a></td>\n' +
            '<td>      .offset =  MTDPART_OFS_NEXT,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3376>3376</a></td>\n' +
            '<td>      .size =    MTDPART_SIZ_FULL },</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3377>3377</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3378>3378</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3379>3379</a></td>\n' +
            '<td>Hardware control function</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3380>3380</a></td>\n' +
            '<td>The hardware control function provides access to the control pins of the NAND chip(s). The access can be done by GPIO pins or by address lines. If you use address lines, make sure that the timing requirements are met.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3381>3381</a></td>\n' +
            '<td>GPIO based example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3382>3382</a></td>\n' +
            '<td>static void board_hwcontrol(struct mtd_info *mtd, int cmd)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3383>3383</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3384>3384</a></td>\n' +
            '<td>    switch(cmd){</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3385>3385</a></td>\n' +
            '<td>        case NAND_CTL_SETCLE: /* Set CLE pin high */ break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3386>3386</a></td>\n' +
            '<td>        case NAND_CTL_CLRCLE: /* Set CLE pin low */ break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3387>3387</a></td>\n' +
            '<td>        case NAND_CTL_SETALE: /* Set ALE pin high */ break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3388>3388</a></td>\n' +
            '<td>        case NAND_CTL_CLRALE: /* Set ALE pin low */ break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3389>3389</a></td>\n' +
            '<td>        case NAND_CTL_SETNCE: /* Set nCE pin low */ break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3390>3390</a></td>\n' +
            '<td>        case NAND_CTL_CLRNCE: /* Set nCE pin high */ break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3391>3391</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3392>3392</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3393>3393</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3394>3394</a></td>\n' +
            '<td>Address lines based example. It' + "'" + 's assumed that the nCE pin is driven by a chip select decoder.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3395>3395</a></td>\n' +
            '<td>static void board_hwcontrol(struct mtd_info *mtd, int cmd)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3396>3396</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3397>3397</a></td>\n' +
            '<td>    struct nand_chip *this = (struct nand_chip *) mtd-&gt;priv;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3398>3398</a></td>\n' +
            '<td>    switch(cmd){</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3399>3399</a></td>\n' +
            '<td>        case NAND_CTL_SETCLE: this-&gt;IO_ADDR_W |= CLE_ADRR_BIT;  break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3400>3400</a></td>\n' +
            '<td>        case NAND_CTL_CLRCLE: this-&gt;IO_ADDR_W &amp;= ~CLE_ADRR_BIT; break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3401>3401</a></td>\n' +
            '<td>        case NAND_CTL_SETALE: this-&gt;IO_ADDR_W |= ALE_ADRR_BIT;  break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3402>3402</a></td>\n' +
            '<td>        case NAND_CTL_CLRALE: this-&gt;IO_ADDR_W &amp;= ~ALE_ADRR_BIT; break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3403>3403</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3404>3404</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3405>3405</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3406>3406</a></td>\n' +
            '<td>Device ready function</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3407>3407</a></td>\n' +
            '<td>If the hardware interface has the ready busy pin of the NAND chip connected to a GPIO or other accessible I/O pin, this function is used to read back the state of the pin. The function has no arguments and should return 0, if the device is busy (R/B pin is low) and 1, if the device is ready (R/B pin is high). If the hardware interface does not give access to the ready busy pin, then the function must not be defined and the function pointer this-&gt;dev_ready is set to NULL.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3408>3408</a></td>\n' +
            '<td>Init function</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3409>3409</a></td>\n' +
            '<td>The init function allocates memory and sets up all the board specific parameters and function pointers. When everything is set up nand_scan() is called. This function tries to detect and identify then chip. If a chip is found all the internal data fields are initialized accordingly. The structure(s) have to be zeroed out first and then filled with the neccecary information about the device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3410>3410</a></td>\n' +
            '<td>static int __init board_init (void)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3411>3411</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3412>3412</a></td>\n' +
            '<td>    struct nand_chip *this;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3413>3413</a></td>\n' +
            '<td>    int err = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3414>3414</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3415>3415</a></td>\n' +
            '<td>    /* Allocate memory for MTD device structure and private data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3416>3416</a></td>\n' +
            '<td>    board_mtd = kzalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3417>3417</a></td>\n' +
            '<td>    if (!board_mtd) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3418>3418</a></td>\n' +
            '<td>        printk ("Unable to allocate NAND MTD device structure.\\n");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3419>3419</a></td>\n' +
            '<td>        err = -ENOMEM;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3420>3420</a></td>\n' +
            '<td>        goto out;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3421>3421</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3422>3422</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3423>3423</a></td>\n' +
            '<td>    /* map physical address */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3424>3424</a></td>\n' +
            '<td>    baseaddr = ioremap(CHIP_PHYSICAL_ADDRESS, 1024);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3425>3425</a></td>\n' +
            '<td>    if (!baseaddr) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3426>3426</a></td>\n' +
            '<td>        printk("Ioremap to access NAND chip failed\\n");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3427>3427</a></td>\n' +
            '<td>        err = -EIO;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3428>3428</a></td>\n' +
            '<td>        goto out_mtd;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3429>3429</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3430>3430</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3431>3431</a></td>\n' +
            '<td>    /* Get pointer to private data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3432>3432</a></td>\n' +
            '<td>    this = (struct nand_chip *) ();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3433>3433</a></td>\n' +
            '<td>    /* Link the private data with the MTD structure */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3434>3434</a></td>\n' +
            '<td>    board_mtd-&gt;priv = this;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3435>3435</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3436>3436</a></td>\n' +
            '<td>    /* Set address of NAND IO lines */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3437>3437</a></td>\n' +
            '<td>    this-&gt;IO_ADDR_R = baseaddr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3438>3438</a></td>\n' +
            '<td>    this-&gt;IO_ADDR_W = baseaddr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3439>3439</a></td>\n' +
            '<td>    /* Reference hardware control function */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3440>3440</a></td>\n' +
            '<td>    this-&gt;hwcontrol = board_hwcontrol;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3441>3441</a></td>\n' +
            '<td>    /* Set command delay time, see datasheet for correct value */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3442>3442</a></td>\n' +
            '<td>    this-&gt;chip_delay = CHIP_DEPENDEND_COMMAND_DELAY;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3443>3443</a></td>\n' +
            '<td>    /* Assign the device ready function, if available */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3444>3444</a></td>\n' +
            '<td>    this-&gt;dev_ready = board_dev_ready;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3445>3445</a></td>\n' +
            '<td>    this-&gt;eccmode = NAND_ECC_SOFT;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3446>3446</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3447>3447</a></td>\n' +
            '<td>    /* Scan to find existence of the device */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3448>3448</a></td>\n' +
            '<td>    if (nand_scan (board_mtd, 1)) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3449>3449</a></td>\n' +
            '<td>        err = -ENXIO;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3450>3450</a></td>\n' +
            '<td>        goto out_ior;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3451>3451</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3452>3452</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3453>3453</a></td>\n' +
            '<td>    add_mtd_partitions(board_mtd, partition_info, NUM_PARTITIONS);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3454>3454</a></td>\n' +
            '<td>    goto out;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3455>3455</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3456>3456</a></td>\n' +
            '<td>out_ior:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3457>3457</a></td>\n' +
            '<td>    iounmap(baseaddr);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3458>3458</a></td>\n' +
            '<td>out_mtd:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3459>3459</a></td>\n' +
            '<td>    kfree (board_mtd);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3460>3460</a></td>\n' +
            '<td>out:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3461>3461</a></td>\n' +
            '<td>    return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3462>3462</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3463>3463</a></td>\n' +
            '<td>module_init(board_init);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3464>3464</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3465>3465</a></td>\n' +
            '<td>Exit function</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3466>3466</a></td>\n' +
            '<td>The exit function is only neccecary if the driver is compiled as a module. It releases all resources which are held by the chip driver and unregisters the partitions in the MTD layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3467>3467</a></td>\n' +
            '<td>#ifdef MODULE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3468>3468</a></td>\n' +
            '<td>static void __exit board_cleanup (void)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3469>3469</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3470>3470</a></td>\n' +
            '<td>    /* Release resources, unregister device */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3471>3471</a></td>\n' +
            '<td>    nand_release (board_mtd);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3472>3472</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3473>3473</a></td>\n' +
            '<td>    /* unmap physical address */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3474>3474</a></td>\n' +
            '<td>    iounmap(baseaddr);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3475>3475</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3476>3476</a></td>\n' +
            '<td>    /* Free the MTD device structure */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3477>3477</a></td>\n' +
            '<td>    kfree (board_mtd);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3478>3478</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3479>3479</a></td>\n' +
            '<td>module_exit(board_cleanup);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3480>3480</a></td>\n' +
            '<td>#endif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3481>3481</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3482>3482</a></td>\n' +
            '<td>Advanced board driver functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3483>3483</a></td>\n' +
            '<td>This chapter describes the advanced functionality of the NAND driver. For a list of functions which can be overridden by the board driver see the documentation of the nand_chip structure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3484>3484</a></td>\n' +
            '<td>Multiple chip control</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3485>3485</a></td>\n' +
            '<td>The nand driver can control chip arrays. Therefore the board driver must provide an own select_chip function. This function must (de)select the requested chip. The function pointer in the nand_chip structure must be set before calling nand_scan(). The maxchip parameter of nand_scan() defines the maximum number of chips to scan for. Make sure that the select_chip function can handle the requested number of chips.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3486>3486</a></td>\n' +
            '<td>The nand driver concatenates the chips to one virtual chip and provides this virtual chip to the MTD layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3487>3487</a></td>\n' +
            '<td>Note: The driver can only handle linear chip arrays of equally sized chips. There is no support for parallel arrays which extend the buswidth.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3488>3488</a></td>\n' +
            '<td>GPIO based example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3489>3489</a></td>\n' +
            '<td>static void board_select_chip (struct mtd_info *mtd, int chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3490>3490</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3491>3491</a></td>\n' +
            '<td>    /* Deselect all chips, set all nCE pins high */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3492>3492</a></td>\n' +
            '<td>    GPIO(BOARD_NAND_NCE) |= 0xff;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3493>3493</a></td>\n' +
            '<td>    if (chip &gt;= 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3494>3494</a></td>\n' +
            '<td>        GPIO(BOARD_NAND_NCE) &amp;= ~ (1 &lt;&lt; chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3495>3495</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3496>3496</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3497>3497</a></td>\n' +
            '<td>Address lines based example. Its assumed that the nCE pins are connected to an address decoder.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3498>3498</a></td>\n' +
            '<td>static void board_select_chip (struct mtd_info *mtd, int chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3499>3499</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3500>3500</a></td>\n' +
            '<td>    struct nand_chip *this = (struct nand_chip *) mtd-&gt;priv;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3501>3501</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3502>3502</a></td>\n' +
            '<td>    /* Deselect all chips */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3503>3503</a></td>\n' +
            '<td>    this-&gt;IO_ADDR_R &amp;= ~BOARD_NAND_ADDR_MASK;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3504>3504</a></td>\n' +
            '<td>    this-&gt;IO_ADDR_W &amp;= ~BOARD_NAND_ADDR_MASK;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3505>3505</a></td>\n' +
            '<td>    switch (chip) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3506>3506</a></td>\n' +
            '<td>    case 0:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3507>3507</a></td>\n' +
            '<td>        this-&gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIP0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3508>3508</a></td>\n' +
            '<td>        this-&gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIP0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3509>3509</a></td>\n' +
            '<td>        break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3510>3510</a></td>\n' +
            '<td>    ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3511>3511</a></td>\n' +
            '<td>    case n:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3512>3512</a></td>\n' +
            '<td>        this-&gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIPn;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3513>3513</a></td>\n' +
            '<td>        this-&gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIPn;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3514>3514</a></td>\n' +
            '<td>        break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3515>3515</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3516>3516</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3517>3517</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3518>3518</a></td>\n' +
            '<td>Hardware ECC support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3519>3519</a></td>\n' +
            '<td>Functions and constants</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3520>3520</a></td>\n' +
            '<td>The nand driver supports three different types of hardware ECC.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3521>3521</a></td>\n' +
            '<td>    NAND_ECC_HW3_256</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3522>3522</a></td>\n' +
            '<td>     Hardware ECC generator providing 3 bytes ECC per 256 byte.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3523>3523</a></td>\n' +
            '<td>    NAND_ECC_HW3_512</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3524>3524</a></td>\n' +
            '<td>     Hardware ECC generator providing 3 bytes ECC per 512 byte.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3525>3525</a></td>\n' +
            '<td>    NAND_ECC_HW6_512</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3526>3526</a></td>\n' +
            '<td>     Hardware ECC generator providing 6 bytes ECC per 512 byte.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3527>3527</a></td>\n' +
            '<td>    NAND_ECC_HW8_512</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3528>3528</a></td>\n' +
            '<td>     Hardware ECC generator providing 6 bytes ECC per 512 byte.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3529>3529</a></td>\n' +
            '<td>If your hardware generator has a different functionality add it at the appropriate place in nand_base.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3530>3530</a></td>\n' +
            '<td>The board driver must provide following functions:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3531>3531</a></td>\n' +
            '<td>    enable_hwecc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3532>3532</a></td>\n' +
            '<td>     This function is called before reading / writing to the chip. Reset or initialize the hardware generator in this function. The function is called with an argument which let you distinguish between read and write operations.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3533>3533</a></td>\n' +
            '<td>    calculate_ecc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3534>3534</a></td>\n' +
            '<td>     This function is called after read / write from / to the chip. Transfer the ECC from the hardware to the buffer. If the option NAND_HWECC_SYNDROME is set then the function is only called on write. See below.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3535>3535</a></td>\n' +
            '<td>    correct_data</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3536>3536</a></td>\n' +
            '<td>     In case of an ECC error this function is called for error detection and correction. Return 1 respectively 2 in case the error can be corrected. If the error is not correctable return -1. If your hardware generator matches the default algorithm of the nand_ecc software generator then use the correction function provided by nand_ecc instead of implementing duplicated code.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3537>3537</a></td>\n' +
            '<td>Hardware ECC with syndrome calculation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3538>3538</a></td>\n' +
            '<td>Many hardware ECC implementations provide Reed-Solomon codes and calculate an error syndrome on read. The syndrome must be converted to a standard Reed-Solomon syndrome before calling the error correction code in the generic Reed-Solomon library.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3539>3539</a></td>\n' +
            '<td>The ECC bytes must be placed immediately after the data bytes in order to make the syndrome generator work. This is contrary to the usual layout used by software ECC. The separation of data and out of band area is not longer possible. The nand driver code handles this layout and the remaining free bytes in the oob area are managed by the autoplacement code. Provide a matching oob-layout in this case. See rts_from4.c and diskonchip.c for implementation reference. In those cases we must also use bad block tables on FLASH, because the ECC layout is interferring with the bad block marker positions. See bad block table support for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3540>3540</a></td>\n' +
            '<td>Bad block table support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3541>3541</a></td>\n' +
            '<td>Most NAND chips mark the bad blocks at a defined position in the spare area. Those blocks must not be erased under any circumstances as the bad block information would be lost. It is possible to check the bad block mark each time when the blocks are accessed by reading the spare area of the first page in the block. This is time consuming so a bad block table is used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3542>3542</a></td>\n' +
            '<td>The nand driver supports various types of bad block tables.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3543>3543</a></td>\n' +
            '<td>    Per device</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3544>3544</a></td>\n' +
            '<td>     The bad block table contains all bad block information of the device which can consist of multiple chips.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3545>3545</a></td>\n' +
            '<td>    Per chip</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3546>3546</a></td>\n' +
            '<td>     A bad block table is used per chip and contains the bad block information for this particular chip.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3547>3547</a></td>\n' +
            '<td>    Fixed offset</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3548>3548</a></td>\n' +
            '<td>     The bad block table is located at a fixed offset in the chip (device). This applies to various DiskOnChip devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3549>3549</a></td>\n' +
            '<td>    Automatic placed</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3550>3550</a></td>\n' +
            '<td>     The bad block table is automatically placed and detected either at the end or at the beginning of a chip (device)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3551>3551</a></td>\n' +
            '<td>    Mirrored tables</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3552>3552</a></td>\n' +
            '<td>     The bad block table is mirrored on the chip (device) to allow updates of the bad block table without data loss.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3553>3553</a></td>\n' +
            '<td>nand_scan() calls the function nand_default_bbt(). nand_default_bbt() selects appropriate default bad block table desriptors depending on the chip information which was retrieved by nand_scan().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3554>3554</a></td>\n' +
            '<td>The standard policy is scanning the device for bad blocks and build a ram based bad block table which allows faster access than always checking the bad block information on the flash chip itself.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3555>3555</a></td>\n' +
            '<td>Flash based tables</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3556>3556</a></td>\n' +
            '<td>It may be desired or neccecary to keep a bad block table in FLASH. For AG-AND chips this is mandatory, as they have no factory marked bad blocks. They have factory marked good blocks. The marker pattern is erased when the block is erased to be reused. So in case of powerloss before writing the pattern back to the chip this block would be lost and added to the bad blocks. Therefore we scan the chip(s) when we detect them the first time for good blocks and store this information in a bad block table before erasing any of the blocks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3557>3557</a></td>\n' +
            '<td>The blocks in which the tables are stored are procteted against accidental access by marking them bad in the memory bad block table. The bad block table management functions are allowed to circumvernt this protection.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3558>3558</a></td>\n' +
            '<td>The simplest way to activate the FLASH based bad block table support is to set the option NAND_BBT_USE_FLASH in the bbt_option field of the nand chip structure before calling nand_scan(). For AG-AND chips is this done by default. This activates the default FLASH based bad block table functionality of the NAND driver. The default bad block table options are</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3559>3559</a></td>\n' +
            '<td>    Store bad block table per chip</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3560>3560</a></td>\n' +
            '<td>    Use 2 bits per block</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3561>3561</a></td>\n' +
            '<td>    Automatic placement at the end of the chip</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3562>3562</a></td>\n' +
            '<td>    Use mirrored tables with version numbers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3563>3563</a></td>\n' +
            '<td>    Reserve 4 blocks at the end of the chip</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3564>3564</a></td>\n' +
            '<td>User defined tables</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3565>3565</a></td>\n' +
            '<td>User defined tables are created by filling out a nand_bbt_descr structure and storing the pointer in the nand_chip structure member bbt_td before calling nand_scan(). If a mirror table is neccecary a second structure must be created and a pointer to this structure must be stored in bbt_md inside the nand_chip structure. If the bbt_md member is set to NULL then only the main table is used and no scan for the mirrored table is performed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3566>3566</a></td>\n' +
            '<td>The most important field in the nand_bbt_descr structure is the options field. The options define most of the table properties. Use the predefined constants from nand.h to define the options.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3567>3567</a></td>\n' +
            '<td>    Number of bits per block</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3568>3568</a></td>\n' +
            '<td>     The supported number of bits is 1, 2, 4, 8.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3569>3569</a></td>\n' +
            '<td>    Table per chip</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3570>3570</a></td>\n' +
            '<td>     Setting the constant NAND_BBT_PERCHIP selects that a bad block table is managed for each chip in a chip array. If this option is not set then a per device bad block table is used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3571>3571</a></td>\n' +
            '<td>    Table location is absolute</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3572>3572</a></td>\n' +
            '<td>     Use the option constant NAND_BBT_ABSPAGE and define the absolute page number where the bad block table starts in the field pages. If you have selected bad block tables per chip and you have a multi chip array then the start page must be given for each chip in the chip array. Note: there is no scan for a table ident pattern performed, so the fields pattern, veroffs, offs, len can be left uninitialized</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3573>3573</a></td>\n' +
            '<td>    Table location is automatically detected</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3574>3574</a></td>\n' +
            '<td>     The table can either be located in the first or the last good blocks of the chip (device). Set NAND_BBT_LASTBLOCK to place the bad block table at the end of the chip (device). The bad block tables are marked and identified by a pattern which is stored in the spare area of the first page in the block which holds the bad block table. Store a pointer to the pattern in the pattern field. Further the length of the pattern has to be stored in len and the offset in the spare area must be given in the offs member of the nand_bbt_descr structure. For mirrored bad block tables different patterns are mandatory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3575>3575</a></td>\n' +
            '<td>    Table creation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3576>3576</a></td>\n' +
            '<td>     Set the option NAND_BBT_CREATE to enable the table creation if no table can be found during the scan. Usually this is done only once if a new chip is found.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3577>3577</a></td>\n' +
            '<td>    Table write support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3578>3578</a></td>\n' +
            '<td>     Set the option NAND_BBT_WRITE to enable the table write support. This allows the update of the bad block table(s) in case a block has to be marked bad due to wear. The MTD interface function block_markbad is calling the update function of the bad block table. If the write support is enabled then the table is updated on FLASH.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3579>3579</a></td>\n' +
            '<td>     Note: Write support should only be enabled for mirrored tables with version control.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3580>3580</a></td>\n' +
            '<td>    Table version control</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3581>3581</a></td>\n' +
            '<td>     Set the option NAND_BBT_VERSION to enable the table version control. It' + "'" + 's highly recommended to enable this for mirrored tables with write support. It makes sure that the risk of losing the bad block table information is reduced to the loss of the information about the one worn out block which should be marked bad. The version is stored in 4 consecutive bytes in the spare area of the device. The position of the version number is defined by the member veroffs in the bad block table descriptor.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3582>3582</a></td>\n' +
            '<td>    Save block contents on write</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3583>3583</a></td>\n' +
            '<td>     In case that the block which holds the bad block table does contain other useful information, set the option NAND_BBT_SAVECONTENT. When the bad block table is written then the whole block is read the bad block table is updated and the block is erased and everything is written back. If this option is not set only the bad block table is written and everything else in the block is ignored and erased.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3584>3584</a></td>\n' +
            '<td>    Number of reserved blocks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3585>3585</a></td>\n' +
            '<td>     For automatic placement some blocks must be reserved for bad block table storage. The number of reserved blocks is defined in the maxblocks member of the babd block table description structure. Reserving 4 blocks for mirrored tables should be a reasonable number. This also limits the number of blocks which are scanned for the bad block table ident pattern.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3586>3586</a></td>\n' +
            '<td>Spare area (auto)placement</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3587>3587</a></td>\n' +
            '<td>The nand driver implements different possibilities for placement of filesystem data in the spare area,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3588>3588</a></td>\n' +
            '<td>    Placement defined by fs driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3589>3589</a></td>\n' +
            '<td>    Automatic placement</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3590>3590</a></td>\n' +
            '<td>The default placement function is automatic placement. The nand driver has built in default placement schemes for the various chiptypes. If due to hardware ECC functionality the default placement does not fit then the board driver can provide a own placement scheme.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3591>3591</a></td>\n' +
            '<td>File system drivers can provide a own placement scheme which is used instead of the default placement scheme.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3592>3592</a></td>\n' +
            '<td>Placement schemes are defined by a nand_oobinfo structure</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3593>3593</a></td>\n' +
            '<td>struct nand_oobinfo {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3594>3594</a></td>\n' +
            '<td>    int useecc;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3595>3595</a></td>\n' +
            '<td>    int eccbytes;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3596>3596</a></td>\n' +
            '<td>    int eccpos[24];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3597>3597</a></td>\n' +
            '<td>    int oobfree[8][2];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3598>3598</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3599>3599</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3600>3600</a></td>\n' +
            '<td>    useecc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3601>3601</a></td>\n' +
            '<td>     The useecc member controls the ecc and placement function. The header file include/mtd/mtd-abi.h contains constants to select ecc and placement. MTD_NANDECC_OFF switches off the ecc complete. This is not recommended and available for testing and diagnosis only. MTD_NANDECC_PLACE selects caller defined placement, MTD_NANDECC_AUTOPLACE selects automatic placement.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3602>3602</a></td>\n' +
            '<td>    eccbytes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3603>3603</a></td>\n' +
            '<td>     The eccbytes member defines the number of ecc bytes per page.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3604>3604</a></td>\n' +
            '<td>    eccpos</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3605>3605</a></td>\n' +
            '<td>     The eccpos array holds the byte offsets in the spare area where the ecc codes are placed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3606>3606</a></td>\n' +
            '<td>    oobfree</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3607>3607</a></td>\n' +
            '<td>     The oobfree array defines the areas in the spare area which can be used for automatic placement. The information is given in the format {offset, size}. offset defines the start of the usable area, size the length in bytes. More than one area can be defined. The list is terminated by an {0, 0} entry.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3608>3608</a></td>\n' +
            '<td>Placement defined by fs driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3609>3609</a></td>\n' +
            '<td>The calling function provides a pointer to a nand_oobinfo structure which defines the ecc placement. For writes the caller must provide a spare area buffer along with the data buffer. The spare area buffer size is (number of pages) * (size of spare area). For reads the buffer size is (number of pages) * ((size of spare area) + (number of ecc steps per page) * sizeof (int)). The driver stores the result of the ecc check for each tuple in the spare buffer. The storage sequence is</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3610>3610</a></td>\n' +
            '<td>&lt;spare data page 0&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3611>3611</a></td>\n' +
            '<td>...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3612>3612</a></td>\n' +
            '<td>&lt;spare data page n&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3613>3613</a></td>\n' +
            '<td>This is a legacy mode used by YAFFS1.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3614>3614</a></td>\n' +
            '<td>If the spare area buffer is NULL then only the ECC placement is done according to the given scheme in the nand_oobinfo structure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3615>3615</a></td>\n' +
            '<td>Automatic placement</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3616>3616</a></td>\n' +
            '<td>Automatic placement uses the built in defaults to place the ecc bytes in the spare area. If filesystem data have to be stored / read into the spare area then the calling function must provide a buffer. The buffer size per page is determined by the oobfree array in the nand_oobinfo structure.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3617>3617</a></td>\n' +
            '<td>If the spare area buffer is NULL then only the ECC placement is done according to the default builtin scheme.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3618>3618</a></td>\n' +
            '<td>Spare area autoplacement default schemes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3619>3619</a></td>\n' +
            '<td>256 byte pagesize</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3620>3620</a></td>\n' +
            '<td>Offset    Content    Comment</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3621>3621</a></td>\n' +
            '<td>0x00    ECC byte 0    Error correction code byte 0</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3622>3622</a></td>\n' +
            '<td>0x01    ECC byte 1    Error correction code byte 1</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3623>3623</a></td>\n' +
            '<td>0x02    ECC byte 2    Error correction code byte 2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3624>3624</a></td>\n' +
            '<td>0x03    Autoplace 0</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3625>3625</a></td>\n' +
            '<td>0x04    Autoplace 1</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3626>3626</a></td>\n' +
            '<td>0x05    Bad block marker    If any bit in this byte is zero, then this block is bad. This applies only to the first page in a block. In the remaining pages this byte is reserved</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3627>3627</a></td>\n' +
            '<td>0x06    Autoplace 2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3628>3628</a></td>\n' +
            '<td>0x07    Autoplace 3</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3629>3629</a></td>\n' +
            '<td>512 byte pagesize</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3630>3630</a></td>\n' +
            '<td>Offset    Content    Comment</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3631>3631</a></td>\n' +
            '<td>0x00    ECC byte 0    Error correction code byte 0 of the lower 256 Byte data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3632>3632</a></td>\n' +
            '<td>0x01    ECC byte 1    Error correction code byte 1 of the lower 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3633>3633</a></td>\n' +
            '<td>0x02    ECC byte 2    Error correction code byte 2 of the lower 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3634>3634</a></td>\n' +
            '<td>0x03    ECC byte 3    Error correction code byte 0 of the upper 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3635>3635</a></td>\n' +
            '<td>0x04    reserved    reserved</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3636>3636</a></td>\n' +
            '<td>0x05    Bad block marker    If any bit in this byte is zero, then this block is bad. This applies only to the first page in a block. In the remaining pages this byte is reserved</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3637>3637</a></td>\n' +
            '<td>0x06    ECC byte 4    Error correction code byte 1 of the upper 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3638>3638</a></td>\n' +
            '<td>0x07    ECC byte 5    Error correction code byte 2 of the upper 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3639>3639</a></td>\n' +
            '<td>0x08 - 0x0F    Autoplace 0 - 7</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3640>3640</a></td>\n' +
            '<td>2048 byte pagesize</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3641>3641</a></td>\n' +
            '<td>Offset    Content    Comment</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3642>3642</a></td>\n' +
            '<td>0x00    Bad block marker    If any bit in this byte is zero, then this block is bad. This applies only to the first page in a block. In the remaining pages this byte is reserved</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3643>3643</a></td>\n' +
            '<td>0x01    Reserved    Reserved</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3644>3644</a></td>\n' +
            '<td>0x02-0x27    Autoplace 0 - 37</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3645>3645</a></td>\n' +
            '<td>0x28    ECC byte 0    Error correction code byte 0 of the first 256 Byte data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3646>3646</a></td>\n' +
            '<td>0x29    ECC byte 1    Error correction code byte 1 of the first 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3647>3647</a></td>\n' +
            '<td>0x2A    ECC byte 2    Error correction code byte 2 of the first 256 Bytes data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3648>3648</a></td>\n' +
            '<td>0x2B    ECC byte 3    Error correction code byte 0 of the second 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3649>3649</a></td>\n' +
            '<td>0x2C    ECC byte 4    Error correction code byte 1 of the second 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3650>3650</a></td>\n' +
            '<td>0x2D    ECC byte 5    Error correction code byte 2 of the second 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3651>3651</a></td>\n' +
            '<td>0x2E    ECC byte 6    Error correction code byte 0 of the third 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3652>3652</a></td>\n' +
            '<td>0x2F    ECC byte 7    Error correction code byte 1 of the third 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3653>3653</a></td>\n' +
            '<td>0x30    ECC byte 8    Error correction code byte 2 of the third 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3654>3654</a></td>\n' +
            '<td>0x31    ECC byte 9    Error correction code byte 0 of the fourth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3655>3655</a></td>\n' +
            '<td>0x32    ECC byte 10    Error correction code byte 1 of the fourth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3656>3656</a></td>\n' +
            '<td>0x33    ECC byte 11    Error correction code byte 2 of the fourth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3657>3657</a></td>\n' +
            '<td>0x34    ECC byte 12    Error correction code byte 0 of the fifth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3658>3658</a></td>\n' +
            '<td>0x35    ECC byte 13    Error correction code byte 1 of the fifth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3659>3659</a></td>\n' +
            '<td>0x36    ECC byte 14    Error correction code byte 2 of the fifth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3660>3660</a></td>\n' +
            '<td>0x37    ECC byte 15    Error correction code byte 0 of the sixt 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3661>3661</a></td>\n' +
            '<td>0x38    ECC byte 16    Error correction code byte 1 of the sixt 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3662>3662</a></td>\n' +
            '<td>0x39    ECC byte 17    Error correction code byte 2 of the sixt 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3663>3663</a></td>\n' +
            '<td>0x3A    ECC byte 18    Error correction code byte 0 of the seventh 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3664>3664</a></td>\n' +
            '<td>0x3B    ECC byte 19    Error correction code byte 1 of the seventh 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3665>3665</a></td>\n' +
            '<td>0x3C    ECC byte 20    Error correction code byte 2 of the seventh 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3666>3666</a></td>\n' +
            '<td>0x3D    ECC byte 21    Error correction code byte 0 of the eighth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3667>3667</a></td>\n' +
            '<td>0x3E    ECC byte 22    Error correction code byte 1 of the eighth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3668>3668</a></td>\n' +
            '<td>0x3F    ECC byte 23    Error correction code byte 2 of the eighth 256 Bytes of data in this page</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3669>3669</a></td>\n' +
            '<td>Filesystem support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3670>3670</a></td>\n' +
            '<td>The NAND driver provides all neccecary functions for a filesystem via the MTD interface.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3671>3671</a></td>\n' +
            '<td>Filesystems must be aware of the NAND pecularities and restrictions. One major restrictions of NAND Flash is, that you cannot write as often as you want to a page. The consecutive writes to a page, before erasing it again, are restricted to 1-3 writes, depending on the manufacturers specifications. This applies similar to the spare area.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3672>3672</a></td>\n' +
            '<td>Therefore NAND aware filesystems must either write in page size chunks or hold a writebuffer to collect smaller writes until they sum up to pagesize. Available NAND aware filesystems: JFFS2, YAFFS.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3673>3673</a></td>\n' +
            '<td>The spare area usage to store filesystem data is controlled by the spare area placement functionality which is described in one of the earlier chapters.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3674>3674</a></td>\n' +
            '<td>Tools</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3675>3675</a></td>\n' +
            '<td>The MTD project provides a couple of helpful tools to handle NAND Flash.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3676>3676</a></td>\n' +
            '<td>    flasherase, flasheraseall: Erase and format FLASH partitions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3677>3677</a></td>\n' +
            '<td>    nandwrite: write filesystem images to NAND FLASH</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3678>3678</a></td>\n' +
            '<td>    nanddump: dump the contents of a NAND FLASH partitions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3679>3679</a></td>\n' +
            '<td>These tools are aware of the NAND restrictions. Please use those tools instead of complaining about errors which are caused by non NAND aware access methods.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3680>3680</a></td>\n' +
            '<td>Constants</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3681>3681</a></td>\n' +
            '<td>This chapter describes the constants which might be relevant for a driver developer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3682>3682</a></td>\n' +
            '<td>Chip option constants</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3683>3683</a></td>\n' +
            '<td>Constants for chip id table</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3684>3684</a></td>\n' +
            '<td>These constants are defined in nand.h. They are ored together to describe the chip functionality.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3685>3685</a></td>\n' +
            '<td>/* Buswitdh is 16 bit */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3686>3686</a></td>\n' +
            '<td>#define NAND_BUSWIDTH_16    0x00000002</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3687>3687</a></td>\n' +
            '<td>/* Device supports partial programming without padding */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3688>3688</a></td>\n' +
            '<td>#define NAND_NO_PADDING     0x00000004</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3689>3689</a></td>\n' +
            '<td>/* Chip has cache program function */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3690>3690</a></td>\n' +
            '<td>#define NAND_CACHEPRG       0x00000008</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3691>3691</a></td>\n' +
            '<td>/* Chip has copy back function */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3692>3692</a></td>\n' +
            '<td>#define NAND_COPYBACK       0x00000010</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3693>3693</a></td>\n' +
            '<td>/* AND Chip which has 4 banks and a confusing page / block</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3694>3694</a></td>\n' +
            '<td> * assignment. See Renesas datasheet for further information */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3695>3695</a></td>\n' +
            '<td>#define NAND_IS_AND     0x00000020</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3696>3696</a></td>\n' +
            '<td>/* Chip has a array of 4 pages which can be read without</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3697>3697</a></td>\n' +
            '<td> * additional ready /busy waits */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3698>3698</a></td>\n' +
            '<td>#define NAND_4PAGE_ARRAY    0x00000040</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3699>3699</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3700>3700</a></td>\n' +
            '<td>Constants for runtime options</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3701>3701</a></td>\n' +
            '<td>These constants are defined in nand.h. They are ored together to describe the functionality.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3702>3702</a></td>\n' +
            '<td>/* The hw ecc generator provides a syndrome instead a ecc value on read</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3703>3703</a></td>\n' +
            '<td> * This can only work if we have the ecc bytes directly behind the</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3704>3704</a></td>\n' +
            '<td> * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3705>3705</a></td>\n' +
            '<td>#define NAND_HWECC_SYNDROME 0x00020000</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3706>3706</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3707>3707</a></td>\n' +
            '<td>ECC selection constants</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3708>3708</a></td>\n' +
            '<td>Use these constants to select the ECC algorithm.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3709>3709</a></td>\n' +
            '<td>/* No ECC. Usage is not recommended ! */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3710>3710</a></td>\n' +
            '<td>#define NAND_ECC_NONE       0</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3711>3711</a></td>\n' +
            '<td>/* Software ECC 3 byte ECC per 256 Byte data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3712>3712</a></td>\n' +
            '<td>#define NAND_ECC_SOFT       1</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3713>3713</a></td>\n' +
            '<td>/* Hardware ECC 3 byte ECC per 256 Byte data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3714>3714</a></td>\n' +
            '<td>#define NAND_ECC_HW3_256    2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3715>3715</a></td>\n' +
            '<td>/* Hardware ECC 3 byte ECC per 512 Byte data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3716>3716</a></td>\n' +
            '<td>#define NAND_ECC_HW3_512    3</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3717>3717</a></td>\n' +
            '<td>/* Hardware ECC 6 byte ECC per 512 Byte data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3718>3718</a></td>\n' +
            '<td>#define NAND_ECC_HW6_512    4</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3719>3719</a></td>\n' +
            '<td>/* Hardware ECC 6 byte ECC per 512 Byte data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3720>3720</a></td>\n' +
            '<td>#define NAND_ECC_HW8_512    6</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3721>3721</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3722>3722</a></td>\n' +
            '<td>Hardware control related constants</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3723>3723</a></td>\n' +
            '<td>These constants describe the requested hardware access function when the boardspecific hardware control function is called</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3724>3724</a></td>\n' +
            '<td>/* Select the chip by setting nCE to low */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3725>3725</a></td>\n' +
            '<td>#define NAND_CTL_SETNCE     1</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3726>3726</a></td>\n' +
            '<td>/* Deselect the chip by setting nCE to high */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3727>3727</a></td>\n' +
            '<td>#define NAND_CTL_CLRNCE     2</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3728>3728</a></td>\n' +
            '<td>/* Select the command latch by setting CLE to high */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3729>3729</a></td>\n' +
            '<td>#define NAND_CTL_SETCLE     3</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3730>3730</a></td>\n' +
            '<td>/* Deselect the command latch by setting CLE to low */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3731>3731</a></td>\n' +
            '<td>#define NAND_CTL_CLRCLE     4</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3732>3732</a></td>\n' +
            '<td>/* Select the address latch by setting ALE to high */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3733>3733</a></td>\n' +
            '<td>#define NAND_CTL_SETALE     5</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3734>3734</a></td>\n' +
            '<td>/* Deselect the address latch by setting ALE to low */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3735>3735</a></td>\n' +
            '<td>#define NAND_CTL_CLRALE     6</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3736>3736</a></td>\n' +
            '<td>/* Set write protection by setting WP to high. Not used! */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3737>3737</a></td>\n' +
            '<td>#define NAND_CTL_SETWP      7</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3738>3738</a></td>\n' +
            '<td>/* Clear write protection by setting WP to low. Not used! */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3739>3739</a></td>\n' +
            '<td>#define NAND_CTL_CLRWP      8</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3740>3740</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3741>3741</a></td>\n' +
            '<td>Bad block table related constants</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3742>3742</a></td>\n' +
            '<td>These constants describe the options used for bad block table descriptors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3743>3743</a></td>\n' +
            '<td>/* Options for the bad block table descriptors */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3744>3744</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3745>3745</a></td>\n' +
            '<td>/* The number of bits used per block in the bbt on the device */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3746>3746</a></td>\n' +
            '<td>#define NAND_BBT_NRBITS_MSK 0x0000000F</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3747>3747</a></td>\n' +
            '<td>#define NAND_BBT_1BIT       0x00000001</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3748>3748</a></td>\n' +
            '<td>#define NAND_BBT_2BIT       0x00000002</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3749>3749</a></td>\n' +
            '<td>#define NAND_BBT_4BIT       0x00000004</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3750>3750</a></td>\n' +
            '<td>#define NAND_BBT_8BIT       0x00000008</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3751>3751</a></td>\n' +
            '<td>/* The bad block table is in the last good block of the device */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3752>3752</a></td>\n' +
            '<td>#define NAND_BBT_LASTBLOCK  0x00000010</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3753>3753</a></td>\n' +
            '<td>/* The bbt is at the given page, else we must scan for the bbt */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3754>3754</a></td>\n' +
            '<td>#define NAND_BBT_ABSPAGE    0x00000020</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3755>3755</a></td>\n' +
            '<td>/* bbt is stored per chip on multichip devices */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3756>3756</a></td>\n' +
            '<td>#define NAND_BBT_PERCHIP    0x00000080</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3757>3757</a></td>\n' +
            '<td>/* bbt has a version counter at offset veroffs */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3758>3758</a></td>\n' +
            '<td>#define NAND_BBT_VERSION    0x00000100</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3759>3759</a></td>\n' +
            '<td>/* Create a bbt if none axists */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3760>3760</a></td>\n' +
            '<td>#define NAND_BBT_CREATE     0x00000200</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3761>3761</a></td>\n' +
            '<td>/* Write bbt if neccecary */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3762>3762</a></td>\n' +
            '<td>#define NAND_BBT_WRITE      0x00001000</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3763>3763</a></td>\n' +
            '<td>/* Read and write back block contents when writing bbt */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3764>3764</a></td>\n' +
            '<td>#define NAND_BBT_SAVECONTENT    0x00002000</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3765>3765</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3766>3766</a></td>\n' +
            '<td>Structures</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3767>3767</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the structures which are used in the NAND driver and might be relevant for a driver developer. Each struct member has a short description which is marked with an [XXX] identifier. See the chapter "Documentation hints" for an explanation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3768>3768</a></td>\n' +
            '<td>!Iinclude/linux/mtd/nand.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3769>3769</a></td>\n' +
            '<td>Public Functions Provided</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3770>3770</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the NAND kernel API functions which are exported. Each function has a short description which is marked with an [XXX] identifier. See the chapter "Documentation hints" for an explanation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3771>3771</a></td>\n' +
            '<td>!Edrivers/mtd/nand/nand_base.c !Edrivers/mtd/nand/nand_bbt.c !Edrivers/mtd/nand/nand_ecc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3772>3772</a></td>\n' +
            '<td>Internal Functions Provided</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3773>3773</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the NAND driver internal functions. Each function has a short description which is marked with an [XXX] identifier. See the chapter "Documentation hints" for an explanation. The functions marked with [DEFAULT] might be relevant for a board driver developer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3774>3774</a></td>\n' +
            '<td>!Idrivers/mtd/nand/nand_base.c !Idrivers/mtd/nand/nand_bbt.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3775>3775</a></td>\n' +
            '<td>Credits</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3776>3776</a></td>\n' +
            '<td>The following people have contributed to the NAND driver:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3777>3777</a></td>\n' +
            '<td>1.    Steven J. Hillsjhill@realitydiluted.com</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3778>3778</a></td>\n' +
            '<td>2.    David Woodhousedwmw2@infradead.org</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3779>3779</a></td>\n' +
            '<td>3.    Thomas Gleixnertglx@linutronix.de</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3780>3780</a></td>\n' +
            '<td>A lot of users have provided bugfixes, improvements and helping hands for testing. Thanks a lot.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3781>3781</a></td>\n' +
            '<td>The following people have contributed to this document:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3782>3782</a></td>\n' +
            '<td>1.    Thomas Gleixnertglx@linutronix.de</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3783>3783</a></td>\n' +
            '<td>Linux Networking</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3784>3784</a></td>\n' +
            '<td>Networking Base Types</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3785>3785</a></td>\n' +
            '<td>!Iinclude/linux/net.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3786>3786</a></td>\n' +
            '<td>Socket Buffer Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3787>3787</a></td>\n' +
            '<td>!Iinclude/linux/skbuff.h !Iinclude/net/sock.h !Enet/socket.c !Enet/core/skbuff.c !Enet/core/sock.c !Enet/core/datagram.c !Enet/core/stream.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3788>3788</a></td>\n' +
            '<td>Socket Filter</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3789>3789</a></td>\n' +
            '<td>!Enet/core/filter.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3790>3790</a></td>\n' +
            '<td>Generic Network Statistics</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3791>3791</a></td>\n' +
            '<td>!Iinclude/uapi/linux/gen_stats.h !Enet/core/gen_stats.c !Enet/core/gen_estimator.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3792>3792</a></td>\n' +
            '<td>SUN RPC subsystem</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3793>3793</a></td>\n' +
            '<td>!Enet/sunrpc/xdr.c !Enet/sunrpc/svc_xprt.c !Enet/sunrpc/xprt.c !Enet/sunrpc/sched.c !Enet/sunrpc/socklib.c !Enet/sunrpc/stats.c !Enet/sunrpc/rpc_pipe.c !Enet/sunrpc/rpcb_clnt.c !Enet/sunrpc/clnt.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3794>3794</a></td>\n' +
            '<td>WiMAX</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3795>3795</a></td>\n' +
            '<td>!Enet/wimax/op-msg.c !Enet/wimax/op-reset.c !Enet/wimax/op-rfkill.c !Enet/wimax/stack.c !Iinclude/net/wimax.h !Iinclude/uapi/linux/wimax.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3796>3796</a></td>\n' +
            '<td>Network device support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3797>3797</a></td>\n' +
            '<td>Driver Support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3798>3798</a></td>\n' +
            '<td>!Enet/core/dev.c !Enet/ethernet/eth.c !Enet/sched/sch_generic.c !Iinclude/linux/etherdevice.h !Iinclude/linux/netdevice.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3799>3799</a></td>\n' +
            '<td>PHY Support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3800>3800</a></td>\n' +
            '<td>!Edrivers/net/phy/phy.c !Idrivers/net/phy/phy.c !Edrivers/net/phy/phy_device.c !Idrivers/net/phy/phy_device.c !Edrivers/net/phy/mdio_bus.c !Idrivers/net/phy/mdio_bus.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3801>3801</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3802>3802</a></td>\n' +
            '<td>RapidIO is a high speed switched fabric interconnect with features aimed at the embedded market. RapidIO provides support for memory-mapped I/O as well as message-based transactions over the switched fabric network. RapidIO has a standardized discovery mechanism not unlike the PCI bus standard that allows simple detection of devices in a network.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3803>3803</a></td>\n' +
            '<td>This documentation is provided for developers intending to support RapidIO on new architectures, write new drivers, or to understand the subsystem internals.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3804>3804</a></td>\n' +
            '<td>Known Bugs and Limitations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3805>3805</a></td>\n' +
            '<td>Bugs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3806>3806</a></td>\n' +
            '<td>None. ;)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3807>3807</a></td>\n' +
            '<td>Limitations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3808>3808</a></td>\n' +
            '<td>1.    Access/management of RapidIO memory regions is not supported</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3809>3809</a></td>\n' +
            '<td>2.    Multiple host enumeration is not supported</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3810>3810</a></td>\n' +
            '<td>RapidIO driver interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3811>3811</a></td>\n' +
            '<td>Drivers are provided a set of calls in order to interface with the subsystem to gather info on devices, request/map memory region resources, and manage mailboxes/doorbells.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3812>3812</a></td>\n' +
            '<td>Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3813>3813</a></td>\n' +
            '<td>!Iinclude/linux/rio_drv.h !Edrivers/rapidio/rio-driver.c !Edrivers/rapidio/rio.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3814>3814</a></td>\n' +
            '<td>Internals</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3815>3815</a></td>\n' +
            '<td>This chapter contains the autogenerated documentation of the RapidIO subsystem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3816>3816</a></td>\n' +
            '<td>Structures</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3817>3817</a></td>\n' +
            '<td>!Iinclude/linux/rio.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3818>3818</a></td>\n' +
            '<td>Enumeration and Discovery</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3819>3819</a></td>\n' +
            '<td>!Idrivers/rapidio/rio-scan.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3820>3820</a></td>\n' +
            '<td>Driver functionality</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3821>3821</a></td>\n' +
            '<td>!Idrivers/rapidio/rio.c !Idrivers/rapidio/rio-access.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3822>3822</a></td>\n' +
            '<td>Device model support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3823>3823</a></td>\n' +
            '<td>!Idrivers/rapidio/rio-driver.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3824>3824</a></td>\n' +
            '<td>Sysfs support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3825>3825</a></td>\n' +
            '<td>!Idrivers/rapidio/rio-sysfs.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3826>3826</a></td>\n' +
            '<td>PPC32 support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3827>3827</a></td>\n' +
            '<td>!Iarch/powerpc/sysdev/fsl_rio.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3828>3828</a></td>\n' +
            '<td>Credits</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3829>3829</a></td>\n' +
            '<td>The following people have contributed to the RapidIO subsystem directly or indirectly:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3830>3830</a></td>\n' +
            '<td>1.    Matt Portermporter@kernel.crashing.org</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3831>3831</a></td>\n' +
            '<td>2.    Randy Vinsonrvinson@mvista.com</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3832>3832</a></td>\n' +
            '<td>3.    Dan Malekdan@embeddedalley.com</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3833>3833</a></td>\n' +
            '<td>The following people have contributed to this document:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3834>3834</a></td>\n' +
            '<td>1.    Matt Portermporter@kernel.crashing.org</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3835>3835</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3836>3836</a></td>\n' +
            '<td>This framework is designed to provide a standard kernel interface to control voltage and current regulators.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3837>3837</a></td>\n' +
            '<td>The intention is to allow systems to dynamically control regulator power output in order to save power and prolong battery life. This applies to both voltage regulators (where voltage output is controllable) and current sinks (where current limit is controllable).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3838>3838</a></td>\n' +
            '<td>Note that additional (and currently more complete) documentation is available in the Linux kernel source under Documentation/power/regulator.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3839>3839</a></td>\n' +
            '<td>Glossary</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3840>3840</a></td>\n' +
            '<td>The regulator API uses a number of terms which may not be familiar:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3841>3841</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3842>3842</a></td>\n' +
            '<td>Regulator</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3843>3843</a></td>\n' +
            '<td>Electronic device that supplies power to other devices. Most regulators can enable and disable their output and some can also control their output voltage or current.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3844>3844</a></td>\n' +
            '<td>Consumer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3845>3845</a></td>\n' +
            '<td>Electronic device which consumes power provided by a regulator. These may either be static, requiring only a fixed supply, or dynamic, requiring active management of the regulator at runtime.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3846>3846</a></td>\n' +
            '<td>Power Domain</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3847>3847</a></td>\n' +
            '<td>The electronic circuit supplied by a given regulator, including the regulator and all consumer devices. The configuration of the regulator is shared between all the components in the circuit.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3848>3848</a></td>\n' +
            '<td>Power Management Integrated Circuit</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3849>3849</a></td>\n' +
            '<td>PMIC</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3850>3850</a></td>\n' +
            '<td>An IC which contains numerous regulators and often also other subsystems. In an embedded system the primary PMIC is often equivalent to a combination of the PSU and southbridge in a desktop system.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3851>3851</a></td>\n' +
            '<td>Consumer driver interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3852>3852</a></td>\n' +
            '<td>This offers a similar API to the kernel clock framework. Consumer drivers use get and put operations to acquire and release regulators. Functions are provided to enable and disable the reguator and to get and set the runtime parameters of the regulator.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3853>3853</a></td>\n' +
            '<td>When requesting regulators consumers use symbolic names for their supplies, such as "Vcc", which are mapped into actual regulator devices by the machine interface.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3854>3854</a></td>\n' +
            '<td>A stub version of this API is provided when the regulator framework is not in use in order to minimise the need to use ifdefs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3855>3855</a></td>\n' +
            '<td>Enabling and disabling</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3856>3856</a></td>\n' +
            '<td>The regulator API provides reference counted enabling and disabling of regulators. Consumer devices use the regulator_enable and regulator_disable</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3857>3857</a></td>\n' +
            '<td>      functions to enable and disable regulators. Calls to the two functions must be balanced.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3858>3858</a></td>\n' +
            '<td>Note that since multiple consumers may be using a regulator and machine constraints may not allow the regulator to be disabled there is no guarantee that calling regulator_disable will actually cause the supply provided by the regulator to be disabled. Consumer drivers should assume that the regulator may be enabled at all times.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3859>3859</a></td>\n' +
            '<td>Configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3860>3860</a></td>\n' +
            '<td>Some consumer devices may need to be able to dynamically configure their supplies. For example, MMC drivers may need to select the correct operating voltage for their cards. This may be done while the regulator is enabled or disabled.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3861>3861</a></td>\n' +
            '<td>The regulator_set_voltage</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3862>3862</a></td>\n' +
            '<td>      and regulator_set_current_limit</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3863>3863</a></td>\n' +
            '<td>      functions provide the primary interface for this. Both take ranges of voltages and currents, supporting drivers that do not require a specific value (eg, CPU frequency scaling normally permits the CPU to use a wider range of supply voltages at lower frequencies but does not require that the supply voltage be lowered). Where an exact value is required both minimum and maximum values should be identical.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3864>3864</a></td>\n' +
            '<td>Callbacks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3865>3865</a></td>\n' +
            '<td>Callbacks may also be registered for events such as regulation failures.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3866>3866</a></td>\n' +
            '<td>Regulator driver interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3867>3867</a></td>\n' +
            '<td>Drivers for regulator chips register the regulators with the regulator core, providing operations structures to the core. A notifier interface allows error conditions to be reported to the core.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3868>3868</a></td>\n' +
            '<td>Registration should be triggered by explicit setup done by the platform, supplying a struct regulator_init_data for the regulator containing constraint and supply information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3869>3869</a></td>\n' +
            '<td>Machine interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3870>3870</a></td>\n' +
            '<td>This interface provides a way to define how regulators are connected to consumers on a given system and what the valid operating parameters are for the system.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3871>3871</a></td>\n' +
            '<td>Supplies</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3872>3872</a></td>\n' +
            '<td>Regulator supplies are specified using struct regulator_consumer_supply. This is done at driver registration time as part of the machine constraints.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3873>3873</a></td>\n' +
            '<td>Constraints</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3874>3874</a></td>\n' +
            '<td>As well as defining the connections the machine interface also provides constraints defining the operations that clients are allowed to perform and the parameters that may be set. This is required since generally regulator devices will offer more flexibility than it is safe to use on a given system, for example supporting higher supply voltages than the consumers are rated for.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3875>3875</a></td>\n' +
            '<td>This is done at driver registration time by providing a struct regulation_constraints.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3876>3876</a></td>\n' +
            '<td>The constraints may also specify an initial configuration for the regulator in the constraints, which is particularly useful for use with static consumers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3877>3877</a></td>\n' +
            '<td>API reference</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3878>3878</a></td>\n' +
            '<td>Due to limitations of the kernel documentation framework and the existing layout of the source code the entire regulator API is documented here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3879>3879</a></td>\n' +
            '<td>!Iinclude/linux/regulator/consumer.h !Iinclude/linux/regulator/machine.h !Iinclude/linux/regulator/driver.h !Edrivers/regulator/core.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3880>3880</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3881>3881</a></td>\n' +
            '<td>This document describes the interfaces available for device drivers that drive s390 based channel attached I/O devices. This includes interfaces for interaction with the hardware and interfaces for interacting with the common driver core. Those interfaces are provided by the s390 common I/O layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3882>3882</a></td>\n' +
            '<td>The document assumes a familarity with the technical terms associated with the s390 channel I/O architecture. For a description of this architecture, please refer to the "z/Architecture: Principles of Operation", IBM publication no. SA22-7832.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3883>3883</a></td>\n' +
            '<td>While most I/O devices on a s390 system are typically driven through the channel I/O mechanism described here, there are various other methods (like the diag interface). These are out of the scope of this document.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3884>3884</a></td>\n' +
            '<td>Some additional information can also be found in the kernel source under Documentation/s390/driver-model.txt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3885>3885</a></td>\n' +
            '<td>The ccw bus</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3886>3886</a></td>\n' +
            '<td>The ccw bus typically contains the majority of devices available to a s390 system. Named after the channel command word (ccw), the basic command structure used to address its devices, the ccw bus contains so-called channel attached devices. They are addressed via I/O subchannels, visible on the css bus. A device driver for channel-attached devices, however, will never interact with the subchannel directly, but only via the I/O device on the ccw bus, the ccw device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3887>3887</a></td>\n' +
            '<td>I/O functions for channel-attached devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3888>3888</a></td>\n' +
            '<td>Some hardware structures have been translated into C structures for use by the common I/O layer and device drivers. For more information on the hardware structures represented here, please consult the Principles of Operation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3889>3889</a></td>\n' +
            '<td>!Iarch/s390/include/asm/cio.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3890>3890</a></td>\n' +
            '<td>ccw devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3891>3891</a></td>\n' +
            '<td>Devices that want to initiate channel I/O need to attach to the ccw bus. Interaction with the driver core is done via the common I/O layer, which provides the abstractions of ccw devices and ccw device drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3892>3892</a></td>\n' +
            '<td>The functions that initiate or terminate channel I/O all act upon a ccw device structure. Device drivers must not bypass those functions or strange side effects may happen.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3893>3893</a></td>\n' +
            '<td>!Iarch/s390/include/asm/ccwdev.h !Edrivers/s390/cio/device.c !Edrivers/s390/cio/device_ops.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3894>3894</a></td>\n' +
            '<td>The channel-measurement facility</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3895>3895</a></td>\n' +
            '<td>The channel-measurement facility provides a means to collect measurement data which is made available by the channel subsystem for each channel attached device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3896>3896</a></td>\n' +
            '<td>!Iarch/s390/include/asm/cmb.h !Edrivers/s390/cio/cmf.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3897>3897</a></td>\n' +
            '<td>The ccwgroup bus</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3898>3898</a></td>\n' +
            '<td>The ccwgroup bus only contains artificial devices, created by the user. Many networking devices (e.g. qeth) are in fact composed of several ccw devices (like read, write and data channel for qeth). The ccwgroup bus provides a mechanism to create a meta-device which contains those ccw devices as slave devices and can be associated with the netdevice.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3899>3899</a></td>\n' +
            '<td>ccw group devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3900>3900</a></td>\n' +
            '<td>!Iarch/s390/include/asm/ccwgroup.h !Edrivers/s390/cio/ccwgroup.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3901>3901</a></td>\n' +
            '<td>Generic interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3902>3902</a></td>\n' +
            '<td>Some interfaces are available to other drivers that do not necessarily have anything to do with the busses described above, but still are indirectly using basic infrastructure in the common I/O layer. One example is the support for adapter interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3903>3903</a></td>\n' +
            '<td>!Edrivers/s390/cio/airq.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3904>3904</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3905>3905</a></td>\n' +
            '<td>Protocol vs bus</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3906>3906</a></td>\n' +
            '<td>Once upon a time, the Small Computer Systems Interface defined both a parallel I/O bus and a data protocol to connect a wide variety of peripherals (disk drives, tape drives, modems, printers, scanners, optical drives, test equipment, and medical devices) to a host computer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3907>3907</a></td>\n' +
            '<td>Although the old parallel (fast/wide/ultra) SCSI bus has largely fallen out of use, the SCSI command set is more widely used than ever to communicate with devices over a number of different busses.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3908>3908</a></td>\n' +
            '<td>The SCSI protocol is a big-endian peer-to-peer packet based protocol. SCSI commands are 6, 10, 12, or 16 bytes long, often followed by an associated data payload.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3909>3909</a></td>\n' +
            '<td>SCSI commands can be transported over just about any kind of bus, and are the default protocol for storage devices attached to USB, SATA, SAS, Fibre Channel, FireWire, and ATAPI devices. SCSI packets are also commonly exchanged over Infiniband, I20, TCP/IP (iSCSI), even Parallel ports.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3910>3910</a></td>\n' +
            '<td>Design of the Linux SCSI subsystem</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3911>3911</a></td>\n' +
            '<td>The SCSI subsystem uses a three layer design, with upper, mid, and low layers. Every operation involving the SCSI subsystem (such as reading a sector from a disk) uses one driver at each of the 3 levels: one upper layer driver, one lower layer driver, and the SCSI midlayer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3912>3912</a></td>\n' +
            '<td>The SCSI upper layer provides the interface between userspace and the kernel, in the form of block and char device nodes for I/O and ioctl(). The SCSI lower layer contains drivers for specific hardware devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3913>3913</a></td>\n' +
            '<td>In between is the SCSI mid-layer, analogous to a network routing layer such as the IPv4 stack. The SCSI mid-layer routes a packet based data protocol between the upper layer' + "'" + 's /dev nodes and the corresponding devices in the lower layer. It manages command queues, provides error handling and power management functions, and responds to ioctl() requests.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3914>3914</a></td>\n' +
            '<td>SCSI upper layer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3915>3915</a></td>\n' +
            '<td>The upper layer supports the user-kernel interface by providing device nodes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3916>3916</a></td>\n' +
            '<td>sd (SCSI Disk)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3917>3917</a></td>\n' +
            '<td>sd (sd_mod.o)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3918>3918</a></td>\n' +
            '<td>sr (SCSI CD-ROM)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3919>3919</a></td>\n' +
            '<td>sr (sr_mod.o)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3920>3920</a></td>\n' +
            '<td>st (SCSI Tape)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3921>3921</a></td>\n' +
            '<td>st (st.o)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3922>3922</a></td>\n' +
            '<td>sg (SCSI Generic)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3923>3923</a></td>\n' +
            '<td>sg (sg.o)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3924>3924</a></td>\n' +
            '<td>ch (SCSI Media Changer)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3925>3925</a></td>\n' +
            '<td>ch (ch.c)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3926>3926</a></td>\n' +
            '<td>SCSI mid layer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3927>3927</a></td>\n' +
            '<td>SCSI midlayer implementation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3928>3928</a></td>\n' +
            '<td>include/scsi/scsi_device.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3929>3929</a></td>\n' +
            '<td>!Iinclude/scsi/scsi_device.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3930>3930</a></td>\n' +
            '<td>drivers/scsi/scsi.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3931>3931</a></td>\n' +
            '<td>Main file for the SCSI midlayer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3932>3932</a></td>\n' +
            '<td>!Edrivers/scsi/scsi.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3933>3933</a></td>\n' +
            '<td>drivers/scsi/scsicam.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3934>3934</a></td>\n' +
            '<td>SCSI Common Access Method support functions, for use with HDIO_GETGEO, etc.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3935>3935</a></td>\n' +
            '<td>!Edrivers/scsi/scsicam.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3936>3936</a></td>\n' +
            '<td>drivers/scsi/scsi_error.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3937>3937</a></td>\n' +
            '<td>Common SCSI error/timeout handling routines.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3938>3938</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_error.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3939>3939</a></td>\n' +
            '<td>drivers/scsi/scsi_devinfo.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3940>3940</a></td>\n' +
            '<td>Manage scsi_dev_info_list, which tracks blacklisted and whitelisted devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3941>3941</a></td>\n' +
            '<td>!Idrivers/scsi/scsi_devinfo.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3942>3942</a></td>\n' +
            '<td>drivers/scsi/scsi_ioctl.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3943>3943</a></td>\n' +
            '<td>Handle ioctl() calls for SCSI devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3944>3944</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_ioctl.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3945>3945</a></td>\n' +
            '<td>drivers/scsi/scsi_lib.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3946>3946</a></td>\n' +
            '<td>SCSI queuing library.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3947>3947</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_lib.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3948>3948</a></td>\n' +
            '<td>drivers/scsi/scsi_lib_dma.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3949>3949</a></td>\n' +
            '<td>SCSI library functions depending on DMA (map and unmap scatter-gather lists).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3950>3950</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_lib_dma.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3951>3951</a></td>\n' +
            '<td>drivers/scsi/scsi_module.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3952>3952</a></td>\n' +
            '<td>The file drivers/scsi/scsi_module.c contains legacy support for old-style host templates. It should never be used by any new driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3953>3953</a></td>\n' +
            '<td>drivers/scsi/scsi_proc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3954>3954</a></td>\n' +
            '<td>The functions in this file provide an interface between the PROC file system and the SCSI device drivers It is mainly used for debugging, statistics and to pass information directly to the lowlevel driver. I.E. plumbing to manage /proc/scsi/*</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3955>3955</a></td>\n' +
            '<td>!Idrivers/scsi/scsi_proc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3956>3956</a></td>\n' +
            '<td>drivers/scsi/scsi_netlink.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3957>3957</a></td>\n' +
            '<td>Infrastructure to provide async events from transports to userspace via netlink, using a single NETLINK_SCSITRANSPORT protocol for all transports. See the original patch submission for more details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3958>3958</a></td>\n' +
            '<td>!Idrivers/scsi/scsi_netlink.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3959>3959</a></td>\n' +
            '<td>drivers/scsi/scsi_scan.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3960>3960</a></td>\n' +
            '<td>Scan a host to determine which (if any) devices are attached. The general scanning/probing algorithm is as follows, exceptions are made to it depending on device specific flags, compilation options, and global variable (boot or module load time) settings. A specific LUN is scanned via an INQUIRY command; if the LUN has a device attached, a scsi_device is allocated and setup for it. For every id of every channel on the given host, start by scanning LUN 0. Skip hosts that don' + "'" + 't respond at all to a scan of LUN 0. Otherwise, if LUN 0 has a device attached, allocate and setup a scsi_device for it. If target is SCSI-3 or up, issue a REPORT LUN, and scan all of the LUNs returned by the REPORT LUN; else, sequentially scan LUNs up until some maximum is reached, or a LUN is seen that cannot have a device attached to it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3961>3961</a></td>\n' +
            '<td>!Idrivers/scsi/scsi_scan.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3962>3962</a></td>\n' +
            '<td>drivers/scsi/scsi_sysctl.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3963>3963</a></td>\n' +
            '<td>Set up the sysctl entry: "/dev/scsi/logging_level" (DEV_SCSI_LOGGING_LEVEL) which sets/returns scsi_logging_level.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3964>3964</a></td>\n' +
            '<td>drivers/scsi/scsi_sysfs.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3965>3965</a></td>\n' +
            '<td>SCSI sysfs interface routines.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3966>3966</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_sysfs.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3967>3967</a></td>\n' +
            '<td>drivers/scsi/hosts.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3968>3968</a></td>\n' +
            '<td>mid to lowlevel SCSI driver interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3969>3969</a></td>\n' +
            '<td>!Edrivers/scsi/hosts.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3970>3970</a></td>\n' +
            '<td>drivers/scsi/constants.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3971>3971</a></td>\n' +
            '<td>mid to lowlevel SCSI driver interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3972>3972</a></td>\n' +
            '<td>!Edrivers/scsi/constants.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3973>3973</a></td>\n' +
            '<td>Transport classes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3974>3974</a></td>\n' +
            '<td>Transport classes are service libraries for drivers in the SCSI lower layer, which expose transport attributes in sysfs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3975>3975</a></td>\n' +
            '<td>Fibre Channel transport</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3976>3976</a></td>\n' +
            '<td>The file drivers/scsi/scsi_transport_fc.c defines transport attributes for Fibre Channel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3977>3977</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_transport_fc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3978>3978</a></td>\n' +
            '<td>iSCSI transport class</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3979>3979</a></td>\n' +
            '<td>The file drivers/scsi/scsi_transport_iscsi.c defines transport attributes for the iSCSI class, which sends SCSI packets over TCP/IP connections.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3980>3980</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_transport_iscsi.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3981>3981</a></td>\n' +
            '<td>Serial Attached SCSI (SAS) transport class</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3982>3982</a></td>\n' +
            '<td>The file drivers/scsi/scsi_transport_sas.c defines transport attributes for Serial Attached SCSI, a variant of SATA aimed at large high-end systems.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3983>3983</a></td>\n' +
            '<td>The SAS transport class contains common code to deal with SAS HBAs, an aproximated representation of SAS topologies in the driver model, and various sysfs attributes to expose these topologies and management interfaces to userspace.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3984>3984</a></td>\n' +
            '<td>In addition to the basic SCSI core objects this transport class introduces two additional intermediate objects: The SAS PHY as represented by struct sas_phy defines an "outgoing" PHY on a SAS HBA or Expander, and the SAS remote PHY represented by struct sas_rphy defines an "incoming" PHY on a SAS Expander or end device. Note that this is purely a software concept, the underlying hardware for a PHY and a remote PHY is the exactly the same.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3985>3985</a></td>\n' +
            '<td>There is no concept of a SAS port in this code, users can see what PHYs form a wide port based on the port_identifier attribute, which is the same for all PHYs in a port.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3986>3986</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_transport_sas.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3987>3987</a></td>\n' +
            '<td>SATA transport class</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3988>3988</a></td>\n' +
            '<td>The SATA transport is handled by libata, which has its own book of documentation in this directory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3989>3989</a></td>\n' +
            '<td>Parallel SCSI (SPI) transport class</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3990>3990</a></td>\n' +
            '<td>The file drivers/scsi/scsi_transport_spi.c defines transport attributes for traditional (fast/wide/ultra) SCSI busses.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3991>3991</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_transport_spi.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3992>3992</a></td>\n' +
            '<td>SCSI RDMA (SRP) transport class</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3993>3993</a></td>\n' +
            '<td>The file drivers/scsi/scsi_transport_srp.c defines transport attributes for SCSI over Remote Direct Memory Access.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3994>3994</a></td>\n' +
            '<td>!Edrivers/scsi/scsi_transport_srp.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3995>3995</a></td>\n' +
            '<td>SCSI lower layer</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3996>3996</a></td>\n' +
            '<td>Host Bus Adapter transport types</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3997>3997</a></td>\n' +
            '<td>Many modern device controllers use the SCSI command set as a protocol to communicate with their devices through many different types of physical connections.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3998>3998</a></td>\n' +
            '<td>In SCSI language a bus capable of carrying SCSI commands is called a "transport", and a controller connecting to such a bus is called a "host bus adapter" (HBA).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=3999>3999</a></td>\n' +
            '<td>Debug transport</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4000>4000</a></td>\n' +
            '<td>The file drivers/scsi/scsi_debug.c simulates a host adapter with a variable number of disks (or disk like devices) attached, sharing a common amount of RAM. Does a lot of checking to make sure that we are not getting blocks mixed up, and panics the kernel if anything out of the ordinary is seen.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4001>4001</a></td>\n' +
            '<td>To be more realistic, the simulated devices have the transport attributes of SAS disks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4002>4002</a></td>\n' +
            '<td>For documentation see http://sg.danny.cz/sg/sdebug26.html</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4003>4003</a></td>\n' +
            '<td>todo</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4004>4004</a></td>\n' +
            '<td>Parallel (fast/wide/ultra) SCSI, USB, SATA, SAS, Fibre Channel, FireWire, ATAPI devices, Infiniband, I20, iSCSI, Parallel ports, netlink...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4005>4005</a></td>\n' +
            '<td>Memory Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4006>4006</a></td>\n' +
            '<td>SH-4</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4007>4007</a></td>\n' +
            '<td>Store Queue API</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4008>4008</a></td>\n' +
            '<td>!Earch/sh/kernel/cpu/sh4/sq.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4009>4009</a></td>\n' +
            '<td>SH-5</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4010>4010</a></td>\n' +
            '<td>TLB Interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4011>4011</a></td>\n' +
            '<td>!Iarch/sh/mm/tlb-sh5.c !Iarch/sh/include/asm/tlb_64.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4012>4012</a></td>\n' +
            '<td>Machine Specific Interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4013>4013</a></td>\n' +
            '<td>mach-dreamcast</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4014>4014</a></td>\n' +
            '<td>!Iarch/sh/boards/mach-dreamcast/rtc.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4015>4015</a></td>\n' +
            '<td>mach-x3proto</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4016>4016</a></td>\n' +
            '<td>!Earch/sh/boards/mach-x3proto/ilsel.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4017>4017</a></td>\n' +
            '<td>Busses</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4018>4018</a></td>\n' +
            '<td>SuperHyway</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4019>4019</a></td>\n' +
            '<td>!Edrivers/sh/superhyway/superhyway.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4020>4020</a></td>\n' +
            '<td>Maple</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4021>4021</a></td>\n' +
            '<td>!Edrivers/sh/maple/maple.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4022>4022</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4023>4023</a></td>\n' +
            '<td>Tracepoints are static probe points that are located in strategic points throughout the kernel. ' + "'" + 'Probes' + "'" + ' register/unregister with tracepoints via a callback mechanism. The ' + "'" + 'probes' + "'" + ' are strictly typed functions that are passed a unique set of parameters defined by each tracepoint.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4024>4024</a></td>\n' +
            '<td>From this simple callback mechanism, ' + "'" + 'probes' + "'" + ' can be used to profile, debug, and understand kernel behavior. There are a number of tools that provide a framework for using ' + "'" + 'probes' + "'" + '. These tools include Systemtap, ftrace, and LTTng.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4025>4025</a></td>\n' +
            '<td>Tracepoints are defined in a number of header files via various macros. Thus, the purpose of this document is to provide a clear accounting of the available tracepoints. The intention is to understand not only what tracepoints are available but also to understand where future tracepoints might be added.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4026>4026</a></td>\n' +
            '<td>The API presented has functions of the form: trace_tracepointname(function parameters). These are the tracepoints callbacks that are found throughout the code. Registering and unregistering probes with these callback sites is covered in the Documentation/trace/* directory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4027>4027</a></td>\n' +
            '<td>IRQ</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4028>4028</a></td>\n' +
            '<td>!Iinclude/trace/events/irq.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4029>4029</a></td>\n' +
            '<td>SIGNAL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4030>4030</a></td>\n' +
            '<td>!Iinclude/trace/events/signal.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4031>4031</a></td>\n' +
            '<td>Block IO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4032>4032</a></td>\n' +
            '<td>!Iinclude/trace/events/block.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4033>4033</a></td>\n' +
            '<td>Workqueue</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4034>4034</a></td>\n' +
            '<td>!Iinclude/trace/events/workqueue.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4035>4035</a></td>\n' +
            '<td>About this document</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4036>4036</a></td>\n' +
            '<td>Translations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4037>4037</a></td>\n' +
            '<td>If you know of any translations for this document, or you are interested in translating it, please email me hjk@hansjkoch.de.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4038>4038</a></td>\n' +
            '<td>Preface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4039>4039</a></td>\n' +
            '<td>For many types of devices, creating a Linux kernel driver is overkill. All that is really needed is some way to handle an interrupt and provide access to the memory space of the device. The logic of controlling the device does not necessarily have to be within the kernel, as the device does not need to take advantage of any of other resources that the kernel provides. One such common class of devices that are like this are for industrial I/O cards.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4040>4040</a></td>\n' +
            '<td>To address this situation, the userspace I/O system (UIO) was designed. For typical industrial I/O cards, only a very small kernel module is needed. The main part of the driver will run in user space. This simplifies development and reduces the risk of serious bugs within a kernel module.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4041>4041</a></td>\n' +
            '<td>Please note that UIO is not an universal driver interface. Devices that are already handled well by other kernel subsystems (like networking or serial or USB) are no candidates for an UIO driver. Hardware that is ideally suited for an UIO driver fulfills all of the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4042>4042</a></td>\n' +
            '<td>    The device has memory that can be mapped. The device can be controlled completely by writing to this memory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4043>4043</a></td>\n' +
            '<td>    The device usually generates interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4044>4044</a></td>\n' +
            '<td>    The device does not fit into one of the standard kernel subsystems.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4045>4045</a></td>\n' +
            '<td>Acknowledgments</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4046>4046</a></td>\n' +
            '<td>I' + "'" + 'd like to thank Thomas Gleixner and Benedikt Spranger of Linutronix, who have not only written most of the UIO code, but also helped greatly writing this HOWTO by giving me all kinds of background information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4047>4047</a></td>\n' +
            '<td>Feedback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4048>4048</a></td>\n' +
            '<td>Find something wrong with this document? (Or perhaps something right?) I would love to hear from you. Please email me at hjk@hansjkoch.de.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4049>4049</a></td>\n' +
            '<td>About UIO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4050>4050</a></td>\n' +
            '<td>If you use UIO for your card' + "'" + 's driver, here' + "'" + 's what you get:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4051>4051</a></td>\n' +
            '<td>    only one small kernel module to write and maintain.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4052>4052</a></td>\n' +
            '<td>    develop the main part of your driver in user space, with all the tools and libraries you' + "'" + 're used to.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4053>4053</a></td>\n' +
            '<td>    bugs in your driver won' + "'" + 't crash the kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4054>4054</a></td>\n' +
            '<td>    updates of your driver can take place without recompiling the kernel.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4055>4055</a></td>\n' +
            '<td>How UIO works</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4056>4056</a></td>\n' +
            '<td>Each UIO device is accessed through a device file and several sysfs attribute files. The device file will be called /dev/uio0 for the first device, and /dev/uio1, /dev/uio2 and so on for subsequent devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4057>4057</a></td>\n' +
            '<td>/dev/uioX is used to access the address space of the card. Just use mmap() to access registers or RAM locations of your card.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4058>4058</a></td>\n' +
            '<td>Interrupts are handled by reading from /dev/uioX. A blocking read() from /dev/uioX will return as soon as an interrupt occurs. You can also use select() on /dev/uioX to wait for an interrupt. The integer value read from /dev/uioX represents the total interrupt count. You can use this number to figure out if you missed some interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4059>4059</a></td>\n' +
            '<td>For some hardware that has more than one interrupt source internally, but not separate IRQ mask and status registers, there might be situations where userspace cannot determine what the interrupt source was if the kernel handler disables them by writing to the chip' + "'" + 's IRQ register. In such a case, the kernel has to disable the IRQ completely to leave the chip' + "'" + 's register untouched. Now the userspace part can determine the cause of the interrupt, but it cannot re-enable interrupts. Another cornercase is chips where re-enabling interrupts is a read-modify-write operation to a combined IRQ status/acknowledge register. This would be racy if a new interrupt occurred simultaneously.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4060>4060</a></td>\n' +
            '<td>To address these problems, UIO also implements a write() function. It is normally not used and can be ignored for hardware that has only a single interrupt source or has separate IRQ mask and status registers. If you need it, however, a write to /dev/uioX will call the irqcontrol() function implemented by the driver. You have to write a 32-bit value that is usually either 0 or 1 to disable or enable interrupts. If a driver does not implement irqcontrol(), write() will return with -ENOSYS.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4061>4061</a></td>\n' +
            '<td>To handle interrupts properly, your custom kernel module can provide its own interrupt handler. It will automatically be called by the built-in handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4062>4062</a></td>\n' +
            '<td>For cards that don' + "'" + 't generate interrupts but need to be polled, there is the possibility to set up a timer that triggers the interrupt handler at configurable time intervals. This interrupt simulation is done by calling uio_event_notify() from the timer' + "'" + 's event handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4063>4063</a></td>\n' +
            '<td>Each driver provides attributes that are used to read or write variables. These attributes are accessible through sysfs files. A custom kernel driver module can add its own attributes to the device owned by the uio driver, but not added to the UIO device itself at this time. This might change in the future if it would be found to be useful.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4064>4064</a></td>\n' +
            '<td>The following standard attributes are provided by the UIO framework:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4065>4065</a></td>\n' +
            '<td>    name: The name of your device. It is recommended to use the name of your kernel module for this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4066>4066</a></td>\n' +
            '<td>    version: A version string defined by your driver. This allows the user space part of your driver to deal with different versions of the kernel module.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4067>4067</a></td>\n' +
            '<td>    event: The total number of interrupts handled by the driver since the last time the device node was read.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4068>4068</a></td>\n' +
            '<td>These attributes appear under the /sys/class/uio/uioX directory. Please note that this directory might be a symlink, and not a real directory. Any userspace code that accesses it must be able to handle this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4069>4069</a></td>\n' +
            '<td>Each UIO device can make one or more memory regions available for memory mapping. This is necessary because some industrial I/O cards require access to more than one PCI memory region in a driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4070>4070</a></td>\n' +
            '<td>Each mapping has its own directory in sysfs, the first mapping appears as /sys/class/uio/uioX/maps/map0/. Subsequent mappings create directories map1/, map2/, and so on. These directories will only appear if the size of the mapping is not 0.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4071>4071</a></td>\n' +
            '<td>Each mapX/ directory contains four read-only files that show attributes of the memory:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4072>4072</a></td>\n' +
            '<td>    name: A string identifier for this mapping. This is optional, the string can be empty. Drivers can set this to make it easier for userspace to find the correct mapping.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4073>4073</a></td>\n' +
            '<td>    addr: The address of memory that can be mapped.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4074>4074</a></td>\n' +
            '<td>    size: The size, in bytes, of the memory pointed to by addr.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4075>4075</a></td>\n' +
            '<td>    offset: The offset, in bytes, that has to be added to the pointer returned by mmap() to get to the actual device memory. This is important if the device' + "'" + 's memory is not page aligned. Remember that pointers returned by mmap() are always page aligned, so it is good style to always add this offset.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4076>4076</a></td>\n' +
            '<td>From userspace, the different mappings are distinguished by adjusting the offset parameter of the mmap() call. To map the memory of mapping N, you have to use N times the page size as your offset:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4077>4077</a></td>\n' +
            '<td>offset = N * getpagesize();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4078>4078</a></td>\n' +
            '<td>Sometimes there is hardware with memory-like regions that can not be mapped with the technique described here, but there are still ways to access them from userspace. The most common example are x86 ioports. On x86 systems, userspace can access these ioports using ioperm(), iopl(), inb(), outb(), and similar functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4079>4079</a></td>\n' +
            '<td>Since these ioport regions can not be mapped, they will not appear under /sys/class/uio/uioX/maps/ like the normal memory described above. Without information about the port regions a hardware has to offer, it becomes difficult for the userspace part of the driver to find out which ports belong to which UIO device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4080>4080</a></td>\n' +
            '<td>To address this situation, the new directory /sys/class/uio/uioX/portio/ was added. It only exists if the driver wants to pass information about one or more port regions to userspace. If that is the case, subdirectories named port0, port1, and so on, will appear underneath /sys/class/uio/uioX/portio/.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4081>4081</a></td>\n' +
            '<td>Each portX/ directory contains four read-only files that show name, start, size, and type of the port region:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4082>4082</a></td>\n' +
            '<td>    name: A string identifier for this port region. The string is optional and can be empty. Drivers can set it to make it easier for userspace to find a certain port region.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4083>4083</a></td>\n' +
            '<td>    start: The first port of this region.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4084>4084</a></td>\n' +
            '<td>    size: The number of ports in this region.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4085>4085</a></td>\n' +
            '<td>    porttype: A string describing the type of port.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4086>4086</a></td>\n' +
            '<td>Writing your own kernel module</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4087>4087</a></td>\n' +
            '<td>Please have a look at uio_cif.c as an example. The following paragraphs explain the different sections of this file.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4088>4088</a></td>\n' +
            '<td>struct uio_info</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4089>4089</a></td>\n' +
            '<td>This structure tells the framework the details of your driver, Some of the members are required, others are optional.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4090>4090</a></td>\n' +
            '<td>    const char *name: Required. The name of your driver as it will appear in sysfs. I recommend using the name of your module for this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4091>4091</a></td>\n' +
            '<td>    const char *version: Required. This string appears in /sys/class/uio/uioX/version.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4092>4092</a></td>\n' +
            '<td>    struct uio_mem mem[ MAX_UIO_MAPS ]: Required if you have memory that can be mapped with mmap(). For each mapping you need to fill one of the uio_mem structures. See the description below for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4093>4093</a></td>\n' +
            '<td>    struct uio_port port[ MAX_UIO_PORTS_REGIONS ]: Required if you want to pass information about ioports to userspace. For each port region you need to fill one of the uio_port structures. See the description below for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4094>4094</a></td>\n' +
            '<td>    long irq: Required. If your hardware generates an interrupt, it' + "'" + 's your modules task to determine the irq number during initialization. If you don' + "'" + 't have a hardware generated interrupt but want to trigger the interrupt handler in some other way, set irq to UIO_IRQ_CUSTOM. If you had no interrupt at all, you could set irq to UIO_IRQ_NONE, though this rarely makes sense.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4095>4095</a></td>\n' +
            '<td>    unsigned long irq_flags: Required if you' + "'" + 've set irq to a hardware interrupt number. The flags given here will be used in the call to request_irq().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4096>4096</a></td>\n' +
            '<td>    int (*mmap)(struct uio_info *info, struct vm_area_struct</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4097>4097</a></td>\n' +
            '<td>*vma): Optional. If you need a special mmap() function, you can set it here. If this pointer is not NULL, your mmap() will be called instead of the built-in one.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4098>4098</a></td>\n' +
            '<td>    int (*open)(struct uio_info *info, struct inode *inode): Optional. You might want to have your own open(), e.g. to enable interrupts only when your device is actually used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4099>4099</a></td>\n' +
            '<td>    int (*release)(struct uio_info *info, struct inode *inode): Optional. If you define your own open(), you will probably also want a custom release() function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4100>4100</a></td>\n' +
            '<td>    int (*irqcontrol)(struct uio_info *info, s32 irq_on): Optional. If you need to be able to enable or disable interrupts from userspace by writing to /dev/uioX, you can implement this function. The parameter irq_on will be 0 to disable interrupts and 1 to enable them.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4101>4101</a></td>\n' +
            '<td>Usually, your device will have one or more memory regions that can be mapped to user space. For each region, you have to set up a struct uio_mem in the mem[] array. Here' + "'" + 's a description of the fields of struct uio_mem:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4102>4102</a></td>\n' +
            '<td>    const char *name: Optional. Set this to help identify the memory region, it will show up in the corresponding sysfs node.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4103>4103</a></td>\n' +
            '<td>    int memtype: Required if the mapping is used. Set this to UIO_MEM_PHYS if you you have physical memory on your card to be mapped. Use UIO_MEM_LOGICAL for logical memory (e.g. allocated with kmalloc()). There' + "'" + 's also UIO_MEM_VIRTUAL for virtual memory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4104>4104</a></td>\n' +
            '<td>    phys_addr_t addr: Required if the mapping is used. Fill in the address of your memory block. This address is the one that appears in sysfs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4105>4105</a></td>\n' +
            '<td>    unsigned long size: Fill in the size of the memory block that addr points to. If size is zero, the mapping is considered unused. Note that you must initialize size with zero for all unused mappings.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4106>4106</a></td>\n' +
            '<td>    void *internal_addr: If you have to access this memory region from within your kernel module, you will want to map it internally by using something like ioremap(). Addresses returned by this function cannot be mapped to user space, so you must not store it in addr. Use internal_addr instead to remember such an address.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4107>4107</a></td>\n' +
            '<td>Please do not touch the map element of struct uio_mem! It is used by the UIO framework to set up sysfs files for this mapping. Simply leave it alone.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4108>4108</a></td>\n' +
            '<td>Sometimes, your device can have one or more port regions which can not be mapped to userspace. But if there are other possibilities for userspace to access these ports, it makes sense to make information about the ports available in sysfs. For each region, you have to set up a struct uio_port in the port[] array. Here' + "'" + 's a description of the fields of struct uio_port:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4109>4109</a></td>\n' +
            '<td>    char *porttype: Required. Set this to one of the predefined constants. Use UIO_PORT_X86 for the ioports found in x86 architectures.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4110>4110</a></td>\n' +
            '<td>    unsigned long start: Required if the port region is used. Fill in the number of the first port of this region.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4111>4111</a></td>\n' +
            '<td>    unsigned long size: Fill in the number of ports in this region. If size is zero, the region is considered unused. Note that you must initialize size with zero for all unused regions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4112>4112</a></td>\n' +
            '<td>Please do not touch the portio element of struct uio_port! It is used internally by the UIO framework to set up sysfs files for this region. Simply leave it alone.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4113>4113</a></td>\n' +
            '<td>Adding an interrupt handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4114>4114</a></td>\n' +
            '<td>What you need to do in your interrupt handler depends on your hardware and on how you want to handle it. You should try to keep the amount of code in your kernel interrupt handler low. If your hardware requires no action that you have to perform after each interrupt, then your handler can be empty.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4115>4115</a></td>\n' +
            '<td>If, on the other hand, your hardware needs some action to be performed after each interrupt, then you must do it in your kernel module. Note that you cannot rely on the userspace part of your driver. Your userspace program can terminate at any time, possibly leaving your hardware in a state where proper interrupt handling is still required.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4116>4116</a></td>\n' +
            '<td>There might also be applications where you want to read data from your hardware at each interrupt and buffer it in a piece of kernel memory you' + "'" + 've allocated for that purpose. With this technique you could avoid loss of data if your userspace program misses an interrupt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4117>4117</a></td>\n' +
            '<td>A note on shared interrupts: Your driver should support interrupt sharing whenever this is possible. It is possible if and only if your driver can detect whether your hardware has triggered the interrupt or not. This is usually done by looking at an interrupt status register. If your driver sees that the IRQ bit is actually set, it will perform its actions, and the handler returns IRQ_HANDLED. If the driver detects that it was not your hardware that caused the interrupt, it will do nothing and return IRQ_NONE, allowing the kernel to call the next possible interrupt handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4118>4118</a></td>\n' +
            '<td>If you decide not to support shared interrupts, your card won' + "'" + 't work in computers with no free interrupts. As this frequently happens on the PC platform, you can save yourself a lot of trouble by supporting interrupt sharing.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4119>4119</a></td>\n' +
            '<td>Using uio_pdrv for platform devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4120>4120</a></td>\n' +
            '<td>In many cases, UIO drivers for platform devices can be handled in a generic way. In the same place where you define your struct platform_device, you simply also implement your interrupt handler and fill your struct uio_info. A pointer to this struct uio_info is then used as platform_data for your platform device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4121>4121</a></td>\n' +
            '<td>You also need to set up an array of struct resource containing addresses and sizes of your memory mappings. This information is passed to the driver using the .resource and .num_resources elements of struct platform_device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4122>4122</a></td>\n' +
            '<td>You now have to set the .name element of struct platform_device to "uio_pdrv" to use the generic UIO platform device driver. This driver will fill the mem[] array according to the resources given, and register the device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4123>4123</a></td>\n' +
            '<td>The advantage of this approach is that you only have to edit a file you need to edit anyway. You do not have to create an extra driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4124>4124</a></td>\n' +
            '<td>Using uio_pdrv_genirq for platform devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4125>4125</a></td>\n' +
            '<td>Especially in embedded devices, you frequently find chips where the irq pin is tied to its own dedicated interrupt line. In such cases, where you can be really sure the interrupt is not shared, we can take the concept of uio_pdrv one step further and use a generic interrupt handler. That' + "'" + 's what uio_pdrv_genirq does.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4126>4126</a></td>\n' +
            '<td>The setup for this driver is the same as described above for uio_pdrv, except that you do not implement an interrupt handler. The .handler element of struct uio_info must remain NULL. The .irq_flags element must not contain IRQF_SHARED.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4127>4127</a></td>\n' +
            '<td>You will set the .name element of struct platform_device to "uio_pdrv_genirq" to use this driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4128>4128</a></td>\n' +
            '<td>The generic interrupt handler of uio_pdrv_genirq will simply disable the interrupt line using disable_irq_nosync(). After doing its work, userspace can reenable the interrupt by writing 0x00000001 to the UIO device file. The driver already implements an irq_control() to make this possible, you must not implement your own.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4129>4129</a></td>\n' +
            '<td>Using uio_pdrv_genirq not only saves a few lines of interrupt handler code. You also do not need to know anything about the chip' + "'" + 's internal registers to create the kernel part of the driver. All you need to know is the irq number of the pin the chip is connected to.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4130>4130</a></td>\n' +
            '<td>Using uio_dmem_genirq for platform devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4131>4131</a></td>\n' +
            '<td>In addition to statically allocated memory ranges, they may also be a desire to use dynamically allocated regions in a user space driver. In particular, being able to access memory made available through the dma-mapping API, may be particularly useful. The uio_dmem_genirq driver provides a way to accomplish this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4132>4132</a></td>\n' +
            '<td>This driver is used in a similar manner to the "uio_pdrv_genirq" driver with respect to interrupt configuration and handling.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4133>4133</a></td>\n' +
            '<td>Set the .name element of struct platform_device to "uio_dmem_genirq" to use this driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4134>4134</a></td>\n' +
            '<td>When using this driver, fill in the .platform_data element of struct platform_device, which is of type struct uio_dmem_genirq_pdata and which contains the following elements:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4135>4135</a></td>\n' +
            '<td>    struct uio_info uioinfo</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4136>4136</a></td>\n' +
            '<td>     : The same structure used as the</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4137>4137</a></td>\n' +
            '<td>     uio_pdrv_genirq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4138>4138</a></td>\n' +
            '<td>     platform data</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4139>4139</a></td>\n' +
            '<td>    unsigned int *dynamic_region_sizes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4140>4140</a></td>\n' +
            '<td>     : Pointer to list of sizes of dynamic memory regions to be mapped into user space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4141>4141</a></td>\n' +
            '<td>    unsigned int num_dynamic_regions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4142>4142</a></td>\n' +
            '<td>     : Number of elements in</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4143>4143</a></td>\n' +
            '<td>     dynamic_region_sizes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4144>4144</a></td>\n' +
            '<td>     array.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4145>4145</a></td>\n' +
            '<td>The dynamic regions defined in the platform data will be appended to the  mem[]  array after the platform device resources, which implies that the total number of static and dynamic memory regions cannot exceed MAX_UIO_MAPS.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4146>4146</a></td>\n' +
            '<td>The dynamic memory regions will be allocated when the UIO device file, /dev/uioX is opened. Simiar to static memory resources, the memory region information for dynamic regions is then visible via sysfs at /sys/class/uio/uioX/maps/mapY/*. The dynmaic memory regions will be freed when the UIO device file is closed. When no processes are holding the device file open, the address returned to userspace is ~0.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4147>4147</a></td>\n' +
            '<td>Writing a driver in userspace</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4148>4148</a></td>\n' +
            '<td>Once you have a working kernel module for your hardware, you can write the userspace part of your driver. You don' + "'" + 't need any special libraries, your driver can be written in any reasonable language, you can use floating point numbers and so on. In short, you can use all the tools and libraries you' + "'" + 'd normally use for writing a userspace application.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4149>4149</a></td>\n' +
            '<td>Getting information about your UIO device</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4150>4150</a></td>\n' +
            '<td>Information about all UIO devices is available in sysfs. The first thing you should do in your driver is check name and version to make sure your talking to the right device and that its kernel driver has the version you expect.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4151>4151</a></td>\n' +
            '<td>You should also make sure that the memory mapping you need exists and has the size you expect.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4152>4152</a></td>\n' +
            '<td>There is a tool called lsuio that lists UIO devices and their attributes. It is available here:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4153>4153</a></td>\n' +
            '<td>http://www.osadl.org/projects/downloads/UIO/user/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4154>4154</a></td>\n' +
            '<td>With lsuio you can quickly check if your kernel module is loaded and which attributes it exports. Have a look at the manpage for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4155>4155</a></td>\n' +
            '<td>The source code of lsuio can serve as an example for getting information about an UIO device. The file uio_helper.c contains a lot of functions you could use in your userspace driver code.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4156>4156</a></td>\n' +
            '<td>mmap() device memory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4157>4157</a></td>\n' +
            '<td>After you made sure you' + "'" + 've got the right device with the memory mappings you need, all you have to do is to call mmap() to map the device' + "'" + 's memory to userspace.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4158>4158</a></td>\n' +
            '<td>The parameter offset of the mmap() call has a special meaning for UIO devices: It is used to select which mapping of your device you want to map. To map the memory of mapping N, you have to use N times the page size as your offset:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4159>4159</a></td>\n' +
            '<td>    offset = N * getpagesize();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4160>4160</a></td>\n' +
            '<td>N starts from zero, so if you' + "'" + 've got only one memory range to map, set offset = 0. A drawback of this technique is that memory is always mapped beginning with its start address.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4161>4161</a></td>\n' +
            '<td>Waiting for interrupts</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4162>4162</a></td>\n' +
            '<td>After you successfully mapped your devices memory, you can access it like an ordinary array. Usually, you will perform some initialization. After that, your hardware starts working and will generate an interrupt as soon as it' + "'" + 's finished, has some data available, or needs your attention because an error occurred.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4163>4163</a></td>\n' +
            '<td>/dev/uioX is a read-only file. A read() will always block until an interrupt occurs. There is only one legal value for the count parameter of read(), and that is the size of a signed 32 bit integer (4). Any other value for count causes read() to fail. The signed 32 bit integer read is the interrupt count of your device. If the value is one more than the value you read the last time, everything is OK. If the difference is greater than one, you missed interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4164>4164</a></td>\n' +
            '<td>You can also use select() on /dev/uioX.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4165>4165</a></td>\n' +
            '<td>Generic PCI UIO driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4166>4166</a></td>\n' +
            '<td>The generic driver is a kernel module named uio_pci_generic. It can work with any device compliant to PCI 2.3 (circa 2002) and any compliant PCI Express device. Using this, you only need to write the userspace driver, removing the need to write a hardware-specific kernel module.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4167>4167</a></td>\n' +
            '<td>Making the driver recognize the device</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4168>4168</a></td>\n' +
            '<td>Since the driver does not declare any device ids, it will not get loaded automatically and will not automatically bind to any devices, you must load it and allocate id to the driver yourself. For example:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4169>4169</a></td>\n' +
            '<td> modprobe uio_pci_generic</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4170>4170</a></td>\n' +
            '<td> echo "8086 10f5" &gt; /sys/bus/pci/drivers/uio_pci_generic/new_id</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4171>4171</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4172>4172</a></td>\n' +
            '<td>If there already is a hardware specific kernel driver for your device, the generic driver still won' + "'" + 't bind to it, in this case if you want to use the generic driver (why would you?) you' + "'" + 'll have to manually unbind the hardware specific driver and bind the generic driver, like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4173>4173</a></td>\n' +
            '<td>    echo -n 0000:00:19.0 &gt; /sys/bus/pci/drivers/e1000e/unbind</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4174>4174</a></td>\n' +
            '<td>    echo -n 0000:00:19.0 &gt; /sys/bus/pci/drivers/uio_pci_generic/bind</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4175>4175</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4176>4176</a></td>\n' +
            '<td>You can verify that the device has been bound to the driver by looking for it in sysfs, for example like the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4177>4177</a></td>\n' +
            '<td>    ls -l /sys/bus/pci/devices/0000:00:19.0/driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4178>4178</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4179>4179</a></td>\n' +
            '<td>Which if successful should print</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4180>4180</a></td>\n' +
            '<td>  .../0000:00:19.0/driver -&gt; ../../../bus/pci/drivers/uio_pci_generic</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4181>4181</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4182>4182</a></td>\n' +
            '<td>Note that the generic driver will not bind to old PCI 2.2 devices. If binding the device failed, run the following command:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4183>4183</a></td>\n' +
            '<td>  dmesg</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4184>4184</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4185>4185</a></td>\n' +
            '<td>and look in the output for failure reasons</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4186>4186</a></td>\n' +
            '<td>Things to know about uio_pci_generic</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4187>4187</a></td>\n' +
            '<td>Interrupts are handled using the Interrupt Disable bit in the PCI command register and Interrupt Status bit in the PCI status register. All devices compliant to PCI 2.3 (circa 2002) and all compliant PCI Express devices should support these bits. uio_pci_generic detects this support, and won' + "'" + 't bind to devices which do not support the Interrupt Disable Bit in the command register.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4188>4188</a></td>\n' +
            '<td>On each interrupt, uio_pci_generic sets the Interrupt Disable bit. This prevents the device from generating further interrupts until the bit is cleared. The userspace driver should clear this bit before blocking and waiting for more interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4189>4189</a></td>\n' +
            '<td>Writing userspace driver using uio_pci_generic</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4190>4190</a></td>\n' +
            '<td>Userspace driver can use pci sysfs interface, or the libpci libray that wraps it, to talk to the device and to re-enable interrupts by writing to the command register.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4191>4191</a></td>\n' +
            '<td>Example code using uio_pci_generic</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4192>4192</a></td>\n' +
            '<td>Here is some sample userspace driver code using uio_pci_generic:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4193>4193</a></td>\n' +
            '<td>#include &lt;stdlib.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4194>4194</a></td>\n' +
            '<td>#include &lt;stdio.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4195>4195</a></td>\n' +
            '<td>#include &lt;unistd.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4196>4196</a></td>\n' +
            '<td>#include &lt;sys/types.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4197>4197</a></td>\n' +
            '<td>#include &lt;sys/stat.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4198>4198</a></td>\n' +
            '<td>#include &lt;fcntl.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4199>4199</a></td>\n' +
            '<td>#include &lt;errno.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4200>4200</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4201>4201</a></td>\n' +
            '<td>int main()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4202>4202</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4203>4203</a></td>\n' +
            '<td>    int uiofd;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4204>4204</a></td>\n' +
            '<td>    int configfd;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4205>4205</a></td>\n' +
            '<td>    int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4206>4206</a></td>\n' +
            '<td>    int i;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4207>4207</a></td>\n' +
            '<td>    unsigned icount;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4208>4208</a></td>\n' +
            '<td>    unsigned char command_high;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4209>4209</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4210>4210</a></td>\n' +
            '<td>    uiofd = open("/dev/uio0", O_RDONLY);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4211>4211</a></td>\n' +
            '<td>    if (uiofd &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4212>4212</a></td>\n' +
            '<td>        perror("uio open:");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4213>4213</a></td>\n' +
            '<td>        return errno;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4214>4214</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4215>4215</a></td>\n' +
            '<td>    configfd = open("/sys/class/uio/uio0/device/config", O_RDWR);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4216>4216</a></td>\n' +
            '<td>    if (configfd &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4217>4217</a></td>\n' +
            '<td>        perror("config open:");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4218>4218</a></td>\n' +
            '<td>        return errno;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4219>4219</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4220>4220</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4221>4221</a></td>\n' +
            '<td>    /* Read and cache command value */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4222>4222</a></td>\n' +
            '<td>    err = pread(configfd, &amp;command_high, 1, 5);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4223>4223</a></td>\n' +
            '<td>    if (err != 1) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4224>4224</a></td>\n' +
            '<td>        perror("command config read:");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4225>4225</a></td>\n' +
            '<td>        return errno;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4226>4226</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4227>4227</a></td>\n' +
            '<td>    command_high &amp;= ~0x4;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4228>4228</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4229>4229</a></td>\n' +
            '<td>    for(i = 0;; ++i) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4230>4230</a></td>\n' +
            '<td>        /* Print out a message, for debugging. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4231>4231</a></td>\n' +
            '<td>        if (i == 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4232>4232</a></td>\n' +
            '<td>            fprintf(stderr, "Started uio test driver.\\n");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4233>4233</a></td>\n' +
            '<td>        else</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4234>4234</a></td>\n' +
            '<td>            fprintf(stderr, "Interrupts: %d\\n", icount);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4235>4235</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4236>4236</a></td>\n' +
            '<td>        /****************************************/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4237>4237</a></td>\n' +
            '<td>        /* Here we got an interrupt from the</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4238>4238</a></td>\n' +
            '<td>           device. Do something to it. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4239>4239</a></td>\n' +
            '<td>        /****************************************/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4240>4240</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4241>4241</a></td>\n' +
            '<td>        /* Re-enable interrupts. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4242>4242</a></td>\n' +
            '<td>        err = pwrite(configfd, &amp;command_high, 1, 5);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4243>4243</a></td>\n' +
            '<td>        if (err != 1) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4244>4244</a></td>\n' +
            '<td>            perror("config write:");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4245>4245</a></td>\n' +
            '<td>            break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4246>4246</a></td>\n' +
            '<td>        }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4247>4247</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4248>4248</a></td>\n' +
            '<td>        /* Wait for next interrupt. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4249>4249</a></td>\n' +
            '<td>        err = read(uiofd, &amp;icount, 4);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4250>4250</a></td>\n' +
            '<td>        if (err != 4) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4251>4251</a></td>\n' +
            '<td>            perror("uio read:");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4252>4252</a></td>\n' +
            '<td>            break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4253>4253</a></td>\n' +
            '<td>        }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4254>4254</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4255>4255</a></td>\n' +
            '<td>    }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4256>4256</a></td>\n' +
            '<td>    return errno;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4257>4257</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4258>4258</a></td>\n' +
            '<td>Further information</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4259>4259</a></td>\n' +
            '<td>    OSADL homepage.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4260>4260</a></td>\n' +
            '<td>    Linutronix homepage.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4261>4261</a></td>\n' +
            '<td>Introduction to USB on Linux</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4262>4262</a></td>\n' +
            '<td>A Universal Serial Bus (USB) is used to connect a host, such as a PC or workstation, to a number of peripheral devices. USB uses a tree structure, with the host as the root (the system' + "'" + 's master), hubs as interior nodes, and peripherals as leaves (and slaves). Modern PCs support several such trees of USB devices, usually one USB 2.0 tree (480 Mbit/sec each) with a few USB 1.1 trees (12 Mbit/sec each) that are used when you connect a USB 1.1 device directly to the machine' + "'" + 's "root hub".</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4263>4263</a></td>\n' +
            '<td>That master/slave asymmetry was designed-in for a number of reasons, one being ease of use. It is not physically possible to assemble (legal) USB cables incorrectly: all upstream "to the host" connectors are the rectangular type (matching the sockets on root hubs), and all downstream connectors are the squarish type (or they are built into the peripheral). Also, the host software doesn' + "'" + 't need to deal with distributed auto-configuration since the pre-designated master node manages all that. And finally, at the electrical level, bus protocol overhead is reduced by eliminating arbitration and moving scheduling into the host software.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4264>4264</a></td>\n' +
            '<td>USB 1.0 was announced in January 1996 and was revised as USB 1.1 (with improvements in hub specification and support for interrupt-out transfers) in September 1998. USB 2.0 was released in April 2000, adding high-speed transfers and transaction-translating hubs (used for USB 1.1 and 1.0 backward compatibility).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4265>4265</a></td>\n' +
            '<td>Kernel developers added USB support to Linux early in the 2.2 kernel series, shortly before 2.3 development forked. Updates from 2.3 were regularly folded back into 2.2 releases, which improved reliability and brought /sbin/hotplug support as well more drivers. Such improvements were continued in the 2.5 kernel series, where they added USB 2.0 support, improved performance, and made the host controller drivers (HCDs) more consistent. They also simplified the API (to make bugs less likely) and added internal "kerneldoc" documentation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4266>4266</a></td>\n' +
            '<td>Linux can run inside USB devices as well as on the hosts that control the devices. But USB device drivers running inside those peripherals don' + "'" + 't do the same things as the ones running inside hosts, so they' + "'" + 've been given a different name: gadget drivers. This document does not cover gadget drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4267>4267</a></td>\n' +
            '<td>USB Host-Side API Model</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4268>4268</a></td>\n' +
            '<td>Host-side drivers for USB devices talk to the "usbcore" APIs. There are two. One is intended for general-purpose drivers (exposed through driver frameworks), and the other is for drivers that are part of the core. Such core drivers include the hub driver (which manages trees of USB devices) and several different kinds of host controller drivers, which control individual busses.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4269>4269</a></td>\n' +
            '<td>The device model seen by USB drivers is relatively complex.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4270>4270</a></td>\n' +
            '<td>    USB supports four kinds of data transfers (control, bulk, interrupt, and isochronous). Two of them (control and bulk) use bandwidth as it' + "'" + 's available, while the other two (interrupt and isochronous) are scheduled to provide guaranteed bandwidth.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4271>4271</a></td>\n' +
            '<td>    The device description model includes one or more "configurations" per device, only one of which is active at a time. Devices that are capable of high-speed operation must also support full-speed configurations, along with a way to ask about the "other speed" configurations which might be used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4272>4272</a></td>\n' +
            '<td>    Configurations have one or more "interfaces", each of which may have "alternate settings". Interfaces may be standardized by USB "Class" specifications, or may be specific to a vendor or device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4273>4273</a></td>\n' +
            '<td>     USB device drivers actually bind to interfaces, not devices. Think of them as "interface drivers", though you may not see many devices where the distinction is important. Most USB devices are simple, with only one configuration, one interface, and one alternate setting.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4274>4274</a></td>\n' +
            '<td>    Interfaces have one or more "endpoints", each of which supports one type and direction of data transfer such as "bulk out" or "interrupt in". The entire configuration may have up to sixteen endpoints in each direction, allocated as needed among all the interfaces.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4275>4275</a></td>\n' +
            '<td>    Data transfer on USB is packetized; each endpoint has a maximum packet size. Drivers must often be aware of conventions such as flagging the end of bulk transfers using "short" (including zero length) packets.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4276>4276</a></td>\n' +
            '<td>    The Linux USB API supports synchronous calls for control and bulk messages. It also supports asynchnous calls for all kinds of data transfer, using request structures called "URBs" (USB Request Blocks).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4277>4277</a></td>\n' +
            '<td>Accordingly, the USB Core API exposed to device drivers covers quite a lot of territory. You' + "'" + 'll probably need to consult the USB 2.0 specification, available online from www.usb.org at no cost, as well as class or device specifications.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4278>4278</a></td>\n' +
            '<td>The only host-side drivers that actually touch hardware (reading/writing registers, handling IRQs, and so on) are the HCDs. In theory, all HCDs provide the same functionality through the same API. In practice, that' + "'" + 's becoming more true on the 2.5 kernels, but there are still differences that crop up especially with fault handling. Different controllers don' + "'" + 't necessarily report the same aspects of failures, and recovery from faults (including software-induced ones like unlinking an URB) isn' + "'" + 't yet fully consistent. Device driver authors should make a point of doing disconnect testing (while the device is active) with each different host controller driver, to make sure drivers don' + "'" + 't have bugs of their own as well as to make sure they aren' + "'" + 't relying on some HCD-specific behavior. (You will need external USB 1.1 and/or USB 2.0 hubs to perform all those tests.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4279>4279</a></td>\n' +
            '<td>USB-Standard Types</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4280>4280</a></td>\n' +
            '<td>In &lt;linux/usb/ch9.h&gt; you will find the USB data types defined in chapter 9 of the USB specification. These data types are used throughout USB, and in APIs including this host side API, gadget APIs, and usbfs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4281>4281</a></td>\n' +
            '<td>!Iinclude/linux/usb/ch9.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4282>4282</a></td>\n' +
            '<td>Host-Side Data Types and Macros</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4283>4283</a></td>\n' +
            '<td>The host side API exposes several layers to drivers, some of which are more necessary than others. These support lifecycle models for host side drivers and devices, and support passing buffers through usbcore to some HCD that performs the I/O for the device driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4284>4284</a></td>\n' +
            '<td>!Iinclude/linux/usb.h</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4285>4285</a></td>\n' +
            '<td>USB Core APIs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4286>4286</a></td>\n' +
            '<td>There are two basic I/O models in the USB API. The most elemental one is asynchronous: drivers submit requests in the form of an URB, and the URB' + "'" + 's completion callback handle the next step. All USB transfer types support that model, although there are special cases for control URBs (which always have setup and status stages, but may not have a data stage) and isochronous URBs (which allow large packets and include per-packet fault reports). Built on top of that is synchronous API support, where a driver calls a routine that allocates one or more URBs, submits them, and waits until they complete. There are synchronous wrappers for single-buffer control and bulk transfers (which are awkward to use in some driver disconnect scenarios), and for scatterlist based streaming i/o (bulk or interrupt).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4287>4287</a></td>\n' +
            '<td>USB drivers need to provide buffers that can be used for DMA, although they don' + "'" + 't necessarily need to provide the DMA mapping themselves. There are APIs to use used when allocating DMA buffers, which can prevent use of bounce buffers on some systems. In some cases, drivers may be able to rely on 64bit DMA to eliminate another kind of bounce buffer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4288>4288</a></td>\n' +
            '<td>!Edrivers/usb/core/urb.c !Edrivers/usb/core/message.c !Edrivers/usb/core/file.c !Edrivers/usb/core/driver.c !Edrivers/usb/core/usb.c !Edrivers/usb/core/hub.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4289>4289</a></td>\n' +
            '<td>Host Controller APIs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4290>4290</a></td>\n' +
            '<td>These APIs are only for use by host controller drivers, most of which implement standard register interfaces such as EHCI, OHCI, or UHCI. UHCI was one of the first interfaces, designed by Intel and also used by VIA; it doesn' + "'" + 't do much in hardware. OHCI was designed later, to have the hardware do more work (bigger transfers, tracking protocol state, and so on). EHCI was designed with USB 2.0; its design has features that resemble OHCI (hardware does much more work) as well as UHCI (some parts of ISO support, TD list processing).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4291>4291</a></td>\n' +
            '<td>There are host controllers other than the "big three", although most PCI based controllers (and a few non-PCI based ones) use one of those interfaces. Not all host controllers use DMA; some use PIO, and there is also a simulator.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4292>4292</a></td>\n' +
            '<td>The same basic APIs are available to drivers for all those controllers. For historical reasons they are in two layers: struct usb_bus is a rather thin layer that became available in the 2.2 kernels, while struct usb_hcd is a more featureful layer (available in later 2.4 kernels and in 2.5) that lets HCDs share common code, to shrink driver size and significantly reduce hcd-specific behaviors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4293>4293</a></td>\n' +
            '<td>!Edrivers/usb/core/hcd.c !Edrivers/usb/core/hcd-pci.c !Idrivers/usb/core/buffer.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4294>4294</a></td>\n' +
            '<td>The USB Filesystem (usbfs)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4295>4295</a></td>\n' +
            '<td>This chapter presents the Linux usbfs. You may prefer to avoid writing new kernel code for your USB driver; that' + "'" + 's the problem that usbfs set out to solve. User mode device drivers are usually packaged as applications or libraries, and may use usbfs through some programming library that wraps it. Such libraries include libusb for C/C++, and jUSB for Java.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4296>4296</a></td>\n' +
            '<td>Note</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4297>4297</a></td>\n' +
            '<td>This particular documentation is incomplete, especially with respect to the asynchronous mode. As of kernel 2.5.66 the code and this (new) documentation need to be cross-reviewed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4298>4298</a></td>\n' +
            '<td>Configure usbfs into Linux kernels by enabling the USB filesystem option (CONFIG_USB_DEVICEFS), and you get basic support for user mode USB device drivers. Until relatively recently it was often (confusingly) called usbdevfs although it wasn' + "'" + 't solving what devfs was. Every USB device will appear in usbfs, regardless of whether or not it has a kernel driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4299>4299</a></td>\n' +
            '<td>What files are in "usbfs"?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4300>4300</a></td>\n' +
            '<td>Conventionally mounted at /proc/bus/usb, usbfs features include:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4301>4301</a></td>\n' +
            '<td>    /proc/bus/usb/devices ... a text file showing each of the USB devices on known to the kernel, and their configuration descriptors. You can also poll() this to learn about new devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4302>4302</a></td>\n' +
            '<td>    /proc/bus/usb/BBB/DDD ... magic files exposing the each device' + "'" + 's configuration descriptors, and supporting a series of ioctls for making device requests, including I/O to devices. (Purely for access by programs.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4303>4303</a></td>\n' +
            '<td>Each bus is given a number (BBB) based on when it was enumerated; within each bus, each device is given a similar number (DDD). Those BBB/DDD paths are not "stable" identifiers; expect them to change even if you always leave the devices plugged in to the same hub port. Don' + "'" + 't even think of saving these in application configuration files. Stable identifiers are available, for user mode applications that want to use them. HID and networking devices expose these stable IDs, so that for example you can be sure that you told the right UPS to power down its second server. "usbfs" doesn' + "'" + 't (yet) expose those IDs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4304>4304</a></td>\n' +
            '<td>Mounting and Access Control</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4305>4305</a></td>\n' +
            '<td>There are a number of mount options for usbfs, which will be of most interest to you if you need to override the default access control policy. That policy is that only root may read or write device files (/proc/bus/BBB/DDD) although anyone may read the devices or drivers files. I/O requests to the device also need the CAP_SYS_RAWIO capability,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4306>4306</a></td>\n' +
            '<td>The significance of that is that by default, all user mode device drivers need super-user privileges. You can change modes or ownership in a driver setup when the device hotplugs, or maye just start the driver right then, as a privileged server (or some activity within one). That' + "'" + 's the most secure approach for multi-user systems, but for single user systems ("trusted" by that user) it' + "'" + 's more convenient just to grant everyone all access (using the devmode=0666 option) so the driver can start whenever it' + "'" + 's needed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4307>4307</a></td>\n' +
            '<td>The mount options for usbfs, usable in /etc/fstab or in command line invocations of mount, are:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4308>4308</a></td>\n' +
            '<td>busgid=NNNNN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4309>4309</a></td>\n' +
            '<td>Controls the GID used for the /proc/bus/usb/BBB directories. (Default: 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4310>4310</a></td>\n' +
            '<td>busmode=MMM</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4311>4311</a></td>\n' +
            '<td>Controls the file mode used for the /proc/bus/usb/BBB directories. (Default: 0555)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4312>4312</a></td>\n' +
            '<td>busuid=NNNNN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4313>4313</a></td>\n' +
            '<td>Controls the UID used for the /proc/bus/usb/BBB directories. (Default: 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4314>4314</a></td>\n' +
            '<td>devgid=NNNNN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4315>4315</a></td>\n' +
            '<td>Controls the GID used for the /proc/bus/usb/BBB/DDD files. (Default: 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4316>4316</a></td>\n' +
            '<td>devmode=MMM</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4317>4317</a></td>\n' +
            '<td>Controls the file mode used for the /proc/bus/usb/BBB/DDD files. (Default: 0644)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4318>4318</a></td>\n' +
            '<td>devuid=NNNNN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4319>4319</a></td>\n' +
            '<td>Controls the UID used for the /proc/bus/usb/BBB/DDD files. (Default: 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4320>4320</a></td>\n' +
            '<td>listgid=NNNNN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4321>4321</a></td>\n' +
            '<td>Controls the GID used for the /proc/bus/usb/devices and drivers files. (Default: 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4322>4322</a></td>\n' +
            '<td>listmode=MMM</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4323>4323</a></td>\n' +
            '<td>Controls the file mode used for the /proc/bus/usb/devices and drivers files. (Default: 0444)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4324>4324</a></td>\n' +
            '<td>listuid=NNNNN</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4325>4325</a></td>\n' +
            '<td>Controls the UID used for the /proc/bus/usb/devices and drivers files. (Default: 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4326>4326</a></td>\n' +
            '<td>Note that many Linux distributions hard-wire the mount options for usbfs in their init scripts, such as /etc/rc.d/rc.sysinit, rather than making it easy to set this per-system policy in /etc/fstab.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4327>4327</a></td>\n' +
            '<td>/proc/bus/usb/devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4328>4328</a></td>\n' +
            '<td>This file is handy for status viewing tools in user mode, which can scan the text format and ignore most of it. More detailed device status (including class and vendor status) is available from device-specific files. For information about the current format of this file, see the Documentation/usb/proc_usb_info.txt file in your Linux kernel sources.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4329>4329</a></td>\n' +
            '<td>This file, in combination with the poll() system call, can also be used to detect when devices are added or removed:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4330>4330</a></td>\n' +
            '<td>int fd;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4331>4331</a></td>\n' +
            '<td>struct pollfd pfd;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4332>4332</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4333>4333</a></td>\n' +
            '<td>fd = open("/proc/bus/usb/devices", O_RDONLY);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4334>4334</a></td>\n' +
            '<td>pfd = { fd, POLLIN, 0 };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4335>4335</a></td>\n' +
            '<td>for (;;) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4336>4336</a></td>\n' +
            '<td>    /* The first time through, this call will return immediately. */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4337>4337</a></td>\n' +
            '<td>    poll(&amp;pfd, 1, -1);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4338>4338</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4339>4339</a></td>\n' +
            '<td>    /* To see what' + "'" + 's changed, compare the file' + "'" + 's previous and current</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4340>4340</a></td>\n' +
            '<td>       contents or scan the filesystem.  (Scanning is more precise.) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4341>4341</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4342>4342</a></td>\n' +
            '<td>Note that this behavior is intended to be used for informational and debug purposes. It would be more appropriate to use programs such as udev or HAL to initialize a device or start a user-mode helper program, for instance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4343>4343</a></td>\n' +
            '<td>/proc/bus/usb/BBB/DDD</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4344>4344</a></td>\n' +
            '<td>Use these files in one of these basic ways:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4345>4345</a></td>\n' +
            '<td>They can be read, producing first the device descriptor (18 bytes) and then the descriptors for the current configuration. See the USB 2.0 spec for details about those binary data formats. You' + "'" + 'll need to convert most multibyte values from little endian format to your native host byte order, although a few of the fields in the device descriptor (both of the BCD-encoded fields, and the vendor and product IDs) will be byteswapped for you. Note that configuration descriptors include descriptors for interfaces, altsettings, endpoints, and maybe additional class descriptors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4346>4346</a></td>\n' +
            '<td>Perform USB operations using ioctl() requests to make endpoint I/O requests (synchronously or asynchronously) or manage the device. These requests need the CAP_SYS_RAWIO capability, as well as filesystem access permissions. Only one ioctl request can be made on one of these device files at a time. This means that if you are synchronously reading an endpoint from one thread, you won' + "'" + 't be able to write to a different endpoint from another thread until the read completes. This works for half duplex protocols, but otherwise you' + "'" + 'd use asynchronous i/o requests.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4347>4347</a></td>\n' +
            '<td>Life Cycle of User Mode Drivers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4348>4348</a></td>\n' +
            '<td>Such a driver first needs to find a device file for a device it knows how to handle. Maybe it was told about it because a /sbin/hotplug event handling agent chose that driver to handle the new device. Or maybe it' + "'" + 's an application that scans all the /proc/bus/usb device files, and ignores most devices. In either case, it should read() all the descriptors from the device file, and check them against what it knows how to handle. It might just reject everything except a particular vendor and product ID, or need a more complex policy.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4349>4349</a></td>\n' +
            '<td>Never assume there will only be one such device on the system at a time! If your code can' + "'" + 't handle more than one device at a time, at least detect when there' + "'" + 's more than one, and have your users choose which device to use.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4350>4350</a></td>\n' +
            '<td>Once your user mode driver knows what device to use, it interacts with it in either of two styles. The simple style is to make only control requests; some devices don' + "'" + 't need more complex interactions than those. (An example might be software using vendor-specific control requests for some initialization or configuration tasks, with a kernel driver for the rest.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4351>4351</a></td>\n' +
            '<td>More likely, you need a more complex style driver: one using non-control endpoints, reading or writing data and claiming exclusive use of an interface. Bulk transfers are easiest to use, but only their sibling interrupt transfers work with low speed devices. Both interrupt and isochronous transfers offer service guarantees because their bandwidth is reserved. Such "periodic" transfers are awkward to use through usbfs, unless you' + "'" + 're using the asynchronous calls. However, interrupt transfers can also be used in a synchronous "one shot" style.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4352>4352</a></td>\n' +
            '<td>Your user-mode driver should never need to worry about cleaning up request state when the device is disconnected, although it should close its open file descriptors as soon as it starts seeing the ENODEV errors.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4353>4353</a></td>\n' +
            '<td>The ioctl() Requests</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4354>4354</a></td>\n' +
            '<td>To use these ioctls, you need to include the following headers in your userspace program:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4355>4355</a></td>\n' +
            '<td>#include &lt;linux/usb.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4356>4356</a></td>\n' +
            '<td>#include &lt;linux/usbdevice_fs.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4357>4357</a></td>\n' +
            '<td>#include &lt;asm/byteorder.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4358>4358</a></td>\n' +
            '<td>The standard USB device model requests, from "Chapter 9" of the USB 2.0 specification, are automatically included from the &lt;linux/usb/ch9.h&gt; header.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4359>4359</a></td>\n' +
            '<td>Unless noted otherwise, the ioctl requests described here will update the modification time on the usbfs file to which they are applied (unless they fail). A return of zero indicates success; otherwise, a standard USB error code is returned. (These are documented in Documentation/usb/error-codes.txt in your kernel sources.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4360>4360</a></td>\n' +
            '<td>Each of these files multiplexes access to several I/O streams, one per endpoint. Each device has one control endpoint (endpoint zero) which supports a limited RPC style RPC access. Devices are configured by khubd (in the kernel) setting a device-wide configuration that affects things like power consumption and basic functionality. The endpoints are part of USB interfaces, which may have altsettings affecting things like which endpoints are available. Many devices only have a single configuration and interface, so drivers for them will ignore configurations and altsettings.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4361>4361</a></td>\n' +
            '<td>Management/Status Requests</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4362>4362</a></td>\n' +
            '<td>A number of usbfs requests don' + "'" + 't deal very directly with device I/O. They mostly relate to device management and status. These are all synchronous requests.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4363>4363</a></td>\n' +
            '<td>USBDEVFS_CLAIMINTERFACE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4364>4364</a></td>\n' +
            '<td>This is used to force usbfs to claim a specific interface, which has not previously been claimed by usbfs or any other kernel driver. The ioctl parameter is an integer holding the number of the interface (bInterfaceNumber from descriptor).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4365>4365</a></td>\n' +
            '<td>Note that if your driver doesn' + "'" + 't claim an interface before trying to use one of its endpoints, and no other driver has bound to it, then the interface is automatically claimed by usbfs.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4366>4366</a></td>\n' +
            '<td>This claim will be released by a RELEASEINTERFACE ioctl, or by closing the file descriptor. File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4367>4367</a></td>\n' +
            '<td>USBDEVFS_CONNECTINFO</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4368>4368</a></td>\n' +
            '<td>Says whether the device is lowspeed. The ioctl parameter points to a structure like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4369>4369</a></td>\n' +
            '<td>struct usbdevfs_connectinfo {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4370>4370</a></td>\n' +
            '<td>        unsigned int   devnum;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4371>4371</a></td>\n' +
            '<td>        unsigned char  slow;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4372>4372</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4373>4373</a></td>\n' +
            '<td>File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4374>4374</a></td>\n' +
            '<td>You can' + "'" + 't tell whether a "not slow" device is connected at high speed (480 MBit/sec) or just full speed (12 MBit/sec). You should know the devnum value already, it' + "'" + 's the DDD value of the device file name.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4375>4375</a></td>\n' +
            '<td>USBDEVFS_GETDRIVER</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4376>4376</a></td>\n' +
            '<td>Returns the name of the kernel driver bound to a given interface (a string). Parameter is a pointer to this structure, which is modified:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4377>4377</a></td>\n' +
            '<td>struct usbdevfs_getdriver {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4378>4378</a></td>\n' +
            '<td>        unsigned int  interface;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4379>4379</a></td>\n' +
            '<td>        char          driver[USBDEVFS_MAXDRIVERNAME + 1];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4380>4380</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4381>4381</a></td>\n' +
            '<td>File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4382>4382</a></td>\n' +
            '<td>USBDEVFS_IOCTL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4383>4383</a></td>\n' +
            '<td>Passes a request from userspace through to a kernel driver that has an ioctl entry in the struct usb_driver it registered.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4384>4384</a></td>\n' +
            '<td>struct usbdevfs_ioctl {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4385>4385</a></td>\n' +
            '<td>        int     ifno;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4386>4386</a></td>\n' +
            '<td>        int     ioctl_code;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4387>4387</a></td>\n' +
            '<td>        void    *data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4388>4388</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4389>4389</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4390>4390</a></td>\n' +
            '<td>/* user mode call looks like this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4391>4391</a></td>\n' +
            '<td> * ' + "'" + 'request' + "'" + ' becomes the driver-&gt;ioctl() ' + "'" + 'code' + "'" + ' parameter.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4392>4392</a></td>\n' +
            '<td> * the size of ' + "'" + 'param' + "'" + ' is encoded in ' + "'" + 'request' + "'" + ', and that data</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4393>4393</a></td>\n' +
            '<td> * is copied to or from the driver-&gt;ioctl() ' + "'" + 'buf' + "'" + ' parameter.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4394>4394</a></td>\n' +
            '<td> */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4395>4395</a></td>\n' +
            '<td>static int</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4396>4396</a></td>\n' +
            '<td>usbdev_ioctl (int fd, int ifno, unsigned request, void *param)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4397>4397</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4398>4398</a></td>\n' +
            '<td>        struct usbdevfs_ioctl   wrapper;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4399>4399</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4400>4400</a></td>\n' +
            '<td>        wrapper.ifno = ifno;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4401>4401</a></td>\n' +
            '<td>        wrapper.ioctl_code = request;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4402>4402</a></td>\n' +
            '<td>        wrapper.data = param;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4403>4403</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4404>4404</a></td>\n' +
            '<td>        return ioctl (fd, USBDEVFS_IOCTL, &amp;wrapper);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4405>4405</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4406>4406</a></td>\n' +
            '<td>File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4407>4407</a></td>\n' +
            '<td>This request lets kernel drivers talk to user mode code through filesystem operations even when they don' + "'" + 't create a character or block special device. It' + "'" + 's also been used to do things like ask devices what device special file should be used. Two pre-defined ioctls are used to disconnect and reconnect kernel drivers, so that user mode code can completely manage binding and configuration of devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4408>4408</a></td>\n' +
            '<td>USBDEVFS_RELEASEINTERFACE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4409>4409</a></td>\n' +
            '<td>This is used to release the claim usbfs made on interface, either implicitly or because of a USBDEVFS_CLAIMINTERFACE call, before the file descriptor is closed. The ioctl parameter is an integer holding the number of the interface (bInterfaceNumber from descriptor); File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4410>4410</a></td>\n' +
            '<td>Warning</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4411>4411</a></td>\n' +
            '<td>No security check is made to ensure that the task which made the claim is the one which is releasing it. This means that user mode driver may interfere other ones.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4412>4412</a></td>\n' +
            '<td>USBDEVFS_RESETEP</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4413>4413</a></td>\n' +
            '<td>Resets the data toggle value for an endpoint (bulk or interrupt) to DATA0. The ioctl parameter is an integer endpoint number (1 to 15, as identified in the endpoint descriptor), with USB_DIR_IN added if the device' + "'" + 's endpoint sends data to the host.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4414>4414</a></td>\n' +
            '<td>Warning</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4415>4415</a></td>\n' +
            '<td>Avoid using this request. It should probably be removed. Using it typically means the device and driver will lose toggle synchronization. If you really lost synchronization, you likely need to completely handshake with the device, using a request like CLEAR_HALT or SET_INTERFACE.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4416>4416</a></td>\n' +
            '<td>Synchronous I/O Support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4417>4417</a></td>\n' +
            '<td>Synchronous requests involve the kernel blocking until the user mode request completes, either by finishing successfully or by reporting an error. In most cases this is the simplest way to use usbfs, although as noted above it does prevent performing I/O to more than one endpoint at a time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4418>4418</a></td>\n' +
            '<td>USBDEVFS_BULK</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4419>4419</a></td>\n' +
            '<td>Issues a bulk read or write request to the device. The ioctl parameter is a pointer to this structure:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4420>4420</a></td>\n' +
            '<td>struct usbdevfs_bulktransfer {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4421>4421</a></td>\n' +
            '<td>        unsigned int  ep;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4422>4422</a></td>\n' +
            '<td>        unsigned int  len;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4423>4423</a></td>\n' +
            '<td>        unsigned int  timeout; /* in milliseconds */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4424>4424</a></td>\n' +
            '<td>        void          *data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4425>4425</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4426>4426</a></td>\n' +
            '<td>The "ep" value identifies a bulk endpoint number (1 to 15, as identified in an endpoint descriptor), masked with USB_DIR_IN when referring to an endpoint which sends data to the host from the device. The length of the data buffer is identified by "len"; Recent kernels support requests up to about 128KBytes. FIXME say how read length is returned, and how short reads are handled..</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4427>4427</a></td>\n' +
            '<td>USBDEVFS_CLEAR_HALT</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4428>4428</a></td>\n' +
            '<td>Clears endpoint halt (stall) and resets the endpoint toggle. This is only meaningful for bulk or interrupt endpoints. The ioctl parameter is an integer endpoint number (1 to 15, as identified in an endpoint descriptor), masked with USB_DIR_IN when referring to an endpoint which sends data to the host from the device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4429>4429</a></td>\n' +
            '<td>Use this on bulk or interrupt endpoints which have stalled, returning -EPIPE status to a data transfer request. Do not issue the control request directly, since that could invalidate the host' + "'" + 's record of the data toggle.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4430>4430</a></td>\n' +
            '<td>USBDEVFS_CONTROL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4431>4431</a></td>\n' +
            '<td>Issues a control request to the device. The ioctl parameter points to a structure like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4432>4432</a></td>\n' +
            '<td>struct usbdevfs_ctrltransfer {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4433>4433</a></td>\n' +
            '<td>        __u8   bRequestType;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4434>4434</a></td>\n' +
            '<td>        __u8   bRequest;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4435>4435</a></td>\n' +
            '<td>        __u16  wValue;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4436>4436</a></td>\n' +
            '<td>        __u16  wIndex;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4437>4437</a></td>\n' +
            '<td>        __u16  wLength;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4438>4438</a></td>\n' +
            '<td>        __u32  timeout;  /* in milliseconds */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4439>4439</a></td>\n' +
            '<td>        void   *data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4440>4440</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4441>4441</a></td>\n' +
            '<td>The first eight bytes of this structure are the contents of the SETUP packet to be sent to the device; see the USB 2.0 specification for details. The bRequestType value is composed by combining a USB_TYPE_* value, a USB_DIR_* value, and a USB_RECIP_* value (from &lt;linux/usb.h&gt;). If wLength is nonzero, it describes the length of the data buffer, which is either written to the device (USB_DIR_OUT) or read from the device (USB_DIR_IN).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4442>4442</a></td>\n' +
            '<td>At this writing, you can' + "'" + 't transfer more than 4 KBytes of data to or from a device; usbfs has a limit, and some host controller drivers have a limit. (That' + "'" + 's not usually a problem.) Also there' + "'" + 's no way to say it' + "'" + 's not OK to get a short read back from the device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4443>4443</a></td>\n' +
            '<td>USBDEVFS_RESET</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4444>4444</a></td>\n' +
            '<td>Does a USB level device reset. The ioctl parameter is ignored. After the reset, this rebinds all device interfaces. File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4445>4445</a></td>\n' +
            '<td>Warning</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4446>4446</a></td>\n' +
            '<td>Avoid using this call until some usbcore bugs get fixed, since it does not fully synchronize device, interface, and driver (not just usbfs) state.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4447>4447</a></td>\n' +
            '<td>USBDEVFS_SETINTERFACE</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4448>4448</a></td>\n' +
            '<td>Sets the alternate setting for an interface. The ioctl parameter is a pointer to a structure like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4449>4449</a></td>\n' +
            '<td>struct usbdevfs_setinterface {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4450>4450</a></td>\n' +
            '<td>        unsigned int  interface;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4451>4451</a></td>\n' +
            '<td>        unsigned int  altsetting;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4452>4452</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4453>4453</a></td>\n' +
            '<td>File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4454>4454</a></td>\n' +
            '<td>Those struct members are from some interface descriptor applying to the current configuration. The interface number is the bInterfaceNumber value, and the altsetting number is the bAlternateSetting value. (This resets each endpoint in the interface.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4455>4455</a></td>\n' +
            '<td>USBDEVFS_SETCONFIGURATION</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4456>4456</a></td>\n' +
            '<td>Issues the usb_set_configuration call for the device. The parameter is an integer holding the number of a configuration (bConfigurationValue from descriptor). File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4457>4457</a></td>\n' +
            '<td>Warning</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4458>4458</a></td>\n' +
            '<td>Avoid using this call until some usbcore bugs get fixed, since it does not fully synchronize device, interface, and driver (not just usbfs) state.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4459>4459</a></td>\n' +
            '<td>Asynchronous I/O Support</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4460>4460</a></td>\n' +
            '<td>As mentioned above, there are situations where it may be important to initiate concurrent operations from user mode code. This is particularly important for periodic transfers (interrupt and isochronous), but it can be used for other kinds of USB requests too. In such cases, the asynchronous requests described here are essential. Rather than submitting one request and having the kernel block until it completes, the blocking is separate.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4461>4461</a></td>\n' +
            '<td>These requests are packaged into a structure that resembles the URB used by kernel device drivers. (No POSIX Async I/O support here, sorry.) It identifies the endpoint type (USBDEVFS_URB_TYPE_*), endpoint (number, masked with USB_DIR_IN as appropriate), buffer and length, and a user "context" value serving to uniquely identify each request. (It' + "'" + 's usually a pointer to per-request data.) Flags can modify requests (not as many as supported for kernel drivers).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4462>4462</a></td>\n' +
            '<td>Each request can specify a realtime signal number (between SIGRTMIN and SIGRTMAX, inclusive) to request a signal be sent when the request completes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4463>4463</a></td>\n' +
            '<td>When usbfs returns these urbs, the status value is updated, and the buffer may have been modified. Except for isochronous transfers, the actual_length is updated to say how many bytes were transferred; if the USBDEVFS_URB_DISABLE_SPD flag is set ("short packets are not OK"), if fewer bytes were read than were requested then you get an error report.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4464>4464</a></td>\n' +
            '<td>struct usbdevfs_iso_packet_desc {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4465>4465</a></td>\n' +
            '<td>        unsigned int                     length;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4466>4466</a></td>\n' +
            '<td>        unsigned int                     actual_length;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4467>4467</a></td>\n' +
            '<td>        unsigned int                     status;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4468>4468</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4469>4469</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4470>4470</a></td>\n' +
            '<td>struct usbdevfs_urb {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4471>4471</a></td>\n' +
            '<td>        unsigned char                    type;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4472>4472</a></td>\n' +
            '<td>        unsigned char                    endpoint;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4473>4473</a></td>\n' +
            '<td>        int                              status;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4474>4474</a></td>\n' +
            '<td>        unsigned int                     flags;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4475>4475</a></td>\n' +
            '<td>        void                             *buffer;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4476>4476</a></td>\n' +
            '<td>        int                              buffer_length;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4477>4477</a></td>\n' +
            '<td>        int                              actual_length;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4478>4478</a></td>\n' +
            '<td>        int                              start_frame;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4479>4479</a></td>\n' +
            '<td>        int                              number_of_packets;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4480>4480</a></td>\n' +
            '<td>        int                              error_count;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4481>4481</a></td>\n' +
            '<td>        unsigned int                     signr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4482>4482</a></td>\n' +
            '<td>        void                             *usercontext;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4483>4483</a></td>\n' +
            '<td>        struct usbdevfs_iso_packet_desc  iso_frame_desc[];</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4484>4484</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4485>4485</a></td>\n' +
            '<td>For these asynchronous requests, the file modification time reflects when the request was initiated. This contrasts with their use with the synchronous requests, where it reflects when requests complete.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4486>4486</a></td>\n' +
            '<td>USBDEVFS_DISCARDURB</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4487>4487</a></td>\n' +
            '<td>TBS File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4488>4488</a></td>\n' +
            '<td>USBDEVFS_DISCSIGNAL</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4489>4489</a></td>\n' +
            '<td>TBS File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4490>4490</a></td>\n' +
            '<td>USBDEVFS_REAPURB</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4491>4491</a></td>\n' +
            '<td>TBS File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4492>4492</a></td>\n' +
            '<td>USBDEVFS_REAPURBNDELAY</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4493>4493</a></td>\n' +
            '<td>TBS File modification time is not updated by this request.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4494>4494</a></td>\n' +
            '<td>USBDEVFS_SUBMITURB</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4495>4495</a></td>\n' +
            '<td>TBS</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4496>4496</a></td>\n' +
            '<td>Preface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4497>4497</a></td>\n' +
            '<td>This document describes how to write an ALSA (Advanced Linux Sound Architecture) driver. The document focuses mainly on PCI soundcards. In the case of other device types, the API might be different, too. However, at least the ALSA kernel API is consistent, and therefore it would be still a bit help for writing them.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4498>4498</a></td>\n' +
            '<td>This document targets people who already have enough C language skills and have basic linux kernel programming knowledge. This document doesn' + "'" + 't explain the general topic of linux kernel coding and doesn' + "'" + 't cover low-level driver implementation details. It only describes the standard way to write a PCI sound driver on ALSA.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4499>4499</a></td>\n' +
            '<td>If you are already familiar with the older ALSA ver.0.5.x API, you can check the drivers such as sound/pci/es1938.c or sound/pci/maestro3.c which have also almost the same code-base in the ALSA 0.5.x tree, so you can compare the differences.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4500>4500</a></td>\n' +
            '<td>This document is still a draft version. Any feedback and corrections, please!!</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4501>4501</a></td>\n' +
            '<td>File Tree Structure</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4502>4502</a></td>\n' +
            '<td>General</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4503>4503</a></td>\n' +
            '<td>The ALSA drivers are provided in two ways.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4504>4504</a></td>\n' +
            '<td>One is the trees provided as a tarball or via cvs from the ALSA' + "'" + 's ftp site, and another is the 2.6 (or later) Linux kernel tree. To synchronize both, the ALSA driver tree is split into two different trees: alsa-kernel and alsa-driver. The former contains purely the source code for the Linux 2.6 (or later) tree. This tree is designed only for compilation on 2.6 or later environment. The latter, alsa-driver, contains many subtle files for compiling ALSA drivers outside of the Linux kernel tree, wrapper functions for older 2.2 and 2.4 kernels, to adapt the latest kernel API, and additional drivers which are still in development or in tests. The drivers in alsa-driver tree will be moved to alsa-kernel (and eventually to the 2.6 kernel tree) when they are finished and confirmed to work fine.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4505>4505</a></td>\n' +
            '<td>The file tree structure of ALSA driver is depicted below. Both alsa-kernel and alsa-driver have almost the same file structure, except for core directory. It' + "'" + 's named as acore in alsa-driver tree.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4506>4506</a></td>\n' +
            '<td>        sound</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4507>4507</a></td>\n' +
            '<td>                /core</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4508>4508</a></td>\n' +
            '<td>                        /oss</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4509>4509</a></td>\n' +
            '<td>                        /seq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4510>4510</a></td>\n' +
            '<td>                                /oss</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4511>4511</a></td>\n' +
            '<td>                                /instr</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4512>4512</a></td>\n' +
            '<td>                /ioctl32</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4513>4513</a></td>\n' +
            '<td>                /include</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4514>4514</a></td>\n' +
            '<td>                /drivers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4515>4515</a></td>\n' +
            '<td>                        /mpu401</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4516>4516</a></td>\n' +
            '<td>                        /opl3</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4517>4517</a></td>\n' +
            '<td>                /i2c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4518>4518</a></td>\n' +
            '<td>                        /l3</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4519>4519</a></td>\n' +
            '<td>                /synth</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4520>4520</a></td>\n' +
            '<td>                        /emux</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4521>4521</a></td>\n' +
            '<td>                /pci</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4522>4522</a></td>\n' +
            '<td>                        /(cards)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4523>4523</a></td>\n' +
            '<td>                /isa</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4524>4524</a></td>\n' +
            '<td>                        /(cards)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4525>4525</a></td>\n' +
            '<td>                /arm</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4526>4526</a></td>\n' +
            '<td>                /ppc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4527>4527</a></td>\n' +
            '<td>                /sparc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4528>4528</a></td>\n' +
            '<td>                /usb</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4529>4529</a></td>\n' +
            '<td>                /pcmcia /(cards)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4530>4530</a></td>\n' +
            '<td>                /oss</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4531>4531</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4532>4532</a></td>\n' +
            '<td>core directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4533>4533</a></td>\n' +
            '<td>This directory contains the middle layer which is the heart of ALSA drivers. In this directory, the native ALSA modules are stored. The sub-directories contain different modules and are dependent upon the kernel config.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4534>4534</a></td>\n' +
            '<td>core/oss</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4535>4535</a></td>\n' +
            '<td>The codes for PCM and mixer OSS emulation modules are stored in this directory. The rawmidi OSS emulation is included in the ALSA rawmidi code since it' + "'" + 's quite small. The sequencer code is stored in core/seq/oss directory (see below).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4536>4536</a></td>\n' +
            '<td>core/ioctl32</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4537>4537</a></td>\n' +
            '<td>This directory contains the 32bit-ioctl wrappers for 64bit architectures such like x86-64, ppc64 and sparc64. For 32bit and alpha architectures, these are not compiled.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4538>4538</a></td>\n' +
            '<td>core/seq</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4539>4539</a></td>\n' +
            '<td>This directory and its sub-directories are for the ALSA sequencer. This directory contains the sequencer core and primary sequencer modules such like snd-seq-midi, snd-seq-virmidi, etc. They are compiled only when CONFIG_SND_SEQUENCER is set in the kernel config.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4540>4540</a></td>\n' +
            '<td>core/seq/oss</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4541>4541</a></td>\n' +
            '<td>This contains the OSS sequencer emulation codes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4542>4542</a></td>\n' +
            '<td>core/seq/instr</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4543>4543</a></td>\n' +
            '<td>This directory contains the modules for the sequencer instrument layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4544>4544</a></td>\n' +
            '<td>include directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4545>4545</a></td>\n' +
            '<td>This is the place for the public header files of ALSA drivers, which are to be exported to user-space, or included by several files at different directories. Basically, the private header files should not be placed in this directory, but you may still find files there, due to historical reasons :)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4546>4546</a></td>\n' +
            '<td>drivers directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4547>4547</a></td>\n' +
            '<td>This directory contains code shared among different drivers on different architectures. They are hence supposed not to be architecture-specific. For example, the dummy pcm driver and the serial MIDI driver are found in this directory. In the sub-directories, there is code for components which are independent from bus and cpu architectures.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4548>4548</a></td>\n' +
            '<td>drivers/mpu401</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4549>4549</a></td>\n' +
            '<td>The MPU401 and MPU401-UART modules are stored here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4550>4550</a></td>\n' +
            '<td>drivers/opl3 and opl4</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4551>4551</a></td>\n' +
            '<td>The OPL3 and OPL4 FM-synth stuff is found here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4552>4552</a></td>\n' +
            '<td>i2c directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4553>4553</a></td>\n' +
            '<td>This contains the ALSA i2c components.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4554>4554</a></td>\n' +
            '<td>Although there is a standard i2c layer on Linux, ALSA has its own i2c code for some cards, because the soundcard needs only a simple operation and the standard i2c API is too complicated for such a purpose.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4555>4555</a></td>\n' +
            '<td>i2c/l3</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4556>4556</a></td>\n' +
            '<td>This is a sub-directory for ARM L3 i2c.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4557>4557</a></td>\n' +
            '<td>synth directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4558>4558</a></td>\n' +
            '<td>This contains the synth middle-level modules.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4559>4559</a></td>\n' +
            '<td>So far, there is only Emu8000/Emu10k1 synth driver under the synth/emux sub-directory.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4560>4560</a></td>\n' +
            '<td>pci directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4561>4561</a></td>\n' +
            '<td>This directory and its sub-directories hold the top-level card modules for PCI soundcards and the code specific to the PCI BUS.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4562>4562</a></td>\n' +
            '<td>The drivers compiled from a single file are stored directly in the pci directory, while the drivers with several source files are stored on their own sub-directory (e.g. emu10k1, ice1712).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4563>4563</a></td>\n' +
            '<td>isa directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4564>4564</a></td>\n' +
            '<td>This directory and its sub-directories hold the top-level card modules for ISA soundcards.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4565>4565</a></td>\n' +
            '<td>arm, ppc, and sparc directories</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4566>4566</a></td>\n' +
            '<td>They are used for top-level card modules which are specific to one of these architectures.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4567>4567</a></td>\n' +
            '<td>usb directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4568>4568</a></td>\n' +
            '<td>This directory contains the USB-audio driver. In the latest version, the USB MIDI driver is integrated in the usb-audio driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4569>4569</a></td>\n' +
            '<td>pcmcia directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4570>4570</a></td>\n' +
            '<td>The PCMCIA, especially PCCard drivers will go here. CardBus drivers will be in the pci directory, because their API is identical to that of standard PCI cards.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4571>4571</a></td>\n' +
            '<td>oss directory</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4572>4572</a></td>\n' +
            '<td>The OSS/Lite source files are stored here in Linux 2.6 (or later) tree. In the ALSA driver tarball, this directory is empty, of course :)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4573>4573</a></td>\n' +
            '<td>Basic Flow for PCI Drivers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4574>4574</a></td>\n' +
            '<td>Outline</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4575>4575</a></td>\n' +
            '<td>The minimum flow for PCI soundcards is as follows:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4576>4576</a></td>\n' +
            '<td>    define the PCI ID table (see the section PCI Entries).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4577>4577</a></td>\n' +
            '<td>    create probe() callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4578>4578</a></td>\n' +
            '<td>    create remove() callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4579>4579</a></td>\n' +
            '<td>    create a pci_driver structure containing the three pointers above.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4580>4580</a></td>\n' +
            '<td>    create an init() function just calling the pci_register_driver() to register the pci_driver table defined above.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4581>4581</a></td>\n' +
            '<td>    create an exit() function to call the pci_unregister_driver() function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4582>4582</a></td>\n' +
            '<td>Full Code Example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4583>4583</a></td>\n' +
            '<td>The code example is shown below. Some parts are kept unimplemented at this moment but will be filled in the next sections. The numbers in the comment lines of the snd_mychip_probe() function refer to details explained in the following section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4584>4584</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4585>4585</a></td>\n' +
            '<td>  #include &lt;linux/init.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4586>4586</a></td>\n' +
            '<td>  #include &lt;linux/pci.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4587>4587</a></td>\n' +
            '<td>  #include &lt;linux/slab.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4588>4588</a></td>\n' +
            '<td>  #include &lt;sound/core.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4589>4589</a></td>\n' +
            '<td>  #include &lt;sound/initval.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4590>4590</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4591>4591</a></td>\n' +
            '<td>  /* module parameters (see "Module Parameters") */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4592>4592</a></td>\n' +
            '<td>  /* SNDRV_CARDS: maximum number of cards supported by this module */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4593>4593</a></td>\n' +
            '<td>  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4594>4594</a></td>\n' +
            '<td>  static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4595>4595</a></td>\n' +
            '<td>  static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4596>4596</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4597>4597</a></td>\n' +
            '<td>  /* definition of the chip-specific record */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4598>4598</a></td>\n' +
            '<td>  struct mychip {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4599>4599</a></td>\n' +
            '<td>          struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4600>4600</a></td>\n' +
            '<td>          /* the rest of the implementation will be in section</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4601>4601</a></td>\n' +
            '<td>           * "PCI Resource Management"</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4602>4602</a></td>\n' +
            '<td>           */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4603>4603</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4604>4604</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4605>4605</a></td>\n' +
            '<td>  /* chip-specific destructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4606>4606</a></td>\n' +
            '<td>   * (see "PCI Resource Management")</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4607>4607</a></td>\n' +
            '<td>   */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4608>4608</a></td>\n' +
            '<td>  static int snd_mychip_free(struct mychip *chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4609>4609</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4610>4610</a></td>\n' +
            '<td>          .... /* will be implemented later... */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4611>4611</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4612>4612</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4613>4613</a></td>\n' +
            '<td>  /* component-destructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4614>4614</a></td>\n' +
            '<td>   * (see "Management of Cards and Components")</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4615>4615</a></td>\n' +
            '<td>   */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4616>4616</a></td>\n' +
            '<td>  static int snd_mychip_dev_free(struct snd_device *device)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4617>4617</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4618>4618</a></td>\n' +
            '<td>          return snd_mychip_free(device-&gt;device_data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4619>4619</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4620>4620</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4621>4621</a></td>\n' +
            '<td>  /* chip-specific constructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4622>4622</a></td>\n' +
            '<td>   * (see "Management of Cards and Components")</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4623>4623</a></td>\n' +
            '<td>   */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4624>4624</a></td>\n' +
            '<td>  static int snd_mychip_create(struct snd_card *card,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4625>4625</a></td>\n' +
            '<td>                               struct pci_dev *pci,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4626>4626</a></td>\n' +
            '<td>                               struct mychip **rchip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4627>4627</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4628>4628</a></td>\n' +
            '<td>          struct mychip *chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4629>4629</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4630>4630</a></td>\n' +
            '<td>          static struct snd_device_ops ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4631>4631</a></td>\n' +
            '<td>                 .dev_free = snd_mychip_dev_free,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4632>4632</a></td>\n' +
            '<td>          };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4633>4633</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4634>4634</a></td>\n' +
            '<td>          *rchip = NULL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4635>4635</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4636>4636</a></td>\n' +
            '<td>          /* check PCI availability here</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4637>4637</a></td>\n' +
            '<td>           * (see "PCI Resource Management")</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4638>4638</a></td>\n' +
            '<td>           */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4639>4639</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4640>4640</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4641>4641</a></td>\n' +
            '<td>          /* allocate a chip-specific data with zero filled */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4642>4642</a></td>\n' +
            '<td>          chip = kzalloc(sizeof(*chip), GFP_KERNEL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4643>4643</a></td>\n' +
            '<td>          if (chip == NULL)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4644>4644</a></td>\n' +
            '<td>                  return -ENOMEM;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4645>4645</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4646>4646</a></td>\n' +
            '<td>          chip-&gt;card = card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4647>4647</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4648>4648</a></td>\n' +
            '<td>          /* rest of initialization here; will be implemented</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4649>4649</a></td>\n' +
            '<td>           * later, see "PCI Resource Management"</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4650>4650</a></td>\n' +
            '<td>           */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4651>4651</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4652>4652</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4653>4653</a></td>\n' +
            '<td>          err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4654>4654</a></td>\n' +
            '<td>          if (err &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4655>4655</a></td>\n' +
            '<td>                  snd_mychip_free(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4656>4656</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4657>4657</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4658>4658</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4659>4659</a></td>\n' +
            '<td>          snd_card_set_dev(card, &amp;pci-&gt;dev);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4660>4660</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4661>4661</a></td>\n' +
            '<td>          *rchip = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4662>4662</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4663>4663</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4664>4664</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4665>4665</a></td>\n' +
            '<td>  /* constructor -- see "Constructor" sub-section */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4666>4666</a></td>\n' +
            '<td>  static int snd_mychip_probe(struct pci_dev *pci,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4667>4667</a></td>\n' +
            '<td>                              const struct pci_device_id *pci_id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4668>4668</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4669>4669</a></td>\n' +
            '<td>          static int dev;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4670>4670</a></td>\n' +
            '<td>          struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4671>4671</a></td>\n' +
            '<td>          struct mychip *chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4672>4672</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4673>4673</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4674>4674</a></td>\n' +
            '<td>          /* (1) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4675>4675</a></td>\n' +
            '<td>          if (dev &gt;= SNDRV_CARDS)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4676>4676</a></td>\n' +
            '<td>                  return -ENODEV;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4677>4677</a></td>\n' +
            '<td>          if (!enable[dev]) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4678>4678</a></td>\n' +
            '<td>                  dev++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4679>4679</a></td>\n' +
            '<td>                  return -ENOENT;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4680>4680</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4681>4681</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4682>4682</a></td>\n' +
            '<td>          /* (2) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4683>4683</a></td>\n' +
            '<td>          err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4684>4684</a></td>\n' +
            '<td>          if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4685>4685</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4686>4686</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4687>4687</a></td>\n' +
            '<td>          /* (3) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4688>4688</a></td>\n' +
            '<td>          err = snd_mychip_create(card, pci, &amp;chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4689>4689</a></td>\n' +
            '<td>          if (err &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4690>4690</a></td>\n' +
            '<td>                  snd_card_free(card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4691>4691</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4692>4692</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4693>4693</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4694>4694</a></td>\n' +
            '<td>          /* (4) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4695>4695</a></td>\n' +
            '<td>          strcpy(card-&gt;driver, "My Chip");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4696>4696</a></td>\n' +
            '<td>          strcpy(card-&gt;shortname, "My Own Chip 123");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4697>4697</a></td>\n' +
            '<td>          sprintf(card-&gt;longname, "%s at 0x%lx irq %i",</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4698>4698</a></td>\n' +
            '<td>                  card-&gt;shortname, chip-&gt;ioport, chip-&gt;irq);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4699>4699</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4700>4700</a></td>\n' +
            '<td>          /* (5) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4701>4701</a></td>\n' +
            '<td>          .... /* implemented later */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4702>4702</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4703>4703</a></td>\n' +
            '<td>          /* (6) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4704>4704</a></td>\n' +
            '<td>          err = snd_card_register(card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4705>4705</a></td>\n' +
            '<td>          if (err &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4706>4706</a></td>\n' +
            '<td>                  snd_card_free(card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4707>4707</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4708>4708</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4709>4709</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4710>4710</a></td>\n' +
            '<td>          /* (7) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4711>4711</a></td>\n' +
            '<td>          pci_set_drvdata(pci, card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4712>4712</a></td>\n' +
            '<td>          dev++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4713>4713</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4714>4714</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4715>4715</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4716>4716</a></td>\n' +
            '<td>  /* destructor -- see the "Destructor" sub-section */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4717>4717</a></td>\n' +
            '<td>  static void snd_mychip_remove(struct pci_dev *pci)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4718>4718</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4719>4719</a></td>\n' +
            '<td>          snd_card_free(pci_get_drvdata(pci));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4720>4720</a></td>\n' +
            '<td>          pci_set_drvdata(pci, NULL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4721>4721</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4722>4722</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4723>4723</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4724>4724</a></td>\n' +
            '<td>Constructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4725>4725</a></td>\n' +
            '<td>The real constructor of PCI drivers is the probe callback. The probe callback and other component-constructors which are called from the probe callback cannot be used with the __init prefix because any PCI device could be a hotplug device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4726>4726</a></td>\n' +
            '<td>In the probe callback, the following scheme is often used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4727>4727</a></td>\n' +
            '<td>1) Check and increment the device index.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4728>4728</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4729>4729</a></td>\n' +
            '<td>  static int dev;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4730>4730</a></td>\n' +
            '<td>  ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4731>4731</a></td>\n' +
            '<td>  if (dev &gt;= SNDRV_CARDS)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4732>4732</a></td>\n' +
            '<td>          return -ENODEV;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4733>4733</a></td>\n' +
            '<td>  if (!enable[dev]) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4734>4734</a></td>\n' +
            '<td>          dev++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4735>4735</a></td>\n' +
            '<td>          return -ENOENT;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4736>4736</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4737>4737</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4738>4738</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4739>4739</a></td>\n' +
            '<td>where enable[dev] is the module option.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4740>4740</a></td>\n' +
            '<td>Each time the probe callback is called, check the availability of the device. If not available, simply increment the device index and returns. dev will be incremented also later (step 7).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4741>4741</a></td>\n' +
            '<td>2) Create a card instance</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4742>4742</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4743>4743</a></td>\n' +
            '<td>  struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4744>4744</a></td>\n' +
            '<td>  int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4745>4745</a></td>\n' +
            '<td>  ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4746>4746</a></td>\n' +
            '<td>  err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4747>4747</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4748>4748</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4749>4749</a></td>\n' +
            '<td>The details will be explained in the section Management of Cards and Components.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4750>4750</a></td>\n' +
            '<td>3) Create a main component</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4751>4751</a></td>\n' +
            '<td>In this part, the PCI resources are allocated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4752>4752</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4753>4753</a></td>\n' +
            '<td>  struct mychip *chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4754>4754</a></td>\n' +
            '<td>  ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4755>4755</a></td>\n' +
            '<td>  err = snd_mychip_create(card, pci, &amp;chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4756>4756</a></td>\n' +
            '<td>  if (err &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4757>4757</a></td>\n' +
            '<td>          snd_card_free(card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4758>4758</a></td>\n' +
            '<td>          return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4759>4759</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4760>4760</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4761>4761</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4762>4762</a></td>\n' +
            '<td>The details will be explained in the section PCI Resource Management.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4763>4763</a></td>\n' +
            '<td>4) Set the driver ID and name strings.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4764>4764</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4765>4765</a></td>\n' +
            '<td>  strcpy(card-&gt;driver, "My Chip");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4766>4766</a></td>\n' +
            '<td>  strcpy(card-&gt;shortname, "My Own Chip 123");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4767>4767</a></td>\n' +
            '<td>  sprintf(card-&gt;longname, "%s at 0x%lx irq %i",</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4768>4768</a></td>\n' +
            '<td>          card-&gt;shortname, chip-&gt;ioport, chip-&gt;irq);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4769>4769</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4770>4770</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4771>4771</a></td>\n' +
            '<td>The driver field holds the minimal ID string of the chip. This is used by alsa-lib' + "'" + 's configurator, so keep it simple but unique. Even the same driver can have different driver IDs to distinguish the functionality of each chip type.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4772>4772</a></td>\n' +
            '<td>The shortname field is a string shown as more verbose name. The longname field contains the information shown in /proc/asound/cards.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4773>4773</a></td>\n' +
            '<td>5) Create other components, such as mixer, MIDI, etc.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4774>4774</a></td>\n' +
            '<td>Here you define the basic components such as PCM, mixer (e.g. AC97), MIDI (e.g. MPU-401), and other interfaces. Also, if you want a proc file, define it here, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4775>4775</a></td>\n' +
            '<td>6) Register the card instance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4776>4776</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4777>4777</a></td>\n' +
            '<td>  err = snd_card_register(card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4778>4778</a></td>\n' +
            '<td>  if (err &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4779>4779</a></td>\n' +
            '<td>          snd_card_free(card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4780>4780</a></td>\n' +
            '<td>          return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4781>4781</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4782>4782</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4783>4783</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4784>4784</a></td>\n' +
            '<td>Will be explained in the section Management of Cards and Components, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4785>4785</a></td>\n' +
            '<td>7) Set the PCI driver data and return zero.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4786>4786</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4787>4787</a></td>\n' +
            '<td>        pci_set_drvdata(pci, card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4788>4788</a></td>\n' +
            '<td>        dev++;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4789>4789</a></td>\n' +
            '<td>        return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4790>4790</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4791>4791</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4792>4792</a></td>\n' +
            '<td>In the above, the card record is stored. This pointer is used in the remove callback and power-management callbacks, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4793>4793</a></td>\n' +
            '<td>Destructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4794>4794</a></td>\n' +
            '<td>The destructor, remove callback, simply releases the card instance. Then the ALSA middle layer will release all the attached components automatically.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4795>4795</a></td>\n' +
            '<td>It would be typically like the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4796>4796</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4797>4797</a></td>\n' +
            '<td>  static void snd_mychip_remove(struct pci_dev *pci)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4798>4798</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4799>4799</a></td>\n' +
            '<td>          snd_card_free(pci_get_drvdata(pci));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4800>4800</a></td>\n' +
            '<td>          pci_set_drvdata(pci, NULL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4801>4801</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4802>4802</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4803>4803</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4804>4804</a></td>\n' +
            '<td>The above code assumes that the card pointer is set to the PCI driver data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4805>4805</a></td>\n' +
            '<td>Header Files</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4806>4806</a></td>\n' +
            '<td>For the above example, at least the following include files are necessary.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4807>4807</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4808>4808</a></td>\n' +
            '<td>  #include &lt;linux/init.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4809>4809</a></td>\n' +
            '<td>  #include &lt;linux/pci.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4810>4810</a></td>\n' +
            '<td>  #include &lt;linux/slab.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4811>4811</a></td>\n' +
            '<td>  #include &lt;sound/core.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4812>4812</a></td>\n' +
            '<td>  #include &lt;sound/initval.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4813>4813</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4814>4814</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4815>4815</a></td>\n' +
            '<td>where the last one is necessary only when module options are defined in the source file. If the code is split into several files, the files without module options don' + "'" + 't need them.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4816>4816</a></td>\n' +
            '<td>In addition to these headers, you' + "'" + 'll need &lt;linux/interrupt.h&gt; for interrupt handling, and &lt;asm/io.h&gt; for I/O access. If you use the mdelay() or udelay() functions, you' + "'" + 'll need to include &lt;linux/delay.h&gt; too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4817>4817</a></td>\n' +
            '<td>The ALSA interfaces like the PCM and control APIs are defined in other &lt;sound/xxx.h&gt; header files. They have to be included after &lt;sound/core.h&gt;.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4818>4818</a></td>\n' +
            '<td>Management of Cards and Components</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4819>4819</a></td>\n' +
            '<td>Card Instance</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4820>4820</a></td>\n' +
            '<td>For each soundcard, a card record must be allocated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4821>4821</a></td>\n' +
            '<td>A card record is the headquarters of the soundcard. It manages the whole list of devices (components) on the soundcard, such as PCM, mixers, MIDI, synthesizer, and so on. Also, the card record holds the ID and the name strings of the card, manages the root of proc files, and controls the power-management states and hotplug disconnections. The component list on the card record is used to manage the correct release of resources at destruction.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4822>4822</a></td>\n' +
            '<td>As mentioned above, to create a card instance, call snd_card_create().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4823>4823</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4824>4824</a></td>\n' +
            '<td>  struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4825>4825</a></td>\n' +
            '<td>  int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4826>4826</a></td>\n' +
            '<td>  err = snd_card_create(index, id, module, extra_size, &amp;card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4827>4827</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4828>4828</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4829>4829</a></td>\n' +
            '<td>The function takes five arguments, the card-index number, the id string, the module pointer (usually THIS_MODULE), the size of extra-data space, and the pointer to return the card instance. The extra_size argument is used to allocate card-&gt;private_data for the chip-specific data. Note that these data are allocated by snd_card_create().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4830>4830</a></td>\n' +
            '<td>Components</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4831>4831</a></td>\n' +
            '<td>After the card is created, you can attach the components (devices) to the card instance. In an ALSA driver, a component is represented as a struct snd_device object. A component can be a PCM instance, a control interface, a raw MIDI interface, etc. Each such instance has one component entry.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4832>4832</a></td>\n' +
            '<td>A component can be created via snd_device_new() function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4833>4833</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4834>4834</a></td>\n' +
            '<td>  snd_device_new(card, SNDRV_DEV_XXX, chip, &amp;ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4835>4835</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4836>4836</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4837>4837</a></td>\n' +
            '<td>This takes the card pointer, the device-level (SNDRV_DEV_XXX), the data pointer, and the callback pointers (&amp;ops). The device-level defines the type of components and the order of registration and de-registration. For most components, the device-level is already defined. For a user-defined component, you can use SNDRV_DEV_LOWLEVEL.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4838>4838</a></td>\n' +
            '<td>This function itself doesn' + "'" + 't allocate the data space. The data must be allocated manually beforehand, and its pointer is passed as the argument. This pointer (chip in the above example) is used as the identifier for the instance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4839>4839</a></td>\n' +
            '<td>Each pre-defined ALSA component such as ac97 and pcm calls snd_device_new() inside its constructor. The destructor for each component is defined in the callback pointers. Hence, you don' + "'" + 't need to take care of calling a destructor for such a component.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4840>4840</a></td>\n' +
            '<td>If you wish to create your own component, you need to set the destructor function to the dev_free callback in the ops, so that it can be released automatically via snd_card_free(). The next example will show an implementation of chip-specific data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4841>4841</a></td>\n' +
            '<td>Chip-Specific Data</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4842>4842</a></td>\n' +
            '<td>Chip-specific information, e.g. the I/O port address, its resource pointer, or the irq number, is stored in the chip-specific record.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4843>4843</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4844>4844</a></td>\n' +
            '<td>  struct mychip {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4845>4845</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4846>4846</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4847>4847</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4848>4848</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4849>4849</a></td>\n' +
            '<td>In general, there are two ways of allocating the chip record.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4850>4850</a></td>\n' +
            '<td>1. Allocating via snd_card_create().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4851>4851</a></td>\n' +
            '<td>As mentioned above, you can pass the extra-data-length to the 4th argument of snd_card_create(), i.e.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4852>4852</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4853>4853</a></td>\n' +
            '<td>  err = snd_card_create(index[dev], id[dev], THIS_MODULE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4854>4854</a></td>\n' +
            '<td>                        sizeof(struct mychip), &amp;card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4855>4855</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4856>4856</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4857>4857</a></td>\n' +
            '<td>struct mychip is the type of the chip record.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4858>4858</a></td>\n' +
            '<td>In return, the allocated record can be accessed as</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4859>4859</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4860>4860</a></td>\n' +
            '<td>  struct mychip *chip = card-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4861>4861</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4862>4862</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4863>4863</a></td>\n' +
            '<td>With this method, you don' + "'" + 't have to allocate twice. The record is released together with the card instance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4864>4864</a></td>\n' +
            '<td>2. Allocating an extra device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4865>4865</a></td>\n' +
            '<td>After allocating a card instance via snd_card_create() (with 0 on the 4th arg), call kzalloc().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4866>4866</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4867>4867</a></td>\n' +
            '<td>  struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4868>4868</a></td>\n' +
            '<td>  struct mychip *chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4869>4869</a></td>\n' +
            '<td>  err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4870>4870</a></td>\n' +
            '<td>  .....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4871>4871</a></td>\n' +
            '<td>  chip = kzalloc(sizeof(*chip), GFP_KERNEL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4872>4872</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4873>4873</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4874>4874</a></td>\n' +
            '<td>The chip record should have the field to hold the card pointer at least,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4875>4875</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4876>4876</a></td>\n' +
            '<td>  struct mychip {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4877>4877</a></td>\n' +
            '<td>          struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4878>4878</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4879>4879</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4880>4880</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4881>4881</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4882>4882</a></td>\n' +
            '<td>Then, set the card pointer in the returned chip instance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4883>4883</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4884>4884</a></td>\n' +
            '<td>  chip-&gt;card = card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4885>4885</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4886>4886</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4887>4887</a></td>\n' +
            '<td>Next, initialize the fields, and register this chip record as a low-level device with a specified ops,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4888>4888</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4889>4889</a></td>\n' +
            '<td>  static struct snd_device_ops ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4890>4890</a></td>\n' +
            '<td>          .dev_free =        snd_mychip_dev_free,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4891>4891</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4892>4892</a></td>\n' +
            '<td>  ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4893>4893</a></td>\n' +
            '<td>  snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4894>4894</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4895>4895</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4896>4896</a></td>\n' +
            '<td>snd_mychip_dev_free() is the device-destructor function, which will call the real destructor.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4897>4897</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4898>4898</a></td>\n' +
            '<td>  static int snd_mychip_dev_free(struct snd_device *device)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4899>4899</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4900>4900</a></td>\n' +
            '<td>          return snd_mychip_free(device-&gt;device_data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4901>4901</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4902>4902</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4903>4903</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4904>4904</a></td>\n' +
            '<td>where snd_mychip_free() is the real destructor.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4905>4905</a></td>\n' +
            '<td>Registration and Release</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4906>4906</a></td>\n' +
            '<td>After all components are assigned, register the card instance by calling snd_card_register(). Access to the device files is enabled at this point. That is, before snd_card_register() is called, the components are safely inaccessible from external side. If this call fails, exit the probe function after releasing the card via snd_card_free().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4907>4907</a></td>\n' +
            '<td>For releasing the card instance, you can call simply snd_card_free(). As mentioned earlier, all components are released automatically by this call.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4908>4908</a></td>\n' +
            '<td>For a device which allows hotplugging, you can use snd_card_free_when_closed. This one will postpone the destruction until all devices are closed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4909>4909</a></td>\n' +
            '<td>PCI Resource Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4910>4910</a></td>\n' +
            '<td>Full Code Example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4911>4911</a></td>\n' +
            '<td>In this section, we' + "'" + 'll complete the chip-specific constructor, destructor and PCI entries. Example code is shown first, below.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4912>4912</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4913>4913</a></td>\n' +
            '<td>  struct mychip {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4914>4914</a></td>\n' +
            '<td>          struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4915>4915</a></td>\n' +
            '<td>          struct pci_dev *pci;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4916>4916</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4917>4917</a></td>\n' +
            '<td>          unsigned long port;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4918>4918</a></td>\n' +
            '<td>          int irq;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4919>4919</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4920>4920</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4921>4921</a></td>\n' +
            '<td>  static int snd_mychip_free(struct mychip *chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4922>4922</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4923>4923</a></td>\n' +
            '<td>          /* disable hardware here if any */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4924>4924</a></td>\n' +
            '<td>          .... /* (not implemented in this document) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4925>4925</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4926>4926</a></td>\n' +
            '<td>          /* release the irq */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4927>4927</a></td>\n' +
            '<td>          if (chip-&gt;irq &gt;= 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4928>4928</a></td>\n' +
            '<td>                  free_irq(chip-&gt;irq, chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4929>4929</a></td>\n' +
            '<td>          /* release the I/O ports &amp; memory */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4930>4930</a></td>\n' +
            '<td>          pci_release_regions(chip-&gt;pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4931>4931</a></td>\n' +
            '<td>          /* disable the PCI entry */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4932>4932</a></td>\n' +
            '<td>          pci_disable_device(chip-&gt;pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4933>4933</a></td>\n' +
            '<td>          /* release the data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4934>4934</a></td>\n' +
            '<td>          kfree(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4935>4935</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4936>4936</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4937>4937</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4938>4938</a></td>\n' +
            '<td>  /* chip-specific constructor */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4939>4939</a></td>\n' +
            '<td>  static int snd_mychip_create(struct snd_card *card,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4940>4940</a></td>\n' +
            '<td>                               struct pci_dev *pci,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4941>4941</a></td>\n' +
            '<td>                               struct mychip **rchip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4942>4942</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4943>4943</a></td>\n' +
            '<td>          struct mychip *chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4944>4944</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4945>4945</a></td>\n' +
            '<td>          static struct snd_device_ops ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4946>4946</a></td>\n' +
            '<td>                 .dev_free = snd_mychip_dev_free,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4947>4947</a></td>\n' +
            '<td>          };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4948>4948</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4949>4949</a></td>\n' +
            '<td>          *rchip = NULL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4950>4950</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4951>4951</a></td>\n' +
            '<td>          /* initialize the PCI entry */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4952>4952</a></td>\n' +
            '<td>          err = pci_enable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4953>4953</a></td>\n' +
            '<td>          if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4954>4954</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4955>4955</a></td>\n' +
            '<td>          /* check PCI availability (28bit DMA) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4956>4956</a></td>\n' +
            '<td>          if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0 ||</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4957>4957</a></td>\n' +
            '<td>              pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4958>4958</a></td>\n' +
            '<td>                  printk(KERN_ERR "error to set 28bit mask DMA\\n");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4959>4959</a></td>\n' +
            '<td>                  pci_disable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4960>4960</a></td>\n' +
            '<td>                  return -ENXIO;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4961>4961</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4962>4962</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4963>4963</a></td>\n' +
            '<td>          chip = kzalloc(sizeof(*chip), GFP_KERNEL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4964>4964</a></td>\n' +
            '<td>          if (chip == NULL) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4965>4965</a></td>\n' +
            '<td>                  pci_disable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4966>4966</a></td>\n' +
            '<td>                  return -ENOMEM;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4967>4967</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4968>4968</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4969>4969</a></td>\n' +
            '<td>          /* initialize the stuff */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4970>4970</a></td>\n' +
            '<td>          chip-&gt;card = card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4971>4971</a></td>\n' +
            '<td>          chip-&gt;pci = pci;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4972>4972</a></td>\n' +
            '<td>          chip-&gt;irq = -1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4973>4973</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4974>4974</a></td>\n' +
            '<td>          /* (1) PCI resource allocation */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4975>4975</a></td>\n' +
            '<td>          err = pci_request_regions(pci, "My Chip");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4976>4976</a></td>\n' +
            '<td>          if (err &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4977>4977</a></td>\n' +
            '<td>                  kfree(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4978>4978</a></td>\n' +
            '<td>                  pci_disable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4979>4979</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4980>4980</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4981>4981</a></td>\n' +
            '<td>          chip-&gt;port = pci_resource_start(pci, 0);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4982>4982</a></td>\n' +
            '<td>          if (request_irq(pci-&gt;irq, snd_mychip_interrupt,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4983>4983</a></td>\n' +
            '<td>                          IRQF_SHARED, KBUILD_MODNAME, chip)) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4984>4984</a></td>\n' +
            '<td>                  printk(KERN_ERR "cannot grab irq %d\\n", pci-&gt;irq);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4985>4985</a></td>\n' +
            '<td>                  snd_mychip_free(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4986>4986</a></td>\n' +
            '<td>                  return -EBUSY;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4987>4987</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4988>4988</a></td>\n' +
            '<td>          chip-&gt;irq = pci-&gt;irq;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4989>4989</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4990>4990</a></td>\n' +
            '<td>          /* (2) initialization of the chip hardware */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4991>4991</a></td>\n' +
            '<td>          .... /*   (not implemented in this document) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4992>4992</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4993>4993</a></td>\n' +
            '<td>          err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4994>4994</a></td>\n' +
            '<td>          if (err &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4995>4995</a></td>\n' +
            '<td>                  snd_mychip_free(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4996>4996</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4997>4997</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4998>4998</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=4999>4999</a></td>\n' +
            '<td>          snd_card_set_dev(card, &amp;pci-&gt;dev);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5000>5000</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5001>5001</a></td>\n' +
            '<td>          *rchip = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5002>5002</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5003>5003</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5004>5004</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5005>5005</a></td>\n' +
            '<td>  /* PCI IDs */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5006>5006</a></td>\n' +
            '<td>  static struct pci_device_id snd_mychip_ids[] = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5007>5007</a></td>\n' +
            '<td>          { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5008>5008</a></td>\n' +
            '<td>            PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5009>5009</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5010>5010</a></td>\n' +
            '<td>          { 0, }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5011>5011</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5012>5012</a></td>\n' +
            '<td>  MODULE_DEVICE_TABLE(pci, snd_mychip_ids);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5013>5013</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5014>5014</a></td>\n' +
            '<td>  /* pci_driver definition */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5015>5015</a></td>\n' +
            '<td>  static struct pci_driver driver = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5016>5016</a></td>\n' +
            '<td>          .name = KBUILD_MODNAME,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5017>5017</a></td>\n' +
            '<td>          .id_table = snd_mychip_ids,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5018>5018</a></td>\n' +
            '<td>          .probe = snd_mychip_probe,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5019>5019</a></td>\n' +
            '<td>          .remove = snd_mychip_remove,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5020>5020</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5021>5021</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5022>5022</a></td>\n' +
            '<td>  /* module initialization */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5023>5023</a></td>\n' +
            '<td>  static int __init alsa_card_mychip_init(void)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5024>5024</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5025>5025</a></td>\n' +
            '<td>          return pci_register_driver(&amp;driver);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5026>5026</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5027>5027</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5028>5028</a></td>\n' +
            '<td>  /* module clean up */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5029>5029</a></td>\n' +
            '<td>  static void __exit alsa_card_mychip_exit(void)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5030>5030</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5031>5031</a></td>\n' +
            '<td>          pci_unregister_driver(&amp;driver);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5032>5032</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5033>5033</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5034>5034</a></td>\n' +
            '<td>  module_init(alsa_card_mychip_init)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5035>5035</a></td>\n' +
            '<td>  module_exit(alsa_card_mychip_exit)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5036>5036</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5037>5037</a></td>\n' +
            '<td>  EXPORT_NO_SYMBOLS; /* for old kernels only */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5038>5038</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5039>5039</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5040>5040</a></td>\n' +
            '<td>Some Hafta' + "'" + 's</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5041>5041</a></td>\n' +
            '<td>The allocation of PCI resources is done in the probe() function, and usually an extra xxx_create() function is written for this purpose.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5042>5042</a></td>\n' +
            '<td>In the case of PCI devices, you first have to call the pci_enable_device() function before allocating resources. Also, you need to set the proper PCI DMA mask to limit the accessed I/O range. In some cases, you might need to call pci_set_master() function, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5043>5043</a></td>\n' +
            '<td>Suppose the 28bit mask, and the code to be added would be like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5044>5044</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5045>5045</a></td>\n' +
            '<td>  err = pci_enable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5046>5046</a></td>\n' +
            '<td>  if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5047>5047</a></td>\n' +
            '<td>          return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5048>5048</a></td>\n' +
            '<td>  if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0 ||</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5049>5049</a></td>\n' +
            '<td>      pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5050>5050</a></td>\n' +
            '<td>          printk(KERN_ERR "error to set 28bit mask DMA\\n");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5051>5051</a></td>\n' +
            '<td>          pci_disable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5052>5052</a></td>\n' +
            '<td>          return -ENXIO;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5053>5053</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5054>5054</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5055>5055</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5056>5056</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5057>5057</a></td>\n' +
            '<td>Resource Allocation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5058>5058</a></td>\n' +
            '<td>The allocation of I/O ports and irqs is done via standard kernel functions. Unlike ALSA ver.0.5.x., there are no helpers for that. And these resources must be released in the destructor function (see below). Also, on ALSA 0.9.x, you don' + "'" + 't need to allocate (pseudo-)DMA for PCI like in ALSA 0.5.x.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5059>5059</a></td>\n' +
            '<td>Now assume that the PCI device has an I/O port with 8 bytes and an interrupt. Then struct mychip will have the following fields:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5060>5060</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5061>5061</a></td>\n' +
            '<td>  struct mychip {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5062>5062</a></td>\n' +
            '<td>          struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5063>5063</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5064>5064</a></td>\n' +
            '<td>          unsigned long port;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5065>5065</a></td>\n' +
            '<td>          int irq;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5066>5066</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5067>5067</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5068>5068</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5069>5069</a></td>\n' +
            '<td>For an I/O port (and also a memory region), you need to have the resource pointer for the standard resource management. For an irq, you have to keep only the irq number (integer). But you need to initialize this number as -1 before actual allocation, since irq 0 is valid. The port address and its resource pointer can be initialized as null by kzalloc() automatically, so you don' + "'" + 't have to take care of resetting them.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5070>5070</a></td>\n' +
            '<td>The allocation of an I/O port is done like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5071>5071</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5072>5072</a></td>\n' +
            '<td>  err = pci_request_regions(pci, "My Chip");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5073>5073</a></td>\n' +
            '<td>  if (err &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5074>5074</a></td>\n' +
            '<td>          kfree(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5075>5075</a></td>\n' +
            '<td>          pci_disable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5076>5076</a></td>\n' +
            '<td>          return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5077>5077</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5078>5078</a></td>\n' +
            '<td>  chip-&gt;port = pci_resource_start(pci, 0);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5079>5079</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5080>5080</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5081>5081</a></td>\n' +
            '<td>It will reserve the I/O port region of 8 bytes of the given PCI device. The returned value, chip-&gt;res_port, is allocated via kmalloc() by request_region(). The pointer must be released via kfree(), but there is a problem with this. This issue will be explained later.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5082>5082</a></td>\n' +
            '<td>The allocation of an interrupt source is done like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5083>5083</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5084>5084</a></td>\n' +
            '<td>  if (request_irq(pci-&gt;irq, snd_mychip_interrupt,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5085>5085</a></td>\n' +
            '<td>                  IRQF_SHARED, KBUILD_MODNAME, chip)) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5086>5086</a></td>\n' +
            '<td>          printk(KERN_ERR "cannot grab irq %d\\n", pci-&gt;irq);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5087>5087</a></td>\n' +
            '<td>          snd_mychip_free(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5088>5088</a></td>\n' +
            '<td>          return -EBUSY;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5089>5089</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5090>5090</a></td>\n' +
            '<td>  chip-&gt;irq = pci-&gt;irq;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5091>5091</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5092>5092</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5093>5093</a></td>\n' +
            '<td>where snd_mychip_interrupt() is the interrupt handler defined later. Note that chip-&gt;irq should be defined only when request_irq() succeeded.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5094>5094</a></td>\n' +
            '<td>On the PCI bus, interrupts can be shared. Thus, IRQF_SHARED is used as the interrupt flag of request_irq().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5095>5095</a></td>\n' +
            '<td>The last argument of request_irq() is the data pointer passed to the interrupt handler. Usually, the chip-specific record is used for that, but you can use what you like, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5096>5096</a></td>\n' +
            '<td>I won' + "'" + 't give details about the interrupt handler at this point, but at least its appearance can be explained now. The interrupt handler looks usually like the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5097>5097</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5098>5098</a></td>\n' +
            '<td>  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5099>5099</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5100>5100</a></td>\n' +
            '<td>          struct mychip *chip = dev_id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5101>5101</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5102>5102</a></td>\n' +
            '<td>          return IRQ_HANDLED;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5103>5103</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5104>5104</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5105>5105</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5106>5106</a></td>\n' +
            '<td>Now let' + "'" + 's write the corresponding destructor for the resources above. The role of destructor is simple: disable the hardware (if already activated) and release the resources. So far, we have no hardware part, so the disabling code is not written here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5107>5107</a></td>\n' +
            '<td>To release the resources, the check-and-release method is a safer way. For the interrupt, do like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5108>5108</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5109>5109</a></td>\n' +
            '<td>  if (chip-&gt;irq &gt;= 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5110>5110</a></td>\n' +
            '<td>          free_irq(chip-&gt;irq, chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5111>5111</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5112>5112</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5113>5113</a></td>\n' +
            '<td>Since the irq number can start from 0, you should initialize chip-&gt;irq with a negative value (e.g. -1), so that you can check the validity of the irq number as above.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5114>5114</a></td>\n' +
            '<td>When you requested I/O ports or memory regions via pci_request_region() or pci_request_regions() like in this example, release the resource(s) using the corresponding function, pci_release_region() or pci_release_regions().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5115>5115</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5116>5116</a></td>\n' +
            '<td>  pci_release_regions(chip-&gt;pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5117>5117</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5118>5118</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5119>5119</a></td>\n' +
            '<td>When you requested manually via request_region() or request_mem_region, you can release it via release_resource(). Suppose that you keep the resource pointer returned from request_region() in chip-&gt;res_port, the release procedure looks like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5120>5120</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5121>5121</a></td>\n' +
            '<td>  release_and_free_resource(chip-&gt;res_port);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5122>5122</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5123>5123</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5124>5124</a></td>\n' +
            '<td>Don' + "'" + 't forget to call pci_disable_device() before the end.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5125>5125</a></td>\n' +
            '<td>And finally, release the chip-specific record.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5126>5126</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5127>5127</a></td>\n' +
            '<td>  kfree(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5128>5128</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5129>5129</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5130>5130</a></td>\n' +
            '<td>We didn' + "'" + 't implement the hardware disabling part in the above. If you need to do this, please note that the destructor may be called even before the initialization of the chip is completed. It would be better to have a flag to skip hardware disabling if the hardware was not initialized yet.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5131>5131</a></td>\n' +
            '<td>When the chip-data is assigned to the card using snd_device_new() with SNDRV_DEV_LOWLELVEL , its destructor is called at the last. That is, it is assured that all other components like PCMs and controls have already been released. You don' + "'" + 't have to stop PCMs, etc. explicitly, but just call low-level hardware stopping.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5132>5132</a></td>\n' +
            '<td>The management of a memory-mapped region is almost as same as the management of an I/O port. You' + "'" + 'll need three fields like the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5133>5133</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5134>5134</a></td>\n' +
            '<td>  struct mychip {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5135>5135</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5136>5136</a></td>\n' +
            '<td>          unsigned long iobase_phys;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5137>5137</a></td>\n' +
            '<td>          void __iomem *iobase_virt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5138>5138</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5139>5139</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5140>5140</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5141>5141</a></td>\n' +
            '<td>and the allocation would be like below:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5142>5142</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5143>5143</a></td>\n' +
            '<td>  if ((err = pci_request_regions(pci, "My Chip")) &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5144>5144</a></td>\n' +
            '<td>          kfree(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5145>5145</a></td>\n' +
            '<td>          return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5146>5146</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5147>5147</a></td>\n' +
            '<td>  chip-&gt;iobase_phys = pci_resource_start(pci, 0);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5148>5148</a></td>\n' +
            '<td>  chip-&gt;iobase_virt = ioremap_nocache(chip-&gt;iobase_phys,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5149>5149</a></td>\n' +
            '<td>                                      pci_resource_len(pci, 0));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5150>5150</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5151>5151</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5152>5152</a></td>\n' +
            '<td>and the corresponding destructor would be:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5153>5153</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5154>5154</a></td>\n' +
            '<td>  static int snd_mychip_free(struct mychip *chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5155>5155</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5156>5156</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5157>5157</a></td>\n' +
            '<td>          if (chip-&gt;iobase_virt)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5158>5158</a></td>\n' +
            '<td>                  iounmap(chip-&gt;iobase_virt);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5159>5159</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5160>5160</a></td>\n' +
            '<td>          pci_release_regions(chip-&gt;pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5161>5161</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5162>5162</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5163>5163</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5164>5164</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5165>5165</a></td>\n' +
            '<td>Registration of Device Struct</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5166>5166</a></td>\n' +
            '<td>At some point, typically after calling snd_device_new(), you need to register the struct device of the chip you' + "'" + 're handling for udev and co. ALSA provides a macro for compatibility with older kernels. Simply call like the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5167>5167</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5168>5168</a></td>\n' +
            '<td>  snd_card_set_dev(card, &amp;pci-&gt;dev);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5169>5169</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5170>5170</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5171>5171</a></td>\n' +
            '<td>so that it stores the PCI' + "'" + 's device pointer to the card. This will be referred by ALSA core functions later when the devices are registered.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5172>5172</a></td>\n' +
            '<td>In the case of non-PCI, pass the proper device struct pointer of the BUS instead. (In the case of legacy ISA without PnP, you don' + "'" + 't have to do anything.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5173>5173</a></td>\n' +
            '<td>PCI Entries</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5174>5174</a></td>\n' +
            '<td>So far, so good. Let' + "'" + 's finish the missing PCI stuff. At first, we need a pci_device_id table for this chipset. It' + "'" + 's a table of PCI vendor/device ID number, and some masks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5175>5175</a></td>\n' +
            '<td>For example,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5176>5176</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5177>5177</a></td>\n' +
            '<td>  static struct pci_device_id snd_mychip_ids[] = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5178>5178</a></td>\n' +
            '<td>          { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5179>5179</a></td>\n' +
            '<td>            PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5180>5180</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5181>5181</a></td>\n' +
            '<td>          { 0, }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5182>5182</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5183>5183</a></td>\n' +
            '<td>  MODULE_DEVICE_TABLE(pci, snd_mychip_ids);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5184>5184</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5185>5185</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5186>5186</a></td>\n' +
            '<td>The first and second fields of the pci_device_id structure are the vendor and device IDs. If you have no reason to filter the matching devices, you can leave the remaining fields as above. The last field of the pci_device_id struct contains private data for this entry. You can specify any value here, for example, to define specific operations for supported device IDs. Such an example is found in the intel8x0 driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5187>5187</a></td>\n' +
            '<td>The last entry of this list is the terminator. You must specify this all-zero entry.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5188>5188</a></td>\n' +
            '<td>Then, prepare the pci_driver record:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5189>5189</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5190>5190</a></td>\n' +
            '<td>  static struct pci_driver driver = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5191>5191</a></td>\n' +
            '<td>          .name = KBUILD_MODNAME,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5192>5192</a></td>\n' +
            '<td>          .id_table = snd_mychip_ids,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5193>5193</a></td>\n' +
            '<td>          .probe = snd_mychip_probe,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5194>5194</a></td>\n' +
            '<td>          .remove = snd_mychip_remove,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5195>5195</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5196>5196</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5197>5197</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5198>5198</a></td>\n' +
            '<td>The probe and remove functions have already been defined in the previous sections. The name field is the name string of this device. Note that you must not use a slash / in this string.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5199>5199</a></td>\n' +
            '<td>And at last, the module entries:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5200>5200</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5201>5201</a></td>\n' +
            '<td>  static int __init alsa_card_mychip_init(void)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5202>5202</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5203>5203</a></td>\n' +
            '<td>          return pci_register_driver(&amp;driver);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5204>5204</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5205>5205</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5206>5206</a></td>\n' +
            '<td>  static void __exit alsa_card_mychip_exit(void)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5207>5207</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5208>5208</a></td>\n' +
            '<td>          pci_unregister_driver(&amp;driver);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5209>5209</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5210>5210</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5211>5211</a></td>\n' +
            '<td>  module_init(alsa_card_mychip_init)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5212>5212</a></td>\n' +
            '<td>  module_exit(alsa_card_mychip_exit)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5213>5213</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5214>5214</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5215>5215</a></td>\n' +
            '<td>Note that these module entries are tagged with __init and __exit prefixes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5216>5216</a></td>\n' +
            '<td>Oh, one thing was forgotten. If you have no exported symbols, you need to declare it in 2.2 or 2.4 kernels (it' + "'" + 's not necessary in 2.6 kernels).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5217>5217</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5218>5218</a></td>\n' +
            '<td>  EXPORT_NO_SYMBOLS;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5219>5219</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5220>5220</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5221>5221</a></td>\n' +
            '<td>That' + "'" + 's all!</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5222>5222</a></td>\n' +
            '<td>PCM Interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5223>5223</a></td>\n' +
            '<td>General</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5224>5224</a></td>\n' +
            '<td>The PCM middle layer of ALSA is quite powerful and it is only necessary for each driver to implement the low-level functions to access its hardware.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5225>5225</a></td>\n' +
            '<td>For accessing to the PCM layer, you need to include &lt;sound/pcm.h&gt; first. In addition, &lt;sound/pcm_params.h&gt; might be needed if you access to some functions related with hw_param.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5226>5226</a></td>\n' +
            '<td>Each card device can have up to four pcm instances. A pcm instance corresponds to a pcm device file. The limitation of number of instances comes only from the available bit size of the Linux' + "'" + 's device numbers. Once when 64bit device number is used, we' + "'" + 'll have more pcm instances available.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5227>5227</a></td>\n' +
            '<td>A pcm instance consists of pcm playback and capture streams, and each pcm stream consists of one or more pcm substreams. Some soundcards support multiple playback functions. For example, emu10k1 has a PCM playback of 32 stereo substreams. In this case, at each open, a free substream is (usually) automatically chosen and opened. Meanwhile, when only one substream exists and it was already opened, the successful open will either block or error with EAGAIN according to the file open mode. But you don' + "'" + 't have to care about such details in your driver. The PCM middle layer will take care of such work.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5228>5228</a></td>\n' +
            '<td>Full Code Example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5229>5229</a></td>\n' +
            '<td>The example code below does not include any hardware access routines but shows only the skeleton, how to build up the PCM interfaces.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5230>5230</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5231>5231</a></td>\n' +
            '<td>  #include &lt;sound/pcm.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5232>5232</a></td>\n' +
            '<td>  ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5233>5233</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5234>5234</a></td>\n' +
            '<td>  /* hardware definition */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5235>5235</a></td>\n' +
            '<td>  static struct snd_pcm_hardware snd_mychip_playback_hw = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5236>5236</a></td>\n' +
            '<td>          .info = (SNDRV_PCM_INFO_MMAP |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5237>5237</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_INTERLEAVED |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5238>5238</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_BLOCK_TRANSFER |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5239>5239</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_MMAP_VALID),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5240>5240</a></td>\n' +
            '<td>          .formats =          SNDRV_PCM_FMTBIT_S16_LE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5241>5241</a></td>\n' +
            '<td>          .rates =            SNDRV_PCM_RATE_8000_48000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5242>5242</a></td>\n' +
            '<td>          .rate_min =         8000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5243>5243</a></td>\n' +
            '<td>          .rate_max =         48000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5244>5244</a></td>\n' +
            '<td>          .channels_min =     2,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5245>5245</a></td>\n' +
            '<td>          .channels_max =     2,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5246>5246</a></td>\n' +
            '<td>          .buffer_bytes_max = 32768,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5247>5247</a></td>\n' +
            '<td>          .period_bytes_min = 4096,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5248>5248</a></td>\n' +
            '<td>          .period_bytes_max = 32768,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5249>5249</a></td>\n' +
            '<td>          .periods_min =      1,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5250>5250</a></td>\n' +
            '<td>          .periods_max =      1024,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5251>5251</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5252>5252</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5253>5253</a></td>\n' +
            '<td>  /* hardware definition */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5254>5254</a></td>\n' +
            '<td>  static struct snd_pcm_hardware snd_mychip_capture_hw = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5255>5255</a></td>\n' +
            '<td>          .info = (SNDRV_PCM_INFO_MMAP |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5256>5256</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_INTERLEAVED |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5257>5257</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_BLOCK_TRANSFER |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5258>5258</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_MMAP_VALID),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5259>5259</a></td>\n' +
            '<td>          .formats =          SNDRV_PCM_FMTBIT_S16_LE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5260>5260</a></td>\n' +
            '<td>          .rates =            SNDRV_PCM_RATE_8000_48000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5261>5261</a></td>\n' +
            '<td>          .rate_min =         8000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5262>5262</a></td>\n' +
            '<td>          .rate_max =         48000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5263>5263</a></td>\n' +
            '<td>          .channels_min =     2,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5264>5264</a></td>\n' +
            '<td>          .channels_max =     2,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5265>5265</a></td>\n' +
            '<td>          .buffer_bytes_max = 32768,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5266>5266</a></td>\n' +
            '<td>          .period_bytes_min = 4096,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5267>5267</a></td>\n' +
            '<td>          .period_bytes_max = 32768,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5268>5268</a></td>\n' +
            '<td>          .periods_min =      1,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5269>5269</a></td>\n' +
            '<td>          .periods_max =      1024,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5270>5270</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5271>5271</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5272>5272</a></td>\n' +
            '<td>  /* open callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5273>5273</a></td>\n' +
            '<td>  static int snd_mychip_playback_open(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5274>5274</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5275>5275</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_substream_chip(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5276>5276</a></td>\n' +
            '<td>          struct snd_pcm_runtime *runtime = substream-&gt;runtime;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5277>5277</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5278>5278</a></td>\n' +
            '<td>          runtime-&gt;hw = snd_mychip_playback_hw;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5279>5279</a></td>\n' +
            '<td>          /* more hardware-initialization will be done here */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5280>5280</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5281>5281</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5282>5282</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5283>5283</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5284>5284</a></td>\n' +
            '<td>  /* close callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5285>5285</a></td>\n' +
            '<td>  static int snd_mychip_playback_close(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5286>5286</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5287>5287</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_substream_chip(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5288>5288</a></td>\n' +
            '<td>          /* the hardware-specific codes will be here */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5289>5289</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5290>5290</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5291>5291</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5292>5292</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5293>5293</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5294>5294</a></td>\n' +
            '<td>  /* open callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5295>5295</a></td>\n' +
            '<td>  static int snd_mychip_capture_open(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5296>5296</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5297>5297</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_substream_chip(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5298>5298</a></td>\n' +
            '<td>          struct snd_pcm_runtime *runtime = substream-&gt;runtime;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5299>5299</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5300>5300</a></td>\n' +
            '<td>          runtime-&gt;hw = snd_mychip_capture_hw;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5301>5301</a></td>\n' +
            '<td>          /* more hardware-initialization will be done here */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5302>5302</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5303>5303</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5304>5304</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5305>5305</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5306>5306</a></td>\n' +
            '<td>  /* close callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5307>5307</a></td>\n' +
            '<td>  static int snd_mychip_capture_close(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5308>5308</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5309>5309</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_substream_chip(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5310>5310</a></td>\n' +
            '<td>          /* the hardware-specific codes will be here */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5311>5311</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5312>5312</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5313>5313</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5314>5314</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5315>5315</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5316>5316</a></td>\n' +
            '<td>  /* hw_params callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5317>5317</a></td>\n' +
            '<td>  static int snd_mychip_pcm_hw_params(struct snd_pcm_substream *substream,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5318>5318</a></td>\n' +
            '<td>                               struct snd_pcm_hw_params *hw_params)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5319>5319</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5320>5320</a></td>\n' +
            '<td>          return snd_pcm_lib_malloc_pages(substream,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5321>5321</a></td>\n' +
            '<td>                                     params_buffer_bytes(hw_params));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5322>5322</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5323>5323</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5324>5324</a></td>\n' +
            '<td>  /* hw_free callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5325>5325</a></td>\n' +
            '<td>  static int snd_mychip_pcm_hw_free(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5326>5326</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5327>5327</a></td>\n' +
            '<td>          return snd_pcm_lib_free_pages(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5328>5328</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5329>5329</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5330>5330</a></td>\n' +
            '<td>  /* prepare callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5331>5331</a></td>\n' +
            '<td>  static int snd_mychip_pcm_prepare(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5332>5332</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5333>5333</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_substream_chip(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5334>5334</a></td>\n' +
            '<td>          struct snd_pcm_runtime *runtime = substream-&gt;runtime;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5335>5335</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5336>5336</a></td>\n' +
            '<td>          /* set up the hardware with the current configuration</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5337>5337</a></td>\n' +
            '<td>           * for example...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5338>5338</a></td>\n' +
            '<td>           */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5339>5339</a></td>\n' +
            '<td>          mychip_set_sample_format(chip, runtime-&gt;format);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5340>5340</a></td>\n' +
            '<td>          mychip_set_sample_rate(chip, runtime-&gt;rate);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5341>5341</a></td>\n' +
            '<td>          mychip_set_channels(chip, runtime-&gt;channels);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5342>5342</a></td>\n' +
            '<td>          mychip_set_dma_setup(chip, runtime-&gt;dma_addr,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5343>5343</a></td>\n' +
            '<td>                               chip-&gt;buffer_size,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5344>5344</a></td>\n' +
            '<td>                               chip-&gt;period_size);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5345>5345</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5346>5346</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5347>5347</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5348>5348</a></td>\n' +
            '<td>  /* trigger callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5349>5349</a></td>\n' +
            '<td>  static int snd_mychip_pcm_trigger(struct snd_pcm_substream *substream,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5350>5350</a></td>\n' +
            '<td>                                    int cmd)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5351>5351</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5352>5352</a></td>\n' +
            '<td>          switch (cmd) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5353>5353</a></td>\n' +
            '<td>          case SNDRV_PCM_TRIGGER_START:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5354>5354</a></td>\n' +
            '<td>                  /* do something to start the PCM engine */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5355>5355</a></td>\n' +
            '<td>                  ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5356>5356</a></td>\n' +
            '<td>                  break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5357>5357</a></td>\n' +
            '<td>          case SNDRV_PCM_TRIGGER_STOP:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5358>5358</a></td>\n' +
            '<td>                  /* do something to stop the PCM engine */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5359>5359</a></td>\n' +
            '<td>                  ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5360>5360</a></td>\n' +
            '<td>                  break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5361>5361</a></td>\n' +
            '<td>          default:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5362>5362</a></td>\n' +
            '<td>                  return -EINVAL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5363>5363</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5364>5364</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5365>5365</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5366>5366</a></td>\n' +
            '<td>  /* pointer callback */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5367>5367</a></td>\n' +
            '<td>  static snd_pcm_uframes_t</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5368>5368</a></td>\n' +
            '<td>  snd_mychip_pcm_pointer(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5369>5369</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5370>5370</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_substream_chip(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5371>5371</a></td>\n' +
            '<td>          unsigned int current_ptr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5372>5372</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5373>5373</a></td>\n' +
            '<td>          /* get the current hardware pointer */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5374>5374</a></td>\n' +
            '<td>          current_ptr = mychip_get_hw_pointer(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5375>5375</a></td>\n' +
            '<td>          return current_ptr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5376>5376</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5377>5377</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5378>5378</a></td>\n' +
            '<td>  /* operators */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5379>5379</a></td>\n' +
            '<td>  static struct snd_pcm_ops snd_mychip_playback_ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5380>5380</a></td>\n' +
            '<td>          .open =        snd_mychip_playback_open,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5381>5381</a></td>\n' +
            '<td>          .close =       snd_mychip_playback_close,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5382>5382</a></td>\n' +
            '<td>          .ioctl =       snd_pcm_lib_ioctl,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5383>5383</a></td>\n' +
            '<td>          .hw_params =   snd_mychip_pcm_hw_params,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5384>5384</a></td>\n' +
            '<td>          .hw_free =     snd_mychip_pcm_hw_free,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5385>5385</a></td>\n' +
            '<td>          .prepare =     snd_mychip_pcm_prepare,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5386>5386</a></td>\n' +
            '<td>          .trigger =     snd_mychip_pcm_trigger,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5387>5387</a></td>\n' +
            '<td>          .pointer =     snd_mychip_pcm_pointer,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5388>5388</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5389>5389</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5390>5390</a></td>\n' +
            '<td>  /* operators */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5391>5391</a></td>\n' +
            '<td>  static struct snd_pcm_ops snd_mychip_capture_ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5392>5392</a></td>\n' +
            '<td>          .open =        snd_mychip_capture_open,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5393>5393</a></td>\n' +
            '<td>          .close =       snd_mychip_capture_close,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5394>5394</a></td>\n' +
            '<td>          .ioctl =       snd_pcm_lib_ioctl,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5395>5395</a></td>\n' +
            '<td>          .hw_params =   snd_mychip_pcm_hw_params,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5396>5396</a></td>\n' +
            '<td>          .hw_free =     snd_mychip_pcm_hw_free,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5397>5397</a></td>\n' +
            '<td>          .prepare =     snd_mychip_pcm_prepare,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5398>5398</a></td>\n' +
            '<td>          .trigger =     snd_mychip_pcm_trigger,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5399>5399</a></td>\n' +
            '<td>          .pointer =     snd_mychip_pcm_pointer,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5400>5400</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5401>5401</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5402>5402</a></td>\n' +
            '<td>  /*</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5403>5403</a></td>\n' +
            '<td>   *  definitions of capture are omitted here...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5404>5404</a></td>\n' +
            '<td>   */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5405>5405</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5406>5406</a></td>\n' +
            '<td>  /* create a pcm device */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5407>5407</a></td>\n' +
            '<td>  static int snd_mychip_new_pcm(struct mychip *chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5408>5408</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5409>5409</a></td>\n' +
            '<td>          struct snd_pcm *pcm;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5410>5410</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5411>5411</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5412>5412</a></td>\n' +
            '<td>          err = snd_pcm_new(chip-&gt;card, "My Chip", 0, 1, 1, &amp;pcm);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5413>5413</a></td>\n' +
            '<td>          if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5414>5414</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5415>5415</a></td>\n' +
            '<td>          pcm-&gt;private_data = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5416>5416</a></td>\n' +
            '<td>          strcpy(pcm-&gt;name, "My Chip");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5417>5417</a></td>\n' +
            '<td>          chip-&gt;pcm = pcm;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5418>5418</a></td>\n' +
            '<td>          /* set operators */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5419>5419</a></td>\n' +
            '<td>          snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5420>5420</a></td>\n' +
            '<td>                          &amp;snd_mychip_playback_ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5421>5421</a></td>\n' +
            '<td>          snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5422>5422</a></td>\n' +
            '<td>                          &amp;snd_mychip_capture_ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5423>5423</a></td>\n' +
            '<td>          /* pre-allocation of buffers */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5424>5424</a></td>\n' +
            '<td>          /* NOTE: this may fail */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5425>5425</a></td>\n' +
            '<td>          snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5426>5426</a></td>\n' +
            '<td>                                                snd_dma_pci_data(chip-&gt;pci),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5427>5427</a></td>\n' +
            '<td>                                                64*1024, 64*1024);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5428>5428</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5429>5429</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5430>5430</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5431>5431</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5432>5432</a></td>\n' +
            '<td>Constructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5433>5433</a></td>\n' +
            '<td>A pcm instance is allocated by the snd_pcm_new() function. It would be better to create a constructor for pcm, namely,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5434>5434</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5435>5435</a></td>\n' +
            '<td>  static int snd_mychip_new_pcm(struct mychip *chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5436>5436</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5437>5437</a></td>\n' +
            '<td>          struct snd_pcm *pcm;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5438>5438</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5439>5439</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5440>5440</a></td>\n' +
            '<td>          err = snd_pcm_new(chip-&gt;card, "My Chip", 0, 1, 1, &amp;pcm);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5441>5441</a></td>\n' +
            '<td>          if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5442>5442</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5443>5443</a></td>\n' +
            '<td>          pcm-&gt;private_data = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5444>5444</a></td>\n' +
            '<td>          strcpy(pcm-&gt;name, "My Chip");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5445>5445</a></td>\n' +
            '<td>          chip-&gt;pcm = pcm;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5446>5446</a></td>\n' +
            '<td>      ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5447>5447</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5448>5448</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5449>5449</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5450>5450</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5451>5451</a></td>\n' +
            '<td>The snd_pcm_new() function takes four arguments. The first argument is the card pointer to which this pcm is assigned, and the second is the ID string.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5452>5452</a></td>\n' +
            '<td>The third argument (index, 0 in the above) is the index of this new pcm. It begins from zero. If you create more than one pcm instances, specify the different numbers in this argument. For example, index = 1 for the second PCM device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5453>5453</a></td>\n' +
            '<td>The fourth and fifth arguments are the number of substreams for playback and capture, respectively. Here 1 is used for both arguments. When no playback or capture substreams are available, pass 0 to the corresponding argument.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5454>5454</a></td>\n' +
            '<td>If a chip supports multiple playbacks or captures, you can specify more numbers, but they must be handled properly in open/close, etc. callbacks. When you need to know which substream you are referring to, then it can be obtained from struct snd_pcm_substream data passed to each callback as follows:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5455>5455</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5456>5456</a></td>\n' +
            '<td>  struct snd_pcm_substream *substream;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5457>5457</a></td>\n' +
            '<td>  int index = substream-&gt;number;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5458>5458</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5459>5459</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5460>5460</a></td>\n' +
            '<td>After the pcm is created, you need to set operators for each pcm stream.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5461>5461</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5462>5462</a></td>\n' +
            '<td>  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5463>5463</a></td>\n' +
            '<td>                  &amp;snd_mychip_playback_ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5464>5464</a></td>\n' +
            '<td>  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5465>5465</a></td>\n' +
            '<td>                  &amp;snd_mychip_capture_ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5466>5466</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5467>5467</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5468>5468</a></td>\n' +
            '<td>The operators are defined typically like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5469>5469</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5470>5470</a></td>\n' +
            '<td>  static struct snd_pcm_ops snd_mychip_playback_ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5471>5471</a></td>\n' +
            '<td>          .open =        snd_mychip_pcm_open,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5472>5472</a></td>\n' +
            '<td>          .close =       snd_mychip_pcm_close,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5473>5473</a></td>\n' +
            '<td>          .ioctl =       snd_pcm_lib_ioctl,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5474>5474</a></td>\n' +
            '<td>          .hw_params =   snd_mychip_pcm_hw_params,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5475>5475</a></td>\n' +
            '<td>          .hw_free =     snd_mychip_pcm_hw_free,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5476>5476</a></td>\n' +
            '<td>          .prepare =     snd_mychip_pcm_prepare,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5477>5477</a></td>\n' +
            '<td>          .trigger =     snd_mychip_pcm_trigger,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5478>5478</a></td>\n' +
            '<td>          .pointer =     snd_mychip_pcm_pointer,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5479>5479</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5480>5480</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5481>5481</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5482>5482</a></td>\n' +
            '<td>All the callbacks are described in the Operators subsection.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5483>5483</a></td>\n' +
            '<td>After setting the operators, you probably will want to pre-allocate the buffer. For the pre-allocation, simply call the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5484>5484</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5485>5485</a></td>\n' +
            '<td>  snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5486>5486</a></td>\n' +
            '<td>                                        snd_dma_pci_data(chip-&gt;pci),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5487>5487</a></td>\n' +
            '<td>                                        64*1024, 64*1024);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5488>5488</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5489>5489</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5490>5490</a></td>\n' +
            '<td>It will allocate a buffer up to 64kB as default. Buffer management details will be described in the later section Buffer and Memory Management.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5491>5491</a></td>\n' +
            '<td>Additionally, you can set some extra information for this pcm in pcm-&gt;info_flags. The available values are defined as SNDRV_PCM_INFO_XXX in &lt;sound/asound.h&gt;, which is used for the hardware definition (described later). When your soundchip supports only half-duplex, specify like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5492>5492</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5493>5493</a></td>\n' +
            '<td>  pcm-&gt;info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5494>5494</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5495>5495</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5496>5496</a></td>\n' +
            '<td>... And the Destructor?</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5497>5497</a></td>\n' +
            '<td>The destructor for a pcm instance is not always necessary. Since the pcm device will be released by the middle layer code automatically, you don' + "'" + 't have to call the destructor explicitly.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5498>5498</a></td>\n' +
            '<td>The destructor would be necessary if you created special records internally and needed to release them. In such a case, set the destructor function to pcm-&gt;private_free:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5499>5499</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5500>5500</a></td>\n' +
            '<td>  static void mychip_pcm_free(struct snd_pcm *pcm)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5501>5501</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5502>5502</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_chip(pcm);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5503>5503</a></td>\n' +
            '<td>          /* free your own data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5504>5504</a></td>\n' +
            '<td>          kfree(chip-&gt;my_private_pcm_data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5505>5505</a></td>\n' +
            '<td>          /* do what you like else */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5506>5506</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5507>5507</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5508>5508</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5509>5509</a></td>\n' +
            '<td>  static int snd_mychip_new_pcm(struct mychip *chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5510>5510</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5511>5511</a></td>\n' +
            '<td>          struct snd_pcm *pcm;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5512>5512</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5513>5513</a></td>\n' +
            '<td>          /* allocate your own data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5514>5514</a></td>\n' +
            '<td>          chip-&gt;my_private_pcm_data = kmalloc(...);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5515>5515</a></td>\n' +
            '<td>          /* set the destructor */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5516>5516</a></td>\n' +
            '<td>          pcm-&gt;private_data = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5517>5517</a></td>\n' +
            '<td>          pcm-&gt;private_free = mychip_pcm_free;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5518>5518</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5519>5519</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5520>5520</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5521>5521</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5522>5522</a></td>\n' +
            '<td>Runtime Pointer - The Chest of PCM Information</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5523>5523</a></td>\n' +
            '<td>When the PCM substream is opened, a PCM runtime instance is allocated and assigned to the substream. This pointer is accessible via substream-&gt;runtime. This runtime pointer holds most information you need to control the PCM: the copy of hw_params and sw_params configurations, the buffer pointers, mmap records, spinlocks, etc.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5524>5524</a></td>\n' +
            '<td>The definition of runtime instance is found in &lt;sound/pcm.h&gt;. Here are the contents of this file:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5525>5525</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5526>5526</a></td>\n' +
            '<td>struct _snd_pcm_runtime {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5527>5527</a></td>\n' +
            '<td>    /* -- Status -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5528>5528</a></td>\n' +
            '<td>    struct snd_pcm_substream *trigger_master;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5529>5529</a></td>\n' +
            '<td>    snd_timestamp_t trigger_tstamp; /* trigger timestamp */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5530>5530</a></td>\n' +
            '<td>    int overrange;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5531>5531</a></td>\n' +
            '<td>    snd_pcm_uframes_t avail_max;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5532>5532</a></td>\n' +
            '<td>    snd_pcm_uframes_t hw_ptr_base;  /* Position at buffer restart */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5533>5533</a></td>\n' +
            '<td>    snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5534>5534</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5535>5535</a></td>\n' +
            '<td>    /* -- HW params -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5536>5536</a></td>\n' +
            '<td>    snd_pcm_access_t access;    /* access mode */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5537>5537</a></td>\n' +
            '<td>    snd_pcm_format_t format;    /* SNDRV_PCM_FORMAT_* */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5538>5538</a></td>\n' +
            '<td>    snd_pcm_subformat_t subformat;  /* subformat */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5539>5539</a></td>\n' +
            '<td>    unsigned int rate;      /* rate in Hz */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5540>5540</a></td>\n' +
            '<td>    unsigned int channels;      /* channels */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5541>5541</a></td>\n' +
            '<td>    snd_pcm_uframes_t period_size;  /* period size */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5542>5542</a></td>\n' +
            '<td>    unsigned int periods;       /* periods */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5543>5543</a></td>\n' +
            '<td>    snd_pcm_uframes_t buffer_size;  /* buffer size */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5544>5544</a></td>\n' +
            '<td>    unsigned int tick_time;     /* tick time */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5545>5545</a></td>\n' +
            '<td>    snd_pcm_uframes_t min_align;    /* Min alignment for the format */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5546>5546</a></td>\n' +
            '<td>    size_t byte_align;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5547>5547</a></td>\n' +
            '<td>    unsigned int frame_bits;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5548>5548</a></td>\n' +
            '<td>    unsigned int sample_bits;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5549>5549</a></td>\n' +
            '<td>    unsigned int info;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5550>5550</a></td>\n' +
            '<td>    unsigned int rate_num;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5551>5551</a></td>\n' +
            '<td>    unsigned int rate_den;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5552>5552</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5553>5553</a></td>\n' +
            '<td>    /* -- SW params -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5554>5554</a></td>\n' +
            '<td>    struct timespec tstamp_mode;    /* mmap timestamp is updated */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5555>5555</a></td>\n' +
            '<td>    unsigned int period_step;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5556>5556</a></td>\n' +
            '<td>    unsigned int sleep_min;     /* min ticks to sleep */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5557>5557</a></td>\n' +
            '<td>    snd_pcm_uframes_t start_threshold;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5558>5558</a></td>\n' +
            '<td>    snd_pcm_uframes_t stop_threshold;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5559>5559</a></td>\n' +
            '<td>    snd_pcm_uframes_t silence_threshold; /* Silence filling happens when</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5560>5560</a></td>\n' +
            '<td>                        noise is nearest than this */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5561>5561</a></td>\n' +
            '<td>    snd_pcm_uframes_t silence_size; /* Silence filling size */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5562>5562</a></td>\n' +
            '<td>    snd_pcm_uframes_t boundary; /* pointers wrap point */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5563>5563</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5564>5564</a></td>\n' +
            '<td>    snd_pcm_uframes_t silenced_start;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5565>5565</a></td>\n' +
            '<td>    snd_pcm_uframes_t silenced_size;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5566>5566</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5567>5567</a></td>\n' +
            '<td>    snd_pcm_sync_id_t sync;     /* hardware synchronization ID */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5568>5568</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5569>5569</a></td>\n' +
            '<td>    /* -- mmap -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5570>5570</a></td>\n' +
            '<td>    volatile struct snd_pcm_mmap_status *status;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5571>5571</a></td>\n' +
            '<td>    volatile struct snd_pcm_mmap_control *control;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5572>5572</a></td>\n' +
            '<td>    atomic_t mmap_count;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5573>5573</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5574>5574</a></td>\n' +
            '<td>    /* -- locking / scheduling -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5575>5575</a></td>\n' +
            '<td>    spinlock_t lock;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5576>5576</a></td>\n' +
            '<td>    wait_queue_head_t sleep;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5577>5577</a></td>\n' +
            '<td>    struct timer_list tick_timer;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5578>5578</a></td>\n' +
            '<td>    struct fasync_struct *fasync;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5579>5579</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5580>5580</a></td>\n' +
            '<td>    /* -- private section -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5581>5581</a></td>\n' +
            '<td>    void *private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5582>5582</a></td>\n' +
            '<td>    void (*private_free)(struct snd_pcm_runtime *runtime);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5583>5583</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5584>5584</a></td>\n' +
            '<td>    /* -- hardware description -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5585>5585</a></td>\n' +
            '<td>    struct snd_pcm_hardware hw;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5586>5586</a></td>\n' +
            '<td>    struct snd_pcm_hw_constraints hw_constraints;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5587>5587</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5588>5588</a></td>\n' +
            '<td>    /* -- interrupt callbacks -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5589>5589</a></td>\n' +
            '<td>    void (*transfer_ack_begin)(struct snd_pcm_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5590>5590</a></td>\n' +
            '<td>    void (*transfer_ack_end)(struct snd_pcm_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5591>5591</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5592>5592</a></td>\n' +
            '<td>    /* -- timer -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5593>5593</a></td>\n' +
            '<td>    unsigned int timer_resolution;  /* timer resolution */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5594>5594</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5595>5595</a></td>\n' +
            '<td>    /* -- DMA -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5596>5596</a></td>\n' +
            '<td>    unsigned char *dma_area;    /* DMA area */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5597>5597</a></td>\n' +
            '<td>    dma_addr_t dma_addr;        /* physical bus address (not accessible from main CPU) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5598>5598</a></td>\n' +
            '<td>    size_t dma_bytes;       /* size of DMA area */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5599>5599</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5600>5600</a></td>\n' +
            '<td>    struct snd_dma_buffer *dma_buffer_p;    /* allocated buffer */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5601>5601</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5602>5602</a></td>\n' +
            '<td>#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5603>5603</a></td>\n' +
            '<td>    /* -- OSS things -- */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5604>5604</a></td>\n' +
            '<td>    struct snd_pcm_oss_runtime oss;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5605>5605</a></td>\n' +
            '<td>#endif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5606>5606</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5607>5607</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5608>5608</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5609>5609</a></td>\n' +
            '<td>For the operators (callbacks) of each sound driver, most of these records are supposed to be read-only. Only the PCM middle-layer changes / updates them. The exceptions are the hardware description (hw), interrupt callbacks (transfer_ack_xxx), DMA buffer information, and the private data. Besides, if you use the standard buffer allocation method via snd_pcm_lib_malloc_pages(), you don' + "'" + 't need to set the DMA buffer information by yourself.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5610>5610</a></td>\n' +
            '<td>In the sections below, important records are explained.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5611>5611</a></td>\n' +
            '<td>Hardware Description</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5612>5612</a></td>\n' +
            '<td>The hardware descriptor (struct snd_pcm_hardware) contains the definitions of the fundamental hardware configuration. Above all, you' + "'" + 'll need to define this in the open callback. Note that the runtime instance holds the copy of the descriptor, not the pointer to the existing descriptor. That is, in the open callback, you can modify the copied descriptor (runtime-&gt;hw) as you need. For example, if the maximum number of channels is 1 only on some chip models, you can still use the same hardware descriptor and change the channels_max later:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5613>5613</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5614>5614</a></td>\n' +
            '<td>          struct snd_pcm_runtime *runtime = substream-&gt;runtime;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5615>5615</a></td>\n' +
            '<td>          ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5616>5616</a></td>\n' +
            '<td>          runtime-&gt;hw = snd_mychip_playback_hw; /* common definition */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5617>5617</a></td>\n' +
            '<td>          if (chip-&gt;model == VERY_OLD_ONE)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5618>5618</a></td>\n' +
            '<td>                  runtime-&gt;hw.channels_max = 1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5619>5619</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5620>5620</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5621>5621</a></td>\n' +
            '<td>Typically, you' + "'" + 'll have a hardware descriptor as below:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5622>5622</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5623>5623</a></td>\n' +
            '<td>  static struct snd_pcm_hardware snd_mychip_playback_hw = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5624>5624</a></td>\n' +
            '<td>          .info = (SNDRV_PCM_INFO_MMAP |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5625>5625</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_INTERLEAVED |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5626>5626</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_BLOCK_TRANSFER |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5627>5627</a></td>\n' +
            '<td>                   SNDRV_PCM_INFO_MMAP_VALID),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5628>5628</a></td>\n' +
            '<td>          .formats =          SNDRV_PCM_FMTBIT_S16_LE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5629>5629</a></td>\n' +
            '<td>          .rates =            SNDRV_PCM_RATE_8000_48000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5630>5630</a></td>\n' +
            '<td>          .rate_min =         8000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5631>5631</a></td>\n' +
            '<td>          .rate_max =         48000,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5632>5632</a></td>\n' +
            '<td>          .channels_min =     2,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5633>5633</a></td>\n' +
            '<td>          .channels_max =     2,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5634>5634</a></td>\n' +
            '<td>          .buffer_bytes_max = 32768,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5635>5635</a></td>\n' +
            '<td>          .period_bytes_min = 4096,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5636>5636</a></td>\n' +
            '<td>          .period_bytes_max = 32768,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5637>5637</a></td>\n' +
            '<td>          .periods_min =      1,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5638>5638</a></td>\n' +
            '<td>          .periods_max =      1024,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5639>5639</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5640>5640</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5641>5641</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5642>5642</a></td>\n' +
            '<td>    The info field contains the type and capabilities of this pcm. The bit flags are defined in &lt;sound/asound.h&gt; as SNDRV_PCM_INFO_XXX. Here, at least, you have to specify whether the mmap is supported and which interleaved format is supported. When the hardware supports mmap, add the SNDRV_PCM_INFO_MMAP flag here. When the hardware supports the interleaved or the non-interleaved formats, SNDRV_PCM_INFO_INTERLEAVED or SNDRV_PCM_INFO_NONINTERLEAVED flag must be set, respectively. If both are supported, you can set both, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5643>5643</a></td>\n' +
            '<td>     In the above example, MMAP_VALID and BLOCK_TRANSFER are specified for the OSS mmap mode. Usually both are set. Of course, MMAP_VALID is set only if the mmap is really supported.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5644>5644</a></td>\n' +
            '<td>     The other possible flags are SNDRV_PCM_INFO_PAUSE and SNDRV_PCM_INFO_RESUME. The PAUSE bit means that the pcm supports the pause operation, while the RESUME bit means that the pcm supports the full suspend/resume operation. If the PAUSE flag is set, the trigger callback below must handle the corresponding (pause push/release) commands. The suspend/resume trigger commands can be defined even without the RESUME flag. See Power Management section for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5645>5645</a></td>\n' +
            '<td>     When the PCM substreams can be synchronized (typically, synchronized start/stop of a playback and a capture streams), you can give SNDRV_PCM_INFO_SYNC_START, too. In this case, you' + "'" + 'll need to check the linked-list of PCM substreams in the trigger callback. This will be described in the later section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5646>5646</a></td>\n' +
            '<td>    formats field contains the bit-flags of supported formats (SNDRV_PCM_FMTBIT_XXX). If the hardware supports more than one format, give all or' + "'" + 'ed bits. In the example above, the signed 16bit little-endian format is specified.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5647>5647</a></td>\n' +
            '<td>    rates field contains the bit-flags of supported rates (SNDRV_PCM_RATE_XXX). When the chip supports continuous rates, pass CONTINUOUS bit additionally. The pre-defined rate bits are provided only for typical rates. If your chip supports unconventional rates, you need to add the KNOT bit and set up the hardware constraint manually (explained later).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5648>5648</a></td>\n' +
            '<td>    rate_min and rate_max define the minimum and maximum sample rate. This should correspond somehow to rates bits.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5649>5649</a></td>\n' +
            '<td>    channel_min and channel_max define, as you might already expected, the minimum and maximum number of channels.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5650>5650</a></td>\n' +
            '<td>    buffer_bytes_max defines the maximum buffer size in bytes. There is no buffer_bytes_min field, since it can be calculated from the minimum period size and the minimum number of periods. Meanwhile, period_bytes_min and define the minimum and maximum size of the period in bytes. periods_max and periods_min define the maximum and minimum number of periods in the buffer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5651>5651</a></td>\n' +
            '<td>     The period is a term that corresponds to a fragment in the OSS world. The period defines the size at which a PCM interrupt is generated. This size strongly depends on the hardware. Generally, the smaller period size will give you more interrupts, that is, more controls. In the case of capture, this size defines the input latency. On the other hand, the whole buffer size defines the output latency for the playback direction.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5652>5652</a></td>\n' +
            '<td>    There is also a field fifo_size. This specifies the size of the hardware FIFO, but currently it is neither used in the driver nor in the alsa-lib. So, you can ignore this field.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5653>5653</a></td>\n' +
            '<td>PCM Configurations</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5654>5654</a></td>\n' +
            '<td>Ok, let' + "'" + 's go back again to the PCM runtime records. The most frequently referred records in the runtime instance are the PCM configurations. The PCM configurations are stored in the runtime instance after the application sends hw_params data via alsa-lib. There are many fields copied from hw_params and sw_params structs. For example, format holds the format type chosen by the application. This field contains the enum value SNDRV_PCM_FORMAT_XXX.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5655>5655</a></td>\n' +
            '<td>One thing to be noted is that the configured buffer and period sizes are stored in frames in the runtime. In the ALSA world, 1 frame = channels * samples-size. For conversion between frames and bytes, you can use the frames_to_bytes() and bytes_to_frames() helper functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5656>5656</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5657>5657</a></td>\n' +
            '<td>  period_bytes = frames_to_bytes(runtime, runtime-&gt;period_size);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5658>5658</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5659>5659</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5660>5660</a></td>\n' +
            '<td>Also, many software parameters (sw_params) are stored in frames, too. Please check the type of the field. snd_pcm_uframes_t is for the frames as unsigned integer while snd_pcm_sframes_t is for the frames as signed integer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5661>5661</a></td>\n' +
            '<td>DMA Buffer Information</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5662>5662</a></td>\n' +
            '<td>The DMA buffer is defined by the following four fields, dma_area, dma_addr, dma_bytes and dma_private. The dma_area holds the buffer pointer (the logical address). You can call memcpy from/to this pointer. Meanwhile, dma_addr holds the physical address of the buffer. This field is specified only when the buffer is a linear buffer. dma_bytes holds the size of buffer in bytes. dma_private is used for the ALSA DMA allocator.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5663>5663</a></td>\n' +
            '<td>If you use a standard ALSA function, snd_pcm_lib_malloc_pages(), for allocating the buffer, these fields are set by the ALSA middle layer, and you should not change them by yourself. You can read them but not write them. On the other hand, if you want to allocate the buffer by yourself, you' + "'" + 'll need to manage it in hw_params callback. At least, dma_bytes is mandatory. dma_area is necessary when the buffer is mmapped. If your driver doesn' + "'" + 't support mmap, this field is not necessary. dma_addr is also optional. You can use dma_private as you like, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5664>5664</a></td>\n' +
            '<td>Running Status</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5665>5665</a></td>\n' +
            '<td>The running status can be referred via runtime-&gt;status. This is the pointer to the struct snd_pcm_mmap_status record. For example, you can get the current DMA hardware pointer via runtime-&gt;status-&gt;hw_ptr.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5666>5666</a></td>\n' +
            '<td>The DMA application pointer can be referred via runtime-&gt;control, which points to the struct snd_pcm_mmap_control record. However, accessing directly to this value is not recommended.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5667>5667</a></td>\n' +
            '<td>Private Data</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5668>5668</a></td>\n' +
            '<td>You can allocate a record for the substream and store it in runtime-&gt;private_data. Usually, this is done in the open callback. Don' + "'" + 't mix this with pcm-&gt;private_data. The pcm-&gt;private_data usually points to the chip instance assigned statically at the creation of PCM, while the runtime-&gt;private_data points to a dynamic data structure created at the PCM open callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5669>5669</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5670>5670</a></td>\n' +
            '<td>  static int snd_xxx_open(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5671>5671</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5672>5672</a></td>\n' +
            '<td>          struct my_pcm_data *data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5673>5673</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5674>5674</a></td>\n' +
            '<td>          data = kmalloc(sizeof(*data), GFP_KERNEL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5675>5675</a></td>\n' +
            '<td>          substream-&gt;runtime-&gt;private_data = data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5676>5676</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5677>5677</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5678>5678</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5679>5679</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5680>5680</a></td>\n' +
            '<td>The allocated object must be released in the close callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5681>5681</a></td>\n' +
            '<td>Interrupt Callbacks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5682>5682</a></td>\n' +
            '<td>The field transfer_ack_begin and transfer_ack_end are called at the beginning and at the end of snd_pcm_period_elapsed(), respectively.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5683>5683</a></td>\n' +
            '<td>Operators</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5684>5684</a></td>\n' +
            '<td>OK, now let me give details about each pcm callback (ops). In general, every callback must return 0 if successful, or a negative error number such as -EINVAL. To choose an appropriate error number, it is advised to check what value other parts of the kernel return when the same kind of request fails.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5685>5685</a></td>\n' +
            '<td>The callback function takes at least the argument with snd_pcm_substream pointer. To retrieve the chip record from the given substream instance, you can use the following macro.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5686>5686</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5687>5687</a></td>\n' +
            '<td>  int xxx() {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5688>5688</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_substream_chip(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5689>5689</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5690>5690</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5691>5691</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5692>5692</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5693>5693</a></td>\n' +
            '<td>The macro reads substream-&gt;private_data, which is a copy of pcm-&gt;private_data. You can override the former if you need to assign different data records per PCM substream. For example, the cmi8330 driver assigns different private_data for playback and capture directions, because it uses two different codecs (SB- and AD-compatible) for different directions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5694>5694</a></td>\n' +
            '<td>open callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5695>5695</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5696>5696</a></td>\n' +
            '<td>  static int snd_xxx_open(struct snd_pcm_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5697>5697</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5698>5698</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5699>5699</a></td>\n' +
            '<td>This is called when a pcm substream is opened.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5700>5700</a></td>\n' +
            '<td>At least, here you have to initialize the runtime-&gt;hw record. Typically, this is done by like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5701>5701</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5702>5702</a></td>\n' +
            '<td>  static int snd_xxx_open(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5703>5703</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5704>5704</a></td>\n' +
            '<td>          struct mychip *chip = snd_pcm_substream_chip(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5705>5705</a></td>\n' +
            '<td>          struct snd_pcm_runtime *runtime = substream-&gt;runtime;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5706>5706</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5707>5707</a></td>\n' +
            '<td>          runtime-&gt;hw = snd_mychip_playback_hw;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5708>5708</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5709>5709</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5710>5710</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5711>5711</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5712>5712</a></td>\n' +
            '<td>where snd_mychip_playback_hw is the pre-defined hardware description.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5713>5713</a></td>\n' +
            '<td>You can allocate a private data in this callback, as described in Private Data section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5714>5714</a></td>\n' +
            '<td>If the hardware configuration needs more constraints, set the hardware constraints here, too. See Constraints for more details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5715>5715</a></td>\n' +
            '<td>close callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5716>5716</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5717>5717</a></td>\n' +
            '<td>  static int snd_xxx_close(struct snd_pcm_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5718>5718</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5719>5719</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5720>5720</a></td>\n' +
            '<td>Obviously, this is called when a pcm substream is closed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5721>5721</a></td>\n' +
            '<td>Any private instance for a pcm substream allocated in the open callback will be released here.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5722>5722</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5723>5723</a></td>\n' +
            '<td>  static int snd_xxx_close(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5724>5724</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5725>5725</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5726>5726</a></td>\n' +
            '<td>          kfree(substream-&gt;runtime-&gt;private_data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5727>5727</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5728>5728</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5729>5729</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5730>5730</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5731>5731</a></td>\n' +
            '<td>ioctl callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5732>5732</a></td>\n' +
            '<td>This is used for any special call to pcm ioctls. But usually you can pass a generic ioctl callback, snd_pcm_lib_ioctl.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5733>5733</a></td>\n' +
            '<td>hw_params callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5734>5734</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5735>5735</a></td>\n' +
            '<td>  static int snd_xxx_hw_params(struct snd_pcm_substream *substream,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5736>5736</a></td>\n' +
            '<td>                               struct snd_pcm_hw_params *hw_params);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5737>5737</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5738>5738</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5739>5739</a></td>\n' +
            '<td>This is called when the hardware parameter (hw_params) is set up by the application, that is, once when the buffer size, the period size, the format, etc. are defined for the pcm substream.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5740>5740</a></td>\n' +
            '<td>Many hardware setups should be done in this callback, including the allocation of buffers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5741>5741</a></td>\n' +
            '<td>Parameters to be initialized are retrieved by params_xxx() macros. To allocate buffer, you can call a helper function,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5742>5742</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5743>5743</a></td>\n' +
            '<td>  snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5744>5744</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5745>5745</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5746>5746</a></td>\n' +
            '<td>snd_pcm_lib_malloc_pages() is available only when the DMA buffers have been pre-allocated. See the section Buffer Types for more details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5747>5747</a></td>\n' +
            '<td>Note that this and prepare callbacks may be called multiple times per initialization. For example, the OSS emulation may call these callbacks at each change via its ioctl.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5748>5748</a></td>\n' +
            '<td>Thus, you need to be careful not to allocate the same buffers many times, which will lead to memory leaks! Calling the helper function above many times is OK. It will release the previous buffer automatically when it was already allocated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5749>5749</a></td>\n' +
            '<td>Another note is that this callback is non-atomic (schedulable). This is important, because the trigger callback is atomic (non-schedulable). That is, mutexes or any schedule-related functions are not available in trigger callback. Please see the subsection Atomicity for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5750>5750</a></td>\n' +
            '<td>hw_free callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5751>5751</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5752>5752</a></td>\n' +
            '<td>  static int snd_xxx_hw_free(struct snd_pcm_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5753>5753</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5754>5754</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5755>5755</a></td>\n' +
            '<td>This is called to release the resources allocated via hw_params. For example, releasing the buffer via snd_pcm_lib_malloc_pages() is done by calling the following:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5756>5756</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5757>5757</a></td>\n' +
            '<td>  snd_pcm_lib_free_pages(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5758>5758</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5759>5759</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5760>5760</a></td>\n' +
            '<td>This function is always called before the close callback is called. Also, the callback may be called multiple times, too. Keep track whether the resource was already released.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5761>5761</a></td>\n' +
            '<td>prepare callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5762>5762</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5763>5763</a></td>\n' +
            '<td>  static int snd_xxx_prepare(struct snd_pcm_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5764>5764</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5765>5765</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5766>5766</a></td>\n' +
            '<td>This callback is called when the pcm is prepared. You can set the format type, sample rate, etc. here. The difference from hw_params is that the prepare callback will be called each time snd_pcm_prepare() is called, i.e. when recovering after underruns, etc.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5767>5767</a></td>\n' +
            '<td>Note that this callback is now non-atomic. You can use schedule-related functions safely in this callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5768>5768</a></td>\n' +
            '<td>In this and the following callbacks, you can refer to the values via the runtime record, substream-&gt;runtime. For example, to get the current rate, format or channels, access to runtime-&gt;rate, runtime-&gt;format or runtime-&gt;channels, respectively. The physical address of the allocated buffer is set to runtime-&gt;dma_area. The buffer and period sizes are in runtime-&gt;buffer_size and runtime-&gt;period_size, respectively.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5769>5769</a></td>\n' +
            '<td>Be careful that this callback will be called many times at each setup, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5770>5770</a></td>\n' +
            '<td>trigger callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5771>5771</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5772>5772</a></td>\n' +
            '<td>  static int snd_xxx_trigger(struct snd_pcm_substream *substream, int cmd);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5773>5773</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5774>5774</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5775>5775</a></td>\n' +
            '<td>This is called when the pcm is started, stopped or paused.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5776>5776</a></td>\n' +
            '<td>Which action is specified in the second argument, SNDRV_PCM_TRIGGER_XXX in &lt;sound/pcm.h&gt;. At least, the START and STOP commands must be defined in this callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5777>5777</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5778>5778</a></td>\n' +
            '<td>  switch (cmd) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5779>5779</a></td>\n' +
            '<td>  case SNDRV_PCM_TRIGGER_START:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5780>5780</a></td>\n' +
            '<td>          /* do something to start the PCM engine */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5781>5781</a></td>\n' +
            '<td>          break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5782>5782</a></td>\n' +
            '<td>  case SNDRV_PCM_TRIGGER_STOP:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5783>5783</a></td>\n' +
            '<td>          /* do something to stop the PCM engine */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5784>5784</a></td>\n' +
            '<td>          break;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5785>5785</a></td>\n' +
            '<td>  default:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5786>5786</a></td>\n' +
            '<td>          return -EINVAL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5787>5787</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5788>5788</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5789>5789</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5790>5790</a></td>\n' +
            '<td>When the pcm supports the pause operation (given in the info field of the hardware table), the PAUSE_PUSH and PAUSE_RELEASE commands must be handled here, too. The former is the command to pause the pcm, and the latter to restart the pcm again.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5791>5791</a></td>\n' +
            '<td>When the pcm supports the suspend/resume operation, regardless of full or partial suspend/resume support, the SUSPEND and RESUME commands must be handled, too. These commands are issued when the power-management status is changed. Obviously, the SUSPEND and RESUME commands suspend and resume the pcm substream, and usually, they are identical to the STOP and START commands, respectively. See the Power Management section for details.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5792>5792</a></td>\n' +
            '<td>As mentioned, this callback is atomic. You cannot call functions which may sleep. The trigger callback should be as minimal as possible, just really triggering the DMA. The other stuff should be initialized hw_params and prepare callbacks properly beforehand.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5793>5793</a></td>\n' +
            '<td>pointer callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5794>5794</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5795>5795</a></td>\n' +
            '<td>  static snd_pcm_uframes_t snd_xxx_pointer(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5796>5796</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5797>5797</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5798>5798</a></td>\n' +
            '<td>This callback is called when the PCM middle layer inquires the current hardware position on the buffer. The position must be returned in frames, ranging from 0 to buffer_size - 1.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5799>5799</a></td>\n' +
            '<td>This is called usually from the buffer-update routine in the pcm middle layer, which is invoked when snd_pcm_period_elapsed() is called in the interrupt routine. Then the pcm middle layer updates the position and calculates the available space, and wakes up the sleeping poll threads, etc.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5800>5800</a></td>\n' +
            '<td>This callback is also atomic.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5801>5801</a></td>\n' +
            '<td>copy and silence callbacks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5802>5802</a></td>\n' +
            '<td>These callbacks are not mandatory, and can be omitted in most cases. These callbacks are used when the hardware buffer cannot be in the normal memory space. Some chips have their own buffer on the hardware which is not mappable. In such a case, you have to transfer the data manually from the memory buffer to the hardware buffer. Or, if the buffer is non-contiguous on both physical and virtual memory spaces, these callbacks must be defined, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5803>5803</a></td>\n' +
            '<td>If these two callbacks are defined, copy and set-silence operations are done by them. The detailed will be described in the later section Buffer and Memory Management.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5804>5804</a></td>\n' +
            '<td>ack callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5805>5805</a></td>\n' +
            '<td>This callback is also not mandatory. This callback is called when the appl_ptr is updated in read or write operations. Some drivers like emu10k1-fx and cs46xx need to track the current appl_ptr for the internal buffer, and this callback is useful only for such a purpose.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5806>5806</a></td>\n' +
            '<td>This callback is atomic.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5807>5807</a></td>\n' +
            '<td>page callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5808>5808</a></td>\n' +
            '<td>This callback is optional too. This callback is used mainly for non-contiguous buffers. The mmap calls this callback to get the page address. Some examples will be explained in the later section Buffer and Memory Management, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5809>5809</a></td>\n' +
            '<td>Interrupt Handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5810>5810</a></td>\n' +
            '<td>The rest of pcm stuff is the PCM interrupt handler. The role of PCM interrupt handler in the sound driver is to update the buffer position and to tell the PCM middle layer when the buffer position goes across the prescribed period size. To inform this, call the snd_pcm_period_elapsed() function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5811>5811</a></td>\n' +
            '<td>There are several types of sound chips to generate the interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5812>5812</a></td>\n' +
            '<td>Interrupts at the period (fragment) boundary</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5813>5813</a></td>\n' +
            '<td>This is the most frequently found type: the hardware generates an interrupt at each period boundary. In this case, you can call snd_pcm_period_elapsed() at each interrupt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5814>5814</a></td>\n' +
            '<td>snd_pcm_period_elapsed() takes the substream pointer as its argument. Thus, you need to keep the substream pointer accessible from the chip instance. For example, define substream field in the chip record to hold the current running substream pointer, and set the pointer value at open callback (and reset at close callback).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5815>5815</a></td>\n' +
            '<td>If you acquire a spinlock in the interrupt handler, and the lock is used in other pcm callbacks, too, then you have to release the lock before calling snd_pcm_period_elapsed(), because snd_pcm_period_elapsed() calls other pcm callbacks inside.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5816>5816</a></td>\n' +
            '<td>Typical code would be like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5817>5817</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5818>5818</a></td>\n' +
            '<td>  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5819>5819</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5820>5820</a></td>\n' +
            '<td>          struct mychip *chip = dev_id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5821>5821</a></td>\n' +
            '<td>          spin_lock(&amp;chip-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5822>5822</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5823>5823</a></td>\n' +
            '<td>          if (pcm_irq_invoked(chip)) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5824>5824</a></td>\n' +
            '<td>                  /* call updater, unlock before it */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5825>5825</a></td>\n' +
            '<td>                  spin_unlock(&amp;chip-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5826>5826</a></td>\n' +
            '<td>                  snd_pcm_period_elapsed(chip-&gt;substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5827>5827</a></td>\n' +
            '<td>                  spin_lock(&amp;chip-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5828>5828</a></td>\n' +
            '<td>                  /* acknowledge the interrupt if necessary */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5829>5829</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5830>5830</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5831>5831</a></td>\n' +
            '<td>          spin_unlock(&amp;chip-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5832>5832</a></td>\n' +
            '<td>          return IRQ_HANDLED;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5833>5833</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5834>5834</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5835>5835</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5836>5836</a></td>\n' +
            '<td>High frequency timer interrupts</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5837>5837</a></td>\n' +
            '<td>This happens when the hardware doesn' + "'" + 't generate interrupts at the period boundary but issues timer interrupts at a fixed timer rate (e.g. es1968 or ymfpci drivers). In this case, you need to check the current hardware position and accumulate the processed sample length at each interrupt. When the accumulated size exceeds the period size, call snd_pcm_period_elapsed() and reset the accumulator.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5838>5838</a></td>\n' +
            '<td>Typical code would be like the following.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5839>5839</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5840>5840</a></td>\n' +
            '<td>  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5841>5841</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5842>5842</a></td>\n' +
            '<td>          struct mychip *chip = dev_id;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5843>5843</a></td>\n' +
            '<td>          spin_lock(&amp;chip-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5844>5844</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5845>5845</a></td>\n' +
            '<td>          if (pcm_irq_invoked(chip)) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5846>5846</a></td>\n' +
            '<td>                  unsigned int last_ptr, size;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5847>5847</a></td>\n' +
            '<td>                  /* get the current hardware pointer (in frames) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5848>5848</a></td>\n' +
            '<td>                  last_ptr = get_hw_ptr(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5849>5849</a></td>\n' +
            '<td>                  /* calculate the processed frames since the</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5850>5850</a></td>\n' +
            '<td>                   * last update</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5851>5851</a></td>\n' +
            '<td>                   */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5852>5852</a></td>\n' +
            '<td>                  if (last_ptr &lt; chip-&gt;last_ptr)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5853>5853</a></td>\n' +
            '<td>                          size = runtime-&gt;buffer_size + last_ptr</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5854>5854</a></td>\n' +
            '<td>                                   - chip-&gt;last_ptr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5855>5855</a></td>\n' +
            '<td>                  else</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5856>5856</a></td>\n' +
            '<td>                          size = last_ptr - chip-&gt;last_ptr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5857>5857</a></td>\n' +
            '<td>                  /* remember the last updated point */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5858>5858</a></td>\n' +
            '<td>                  chip-&gt;last_ptr = last_ptr;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5859>5859</a></td>\n' +
            '<td>                  /* accumulate the size */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5860>5860</a></td>\n' +
            '<td>                  chip-&gt;size += size;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5861>5861</a></td>\n' +
            '<td>                  /* over the period boundary? */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5862>5862</a></td>\n' +
            '<td>                  if (chip-&gt;size &gt;= runtime-&gt;period_size) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5863>5863</a></td>\n' +
            '<td>                          /* reset the accumulator */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5864>5864</a></td>\n' +
            '<td>                          chip-&gt;size %= runtime-&gt;period_size;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5865>5865</a></td>\n' +
            '<td>                          /* call updater */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5866>5866</a></td>\n' +
            '<td>                          spin_unlock(&amp;chip-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5867>5867</a></td>\n' +
            '<td>                          snd_pcm_period_elapsed(substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5868>5868</a></td>\n' +
            '<td>                          spin_lock(&amp;chip-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5869>5869</a></td>\n' +
            '<td>                  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5870>5870</a></td>\n' +
            '<td>                  /* acknowledge the interrupt if necessary */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5871>5871</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5872>5872</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5873>5873</a></td>\n' +
            '<td>          spin_unlock(&amp;chip-&gt;lock);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5874>5874</a></td>\n' +
            '<td>          return IRQ_HANDLED;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5875>5875</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5876>5876</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5877>5877</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5878>5878</a></td>\n' +
            '<td>On calling snd_pcm_period_elapsed()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5879>5879</a></td>\n' +
            '<td>In both cases, even if more than one period are elapsed, you don' + "'" + 't have to call snd_pcm_period_elapsed() many times. Call only once. And the pcm layer will check the current hardware pointer and update to the latest status.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5880>5880</a></td>\n' +
            '<td>Atomicity</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5881>5881</a></td>\n' +
            '<td>One of the most important (and thus difficult to debug) problems in kernel programming are race conditions. In the Linux kernel, they are usually avoided via spin-locks, mutexes or semaphores. In general, if a race condition can happen in an interrupt handler, it has to be managed atomically, and you have to use a spinlock to protect the critical session. If the critical section is not in interrupt handler code and if taking a relatively long time to execute is acceptable, you should use mutexes or semaphores instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5882>5882</a></td>\n' +
            '<td>As already seen, some pcm callbacks are atomic and some are not. For example, the hw_params callback is non-atomic, while trigger callback is atomic. This means, the latter is called already in a spinlock held by the PCM middle layer. Please take this atomicity into account when you choose a locking scheme in the callbacks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5883>5883</a></td>\n' +
            '<td>In the atomic callbacks, you cannot use functions which may call schedule or go to sleep. Semaphores and mutexes can sleep, and hence they cannot be used inside the atomic callbacks (e.g. trigger callback). To implement some delay in such a callback, please use udelay() or mdelay().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5884>5884</a></td>\n' +
            '<td>All three atomic callbacks (trigger, pointer, and ack) are called with local interrupts disabled.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5885>5885</a></td>\n' +
            '<td>Constraints</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5886>5886</a></td>\n' +
            '<td>If your chip supports unconventional sample rates, or only the limited samples, you need to set a constraint for the condition.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5887>5887</a></td>\n' +
            '<td>For example, in order to restrict the sample rates in the some supported values, use snd_pcm_hw_constraint_list(). You need to call this function in the open callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5888>5888</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5889>5889</a></td>\n' +
            '<td>  static unsigned int rates[] =</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5890>5890</a></td>\n' +
            '<td>          {4000, 10000, 22050, 44100};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5891>5891</a></td>\n' +
            '<td>  static struct snd_pcm_hw_constraint_list constraints_rates = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5892>5892</a></td>\n' +
            '<td>          .count = ARRAY_SIZE(rates),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5893>5893</a></td>\n' +
            '<td>          .list = rates,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5894>5894</a></td>\n' +
            '<td>          .mask = 0,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5895>5895</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5896>5896</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5897>5897</a></td>\n' +
            '<td>  static int snd_mychip_pcm_open(struct snd_pcm_substream *substream)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5898>5898</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5899>5899</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5900>5900</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5901>5901</a></td>\n' +
            '<td>          err = snd_pcm_hw_constraint_list(substream-&gt;runtime, 0,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5902>5902</a></td>\n' +
            '<td>                                           SNDRV_PCM_HW_PARAM_RATE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5903>5903</a></td>\n' +
            '<td>                                           &amp;constraints_rates);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5904>5904</a></td>\n' +
            '<td>          if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5905>5905</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5906>5906</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5907>5907</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5908>5908</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5909>5909</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5910>5910</a></td>\n' +
            '<td>There are many different constraints. Look at sound/pcm.h for a complete list. You can even define your own constraint rules. For example, let' + "'" + 's suppose my_chip can manage a substream of 1 channel if and only if the format is S16_LE, otherwise it supports any format specified in the snd_pcm_hardware structure (or in any other constraint_list). You can build a rule like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5911>5911</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5912>5912</a></td>\n' +
            '<td>  static int hw_rule_channels_by_format(struct snd_pcm_hw_params *params,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5913>5913</a></td>\n' +
            '<td>                                        struct snd_pcm_hw_rule *rule)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5914>5914</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5915>5915</a></td>\n' +
            '<td>          struct snd_interval *c = hw_param_interval(params,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5916>5916</a></td>\n' +
            '<td>                        SNDRV_PCM_HW_PARAM_CHANNELS);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5917>5917</a></td>\n' +
            '<td>          struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5918>5918</a></td>\n' +
            '<td>          struct snd_interval ch;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5919>5919</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5920>5920</a></td>\n' +
            '<td>          snd_interval_any(&amp;ch);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5921>5921</a></td>\n' +
            '<td>          if (f-&gt;bits[0] == SNDRV_PCM_FMTBIT_S16_LE) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5922>5922</a></td>\n' +
            '<td>                  ch.min = ch.max = 1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5923>5923</a></td>\n' +
            '<td>                  ch.integer = 1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5924>5924</a></td>\n' +
            '<td>                  return snd_interval_refine(c, &amp;ch);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5925>5925</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5926>5926</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5927>5927</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5928>5928</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5929>5929</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5930>5930</a></td>\n' +
            '<td>Then you need to call this function to add your rule:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5931>5931</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5932>5932</a></td>\n' +
            '<td>  snd_pcm_hw_rule_add(substream-&gt;runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5933>5933</a></td>\n' +
            '<td>                      hw_rule_channels_by_format, NULL,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5934>5934</a></td>\n' +
            '<td>                      SNDRV_PCM_HW_PARAM_FORMAT, -1);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5935>5935</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5936>5936</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5937>5937</a></td>\n' +
            '<td>The rule function is called when an application sets the PCM format, and it refines the number of channels accordingly. But an application may set the number of channels before setting the format. Thus you also need to define the inverse rule:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5938>5938</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5939>5939</a></td>\n' +
            '<td>  static int hw_rule_format_by_channels(struct snd_pcm_hw_params *params,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5940>5940</a></td>\n' +
            '<td>                                        struct snd_pcm_hw_rule *rule)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5941>5941</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5942>5942</a></td>\n' +
            '<td>          struct snd_interval *c = hw_param_interval(params,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5943>5943</a></td>\n' +
            '<td>                SNDRV_PCM_HW_PARAM_CHANNELS);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5944>5944</a></td>\n' +
            '<td>          struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5945>5945</a></td>\n' +
            '<td>          struct snd_mask fmt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5946>5946</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5947>5947</a></td>\n' +
            '<td>          snd_mask_any(&amp;fmt);    /* Init the struct */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5948>5948</a></td>\n' +
            '<td>          if (c-&gt;min &lt; 2) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5949>5949</a></td>\n' +
            '<td>                  fmt.bits[0] &amp;= SNDRV_PCM_FMTBIT_S16_LE;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5950>5950</a></td>\n' +
            '<td>                  return snd_mask_refine(f, &amp;fmt);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5951>5951</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5952>5952</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5953>5953</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5954>5954</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5955>5955</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5956>5956</a></td>\n' +
            '<td>...and in the open callback:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5957>5957</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5958>5958</a></td>\n' +
            '<td>  snd_pcm_hw_rule_add(substream-&gt;runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5959>5959</a></td>\n' +
            '<td>                      hw_rule_format_by_channels, NULL,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5960>5960</a></td>\n' +
            '<td>                      SNDRV_PCM_HW_PARAM_CHANNELS, -1);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5961>5961</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5962>5962</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5963>5963</a></td>\n' +
            '<td>I won' + "'" + 't give more details here, rather I would like to say, Luke, use the source.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5964>5964</a></td>\n' +
            '<td>Control Interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5965>5965</a></td>\n' +
            '<td>General</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5966>5966</a></td>\n' +
            '<td>The control interface is used widely for many switches, sliders, etc. which are accessed from user-space. Its most important use is the mixer interface. In other words, since ALSA 0.9.x, all the mixer stuff is implemented on the control kernel API.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5967>5967</a></td>\n' +
            '<td>ALSA has a well-defined AC97 control module. If your chip supports only the AC97 and nothing else, you can skip this section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5968>5968</a></td>\n' +
            '<td>The control API is defined in &lt;sound/control.h&gt;. Include this file if you want to add your own controls.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5969>5969</a></td>\n' +
            '<td>Definition of Controls</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5970>5970</a></td>\n' +
            '<td>To create a new control, you need to define the following three callbacks: info, get and put. Then, define a struct snd_kcontrol_new record, such as:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5971>5971</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5972>5972</a></td>\n' +
            '<td>  static struct snd_kcontrol_new my_control = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5973>5973</a></td>\n' +
            '<td>          .iface = SNDRV_CTL_ELEM_IFACE_MIXER,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5974>5974</a></td>\n' +
            '<td>          .name = "PCM Playback Switch",</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5975>5975</a></td>\n' +
            '<td>          .index = 0,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5976>5976</a></td>\n' +
            '<td>          .access = SNDRV_CTL_ELEM_ACCESS_READWRITE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5977>5977</a></td>\n' +
            '<td>          .private_value = 0xffff,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5978>5978</a></td>\n' +
            '<td>          .info = my_control_info,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5979>5979</a></td>\n' +
            '<td>          .get = my_control_get,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5980>5980</a></td>\n' +
            '<td>          .put = my_control_put</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5981>5981</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5982>5982</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5983>5983</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5984>5984</a></td>\n' +
            '<td>The iface field specifies the control type, SNDRV_CTL_ELEM_IFACE_XXX, which is usually MIXER. Use CARD for global controls that are not logically part of the mixer. If the control is closely associated with some specific device on the sound card, use HWDEP, PCM, RAWMIDI, TIMER, or SEQUENCER, and specify the device number with the device and subdevice fields.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5985>5985</a></td>\n' +
            '<td>The name is the name identifier string. Since ALSA 0.9.x, the control name is very important, because its role is classified from its name. There are pre-defined standard control names. The details are described in the Control Names subsection.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5986>5986</a></td>\n' +
            '<td>The index field holds the index number of this control. If there are several different controls with the same name, they can be distinguished by the index number. This is the case when several codecs exist on the card. If the index is zero, you can omit the definition above.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5987>5987</a></td>\n' +
            '<td>The access field contains the access type of this control. Give the combination of bit masks, SNDRV_CTL_ELEM_ACCESS_XXX, there. The details will be explained in the Access Flags subsection.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5988>5988</a></td>\n' +
            '<td>The private_value field contains an arbitrary long integer value for this record. When using the generic info, get and put callbacks, you can pass a value through this field. If several small numbers are necessary, you can combine them in bitwise. Or, it' + "'" + 's possible to give a pointer (casted to unsigned long) of some record to this field, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5989>5989</a></td>\n' +
            '<td>The tlv field can be used to provide metadata about the control; see the Metadata subsection.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5990>5990</a></td>\n' +
            '<td>The other three are callback functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5991>5991</a></td>\n' +
            '<td>Control Names</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5992>5992</a></td>\n' +
            '<td>There are some standards to define the control names. A control is usually defined from the three parts as SOURCE DIRECTION FUNCTION.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5993>5993</a></td>\n' +
            '<td>The first, SOURCE, specifies the source of the control, and is a string such as Master, PCM, CD and Line. There are many pre-defined sources.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5994>5994</a></td>\n' +
            '<td>The second, DIRECTION, is one of the following strings according to the direction of the control: Playback, Capture, Bypass Playback and Bypass Capture. Or, it can be omitted, meaning both playback and capture directions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5995>5995</a></td>\n' +
            '<td>The third, FUNCTION, is one of the following strings according to the function of the control: Switch, Volume and Route.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5996>5996</a></td>\n' +
            '<td>The example of control names are, thus, Master Capture Switch or PCM Playback Volume.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5997>5997</a></td>\n' +
            '<td>There are some exceptions:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5998>5998</a></td>\n' +
            '<td>Global capture and playback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=5999>5999</a></td>\n' +
            '<td>Capture Source, Capture Switch and Capture Volume are used for the global capture (input) source, switch and volume. Similarly, Playback Switch and Playback Volume are used for the global output gain switch and volume.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6000>6000</a></td>\n' +
            '<td>Tone-controls</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6001>6001</a></td>\n' +
            '<td>tone-control switch and volumes are specified like Tone Control - XXX, e.g. Tone Control - Switch, Tone Control - Bass, Tone Control - Center.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6002>6002</a></td>\n' +
            '<td>3D controls</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6003>6003</a></td>\n' +
            '<td>3D-control switches and volumes are specified like 3D Control - XXX, e.g. 3D Control - Switch, 3D Control - Center, 3D Control - Space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6004>6004</a></td>\n' +
            '<td>Mic boost</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6005>6005</a></td>\n' +
            '<td>Mic-boost switch is set as Mic Boost or Mic Boost (6dB).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6006>6006</a></td>\n' +
            '<td>More precise information can be found in Documentation/sound/alsa/ControlNames.txt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6007>6007</a></td>\n' +
            '<td>Access Flags</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6008>6008</a></td>\n' +
            '<td>The access flag is the bitmask which specifies the access type of the given control. The default access type is SNDRV_CTL_ELEM_ACCESS_READWRITE, which means both read and write are allowed to this control. When the access flag is omitted (i.e. = 0), it is considered as READWRITE access as default.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6009>6009</a></td>\n' +
            '<td>When the control is read-only, pass SNDRV_CTL_ELEM_ACCESS_READ instead. In this case, you don' + "'" + 't have to define the put callback. Similarly, when the control is write-only (although it' + "'" + 's a rare case), you can use the WRITE flag instead, and you don' + "'" + 't need the get callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6010>6010</a></td>\n' +
            '<td>If the control value changes frequently (e.g. the VU meter), VOLATILE flag should be given. This means that the control may be changed without notification. Applications should poll such a control constantly.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6011>6011</a></td>\n' +
            '<td>When the control is inactive, set the INACTIVE flag, too. There are LOCK and OWNER flags to change the write permissions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6012>6012</a></td>\n' +
            '<td>Callbacks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6013>6013</a></td>\n' +
            '<td>info callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6014>6014</a></td>\n' +
            '<td>The info callback is used to get detailed information on this control. This must store the values of the given struct snd_ctl_elem_info object. For example, for a boolean control with a single element:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6015>6015</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6016>6016</a></td>\n' +
            '<td>  static int snd_myctl_mono_info(struct snd_kcontrol *kcontrol,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6017>6017</a></td>\n' +
            '<td>                          struct snd_ctl_elem_info *uinfo)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6018>6018</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6019>6019</a></td>\n' +
            '<td>          uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6020>6020</a></td>\n' +
            '<td>          uinfo-&gt;count = 1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6021>6021</a></td>\n' +
            '<td>          uinfo-&gt;value.integer.min = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6022>6022</a></td>\n' +
            '<td>          uinfo-&gt;value.integer.max = 1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6023>6023</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6024>6024</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6025>6025</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6026>6026</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6027>6027</a></td>\n' +
            '<td>The type field specifies the type of the control. There are BOOLEAN, INTEGER, ENUMERATED, BYTES, IEC958 and INTEGER64. The count field specifies the number of elements in this control. For example, a stereo volume would have count = 2. The value field is a union, and the values stored are depending on the type. The boolean and integer types are identical.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6028>6028</a></td>\n' +
            '<td>The enumerated type is a bit different from others. You' + "'" + 'll need to set the string for the currently given item index.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6029>6029</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6030>6030</a></td>\n' +
            '<td>  static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6031>6031</a></td>\n' +
            '<td>                          struct snd_ctl_elem_info *uinfo)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6032>6032</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6033>6033</a></td>\n' +
            '<td>          static char *texts[4] = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6034>6034</a></td>\n' +
            '<td>                  "First", "Second", "Third", "Fourth"</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6035>6035</a></td>\n' +
            '<td>          };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6036>6036</a></td>\n' +
            '<td>          uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6037>6037</a></td>\n' +
            '<td>          uinfo-&gt;count = 1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6038>6038</a></td>\n' +
            '<td>          uinfo-&gt;value.enumerated.items = 4;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6039>6039</a></td>\n' +
            '<td>          if (uinfo-&gt;value.enumerated.item &gt; 3)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6040>6040</a></td>\n' +
            '<td>                  uinfo-&gt;value.enumerated.item = 3;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6041>6041</a></td>\n' +
            '<td>          strcpy(uinfo-&gt;value.enumerated.name,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6042>6042</a></td>\n' +
            '<td>                 texts[uinfo-&gt;value.enumerated.item]);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6043>6043</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6044>6044</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6045>6045</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6046>6046</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6047>6047</a></td>\n' +
            '<td>Some common info callbacks are available for your convenience: snd_ctl_boolean_mono_info() and snd_ctl_boolean_stereo_info(). Obviously, the former is an info callback for a mono channel boolean item, just like snd_myctl_mono_info above, and the latter is for a stereo channel boolean item.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6048>6048</a></td>\n' +
            '<td>get callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6049>6049</a></td>\n' +
            '<td>This callback is used to read the current value of the control and to return to user-space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6050>6050</a></td>\n' +
            '<td>For example,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6051>6051</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6052>6052</a></td>\n' +
            '<td>  static int snd_myctl_get(struct snd_kcontrol *kcontrol,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6053>6053</a></td>\n' +
            '<td>                           struct snd_ctl_elem_value *ucontrol)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6054>6054</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6055>6055</a></td>\n' +
            '<td>          struct mychip *chip = snd_kcontrol_chip(kcontrol);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6056>6056</a></td>\n' +
            '<td>          ucontrol-&gt;value.integer.value[0] = get_some_value(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6057>6057</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6058>6058</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6059>6059</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6060>6060</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6061>6061</a></td>\n' +
            '<td>The value field depends on the type of control as well as on the info callback. For example, the sb driver uses this field to store the register offset, the bit-shift and the bit-mask. The private_value field is set as follows:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6062>6062</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6063>6063</a></td>\n' +
            '<td>  .private_value = reg | (shift &lt;&lt; 16) | (mask &lt;&lt; 24)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6064>6064</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6065>6065</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6066>6066</a></td>\n' +
            '<td>and is retrieved in callbacks like</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6067>6067</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6068>6068</a></td>\n' +
            '<td>  static int snd_sbmixer_get_single(struct snd_kcontrol *kcontrol,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6069>6069</a></td>\n' +
            '<td>                                    struct snd_ctl_elem_value *ucontrol)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6070>6070</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6071>6071</a></td>\n' +
            '<td>          int reg = kcontrol-&gt;private_value &amp; 0xff;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6072>6072</a></td>\n' +
            '<td>          int shift = (kcontrol-&gt;private_value &gt;&gt; 16) &amp; 0xff;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6073>6073</a></td>\n' +
            '<td>          int mask = (kcontrol-&gt;private_value &gt;&gt; 24) &amp; 0xff;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6074>6074</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6075>6075</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6076>6076</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6077>6077</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6078>6078</a></td>\n' +
            '<td>In the get callback, you have to fill all the elements if the control has more than one elements, i.e. count &gt; 1. In the example above, we filled only one element (value.integer.value[0]) since it' + "'" + 's assumed as count = 1.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6079>6079</a></td>\n' +
            '<td>put callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6080>6080</a></td>\n' +
            '<td>This callback is used to write a value from user-space.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6081>6081</a></td>\n' +
            '<td>For example,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6082>6082</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6083>6083</a></td>\n' +
            '<td>  static int snd_myctl_put(struct snd_kcontrol *kcontrol,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6084>6084</a></td>\n' +
            '<td>                           struct snd_ctl_elem_value *ucontrol)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6085>6085</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6086>6086</a></td>\n' +
            '<td>          struct mychip *chip = snd_kcontrol_chip(kcontrol);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6087>6087</a></td>\n' +
            '<td>          int changed = 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6088>6088</a></td>\n' +
            '<td>          if (chip-&gt;current_value !=</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6089>6089</a></td>\n' +
            '<td>               ucontrol-&gt;value.integer.value[0]) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6090>6090</a></td>\n' +
            '<td>                  change_current_value(chip,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6091>6091</a></td>\n' +
            '<td>                              ucontrol-&gt;value.integer.value[0]);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6092>6092</a></td>\n' +
            '<td>                  changed = 1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6093>6093</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6094>6094</a></td>\n' +
            '<td>          return changed;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6095>6095</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6096>6096</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6097>6097</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6098>6098</a></td>\n' +
            '<td>As seen above, you have to return 1 if the value is changed. If the value is not changed, return 0 instead. If any fatal error happens, return a negative error code as usual.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6099>6099</a></td>\n' +
            '<td>As in the get callback, when the control has more than one elements, all elements must be evaluated in this callback, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6100>6100</a></td>\n' +
            '<td>Callbacks are not atomic</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6101>6101</a></td>\n' +
            '<td>All these three callbacks are basically not atomic.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6102>6102</a></td>\n' +
            '<td>Constructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6103>6103</a></td>\n' +
            '<td>When everything is ready, finally we can create a new control. To create a control, there are two functions to be called, snd_ctl_new1() and snd_ctl_add().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6104>6104</a></td>\n' +
            '<td>In the simplest way, you can do like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6105>6105</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6106>6106</a></td>\n' +
            '<td>  err = snd_ctl_add(card, snd_ctl_new1(&amp;my_control, chip));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6107>6107</a></td>\n' +
            '<td>  if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6108>6108</a></td>\n' +
            '<td>          return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6109>6109</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6110>6110</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6111>6111</a></td>\n' +
            '<td>where my_control is the struct snd_kcontrol_new object defined above, and chip is the object pointer to be passed to kcontrol-&gt;private_data which can be referred to in callbacks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6112>6112</a></td>\n' +
            '<td>snd_ctl_new1() allocates a new snd_kcontrol instance, and snd_ctl_add assigns the given control component to the card.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6113>6113</a></td>\n' +
            '<td>Change Notification</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6114>6114</a></td>\n' +
            '<td>If you need to change and update a control in the interrupt routine, you can call snd_ctl_notify(). For example,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6115>6115</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6116>6116</a></td>\n' +
            '<td>  snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, id_pointer);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6117>6117</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6118>6118</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6119>6119</a></td>\n' +
            '<td>This function takes the card pointer, the event-mask, and the control id pointer for the notification. The event-mask specifies the types of notification, for example, in the above example, the change of control values is notified. The id pointer is the pointer of struct snd_ctl_elem_id to be notified. You can find some examples in es1938.c or es1968.c for hardware volume interrupts.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6120>6120</a></td>\n' +
            '<td>Metadata</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6121>6121</a></td>\n' +
            '<td>To provide information about the dB values of a mixer control, use on of the DECLARE_TLV_xxx macros from &lt;sound/tlv.h&gt; to define a variable containing this information, set thetlv.p field to point to this variable, and include the SNDRV_CTL_ELEM_ACCESS_TLV_READ flag in the access field; like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6122>6122</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6123>6123</a></td>\n' +
            '<td>  static DECLARE_TLV_DB_SCALE(db_scale_my_control, -4050, 150, 0);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6124>6124</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6125>6125</a></td>\n' +
            '<td>  static struct snd_kcontrol_new my_control = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6126>6126</a></td>\n' +
            '<td>          ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6127>6127</a></td>\n' +
            '<td>          .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6128>6128</a></td>\n' +
            '<td>                    SNDRV_CTL_ELEM_ACCESS_TLV_READ,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6129>6129</a></td>\n' +
            '<td>          ...</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6130>6130</a></td>\n' +
            '<td>          .tlv.p = db_scale_my_control,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6131>6131</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6132>6132</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6133>6133</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6134>6134</a></td>\n' +
            '<td>The DECLARE_TLV_DB_SCALE macro defines information about a mixer control where each step in the control' + "'" + 's value changes the dB value by a constant dB amount. The first parameter is the name of the variable to be defined. The second parameter is the minimum value, in units of 0.01 dB. The third parameter is the step size, in units of 0.01 dB. Set the fourth parameter to 1 if the minimum value actually mutes the control.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6135>6135</a></td>\n' +
            '<td>The DECLARE_TLV_DB_LINEAR macro defines information about a mixer control where the control' + "'" + 's value affects the output linearly. The first parameter is the name of the variable to be defined. The second parameter is the minimum value, in units of 0.01 dB. The third parameter is the maximum value, in units of 0.01 dB. If the minimum value mutes the control, set the second parameter to TLV_DB_GAIN_MUTE.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6136>6136</a></td>\n' +
            '<td>API for AC97 Codec</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6137>6137</a></td>\n' +
            '<td>General</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6138>6138</a></td>\n' +
            '<td>The ALSA AC97 codec layer is a well-defined one, and you don' + "'" + 't have to write much code to control it. Only low-level control routines are necessary. The AC97 codec API is defined in &lt;sound/ac97_codec.h&gt;.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6139>6139</a></td>\n' +
            '<td>Full Code Example</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6140>6140</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6141>6141</a></td>\n' +
            '<td>  struct mychip {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6142>6142</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6143>6143</a></td>\n' +
            '<td>          struct snd_ac97 *ac97;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6144>6144</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6145>6145</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6146>6146</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6147>6147</a></td>\n' +
            '<td>  static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6148>6148</a></td>\n' +
            '<td>                                             unsigned short reg)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6149>6149</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6150>6150</a></td>\n' +
            '<td>          struct mychip *chip = ac97-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6151>6151</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6152>6152</a></td>\n' +
            '<td>          /* read a register value here from the codec */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6153>6153</a></td>\n' +
            '<td>          return the_register_value;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6154>6154</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6155>6155</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6156>6156</a></td>\n' +
            '<td>  static void snd_mychip_ac97_write(struct snd_ac97 *ac97,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6157>6157</a></td>\n' +
            '<td>                                   unsigned short reg, unsigned short val)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6158>6158</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6159>6159</a></td>\n' +
            '<td>          struct mychip *chip = ac97-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6160>6160</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6161>6161</a></td>\n' +
            '<td>          /* write the given register value to the codec */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6162>6162</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6163>6163</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6164>6164</a></td>\n' +
            '<td>  static int snd_mychip_ac97(struct mychip *chip)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6165>6165</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6166>6166</a></td>\n' +
            '<td>          struct snd_ac97_bus *bus;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6167>6167</a></td>\n' +
            '<td>          struct snd_ac97_template ac97;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6168>6168</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6169>6169</a></td>\n' +
            '<td>          static struct snd_ac97_bus_ops ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6170>6170</a></td>\n' +
            '<td>                  .write = snd_mychip_ac97_write,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6171>6171</a></td>\n' +
            '<td>                  .read = snd_mychip_ac97_read,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6172>6172</a></td>\n' +
            '<td>          };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6173>6173</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6174>6174</a></td>\n' +
            '<td>          err = snd_ac97_bus(chip-&gt;card, 0, &amp;ops, NULL, &amp;bus);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6175>6175</a></td>\n' +
            '<td>          if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6176>6176</a></td>\n' +
            '<td>                  return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6177>6177</a></td>\n' +
            '<td>          memset(&amp;ac97, 0, sizeof(ac97));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6178>6178</a></td>\n' +
            '<td>          ac97.private_data = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6179>6179</a></td>\n' +
            '<td>          return snd_ac97_mixer(bus, &amp;ac97, &amp;chip-&gt;ac97);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6180>6180</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6181>6181</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6182>6182</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6183>6183</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6184>6184</a></td>\n' +
            '<td>Constructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6185>6185</a></td>\n' +
            '<td>To create an ac97 instance, first call snd_ac97_bus with an ac97_bus_ops_t record with callback functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6186>6186</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6187>6187</a></td>\n' +
            '<td>  struct snd_ac97_bus *bus;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6188>6188</a></td>\n' +
            '<td>  static struct snd_ac97_bus_ops ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6189>6189</a></td>\n' +
            '<td>        .write = snd_mychip_ac97_write,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6190>6190</a></td>\n' +
            '<td>        .read = snd_mychip_ac97_read,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6191>6191</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6192>6192</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6193>6193</a></td>\n' +
            '<td>  snd_ac97_bus(card, 0, &amp;ops, NULL, &amp;pbus);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6194>6194</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6195>6195</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6196>6196</a></td>\n' +
            '<td>The bus record is shared among all belonging ac97 instances.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6197>6197</a></td>\n' +
            '<td>And then call snd_ac97_mixer() with an struct snd_ac97_template record together with the bus pointer created above.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6198>6198</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6199>6199</a></td>\n' +
            '<td>  struct snd_ac97_template ac97;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6200>6200</a></td>\n' +
            '<td>  int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6201>6201</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6202>6202</a></td>\n' +
            '<td>  memset(&amp;ac97, 0, sizeof(ac97));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6203>6203</a></td>\n' +
            '<td>  ac97.private_data = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6204>6204</a></td>\n' +
            '<td>  snd_ac97_mixer(bus, &amp;ac97, &amp;chip-&gt;ac97);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6205>6205</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6206>6206</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6207>6207</a></td>\n' +
            '<td>where chip-&gt;ac97 is a pointer to a newly created ac97_t instance. In this case, the chip pointer is set as the private data, so that the read/write callback functions can refer to this chip instance. This instance is not necessarily stored in the chip record. If you need to change the register values from the driver, or need the suspend/resume of ac97 codecs, keep this pointer to pass to the corresponding functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6208>6208</a></td>\n' +
            '<td>Callbacks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6209>6209</a></td>\n' +
            '<td>The standard callbacks are read and write. Obviously they correspond to the functions for read and write accesses to the hardware low-level codes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6210>6210</a></td>\n' +
            '<td>The read callback returns the register value specified in the argument.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6211>6211</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6212>6212</a></td>\n' +
            '<td>  static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6213>6213</a></td>\n' +
            '<td>                                             unsigned short reg)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6214>6214</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6215>6215</a></td>\n' +
            '<td>          struct mychip *chip = ac97-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6216>6216</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6217>6217</a></td>\n' +
            '<td>          return the_register_value;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6218>6218</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6219>6219</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6220>6220</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6221>6221</a></td>\n' +
            '<td>Here, the chip can be cast from ac97-&gt;private_data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6222>6222</a></td>\n' +
            '<td>Meanwhile, the write callback is used to set the register value.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6223>6223</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6224>6224</a></td>\n' +
            '<td>  static void snd_mychip_ac97_write(struct snd_ac97 *ac97,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6225>6225</a></td>\n' +
            '<td>                       unsigned short reg, unsigned short val)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6226>6226</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6227>6227</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6228>6228</a></td>\n' +
            '<td>These callbacks are non-atomic like the control API callbacks.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6229>6229</a></td>\n' +
            '<td>There are also other callbacks: reset, wait and init.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6230>6230</a></td>\n' +
            '<td>The reset callback is used to reset the codec. If the chip requires a special kind of reset, you can define this callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6231>6231</a></td>\n' +
            '<td>The wait callback is used to add some waiting time in the standard initialization of the codec. If the chip requires the extra waiting time, define this callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6232>6232</a></td>\n' +
            '<td>The init callback is used for additional initialization of the codec.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6233>6233</a></td>\n' +
            '<td>Updating Registers in The Driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6234>6234</a></td>\n' +
            '<td>If you need to access to the codec from the driver, you can call the following functions: snd_ac97_write(), snd_ac97_read(), snd_ac97_update() and snd_ac97_update_bits().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6235>6235</a></td>\n' +
            '<td>Both snd_ac97_write() and snd_ac97_update() functions are used to set a value to the given register (AC97_XXX). The difference between them is that snd_ac97_update() doesn' + "'" + 't write a value if the given value has been already set, while snd_ac97_write() always rewrites the value.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6236>6236</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6237>6237</a></td>\n' +
            '<td>  snd_ac97_write(ac97, AC97_MASTER, 0x8080);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6238>6238</a></td>\n' +
            '<td>  snd_ac97_update(ac97, AC97_MASTER, 0x8080);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6239>6239</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6240>6240</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6241>6241</a></td>\n' +
            '<td>snd_ac97_read() is used to read the value of the given register. For example,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6242>6242</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6243>6243</a></td>\n' +
            '<td>  value = snd_ac97_read(ac97, AC97_MASTER);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6244>6244</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6245>6245</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6246>6246</a></td>\n' +
            '<td>snd_ac97_update_bits() is used to update some bits in the given register.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6247>6247</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6248>6248</a></td>\n' +
            '<td>  snd_ac97_update_bits(ac97, reg, mask, value);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6249>6249</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6250>6250</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6251>6251</a></td>\n' +
            '<td>Also, there is a function to change the sample rate (of a given register such as AC97_PCM_FRONT_DAC_RATE) when VRA or DRA is supported by the codec: snd_ac97_set_rate().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6252>6252</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6253>6253</a></td>\n' +
            '<td>  snd_ac97_set_rate(ac97, AC97_PCM_FRONT_DAC_RATE, 44100);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6254>6254</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6255>6255</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6256>6256</a></td>\n' +
            '<td>The following registers are available to set the rate: AC97_PCM_MIC_ADC_RATE, AC97_PCM_FRONT_DAC_RATE, AC97_PCM_LR_ADC_RATE, AC97_SPDIF. When AC97_SPDIF is specified, the register is not really changed but the corresponding IEC958 status bits will be updated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6257>6257</a></td>\n' +
            '<td>Clock Adjustment</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6258>6258</a></td>\n' +
            '<td>In some chips, the clock of the codec isn' + "'" + 't 48000 but using a PCI clock (to save a quartz!). In this case, change the field bus-&gt;clock to the corresponding value. For example, intel8x0 and es1968 drivers have their own function to read from the clock.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6259>6259</a></td>\n' +
            '<td>Proc Files</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6260>6260</a></td>\n' +
            '<td>The ALSA AC97 interface will create a proc file such as /proc/asound/card0/codec97#0/ac97#0-0 and ac97#0-0+regs. You can refer to these files to see the current status and registers of the codec.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6261>6261</a></td>\n' +
            '<td>Multiple Codecs</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6262>6262</a></td>\n' +
            '<td>When there are several codecs on the same card, you need to call snd_ac97_mixer() multiple times with ac97.num=1 or greater. The num field specifies the codec number.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6263>6263</a></td>\n' +
            '<td>If you set up multiple codecs, you either need to write different callbacks for each codec or check ac97-&gt;num in the callback routines.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6264>6264</a></td>\n' +
            '<td>MIDI (MPU401-UART) Interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6265>6265</a></td>\n' +
            '<td>General</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6266>6266</a></td>\n' +
            '<td>Many soundcards have built-in MIDI (MPU401-UART) interfaces. When the soundcard supports the standard MPU401-UART interface, most likely you can use the ALSA MPU401-UART API. The MPU401-UART API is defined in &lt;sound/mpu401.h&gt;.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6267>6267</a></td>\n' +
            '<td>Some soundchips have a similar but slightly different implementation of mpu401 stuff. For example, emu10k1 has its own mpu401 routines.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6268>6268</a></td>\n' +
            '<td>Constructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6269>6269</a></td>\n' +
            '<td>To create a rawmidi object, call snd_mpu401_uart_new().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6270>6270</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6271>6271</a></td>\n' +
            '<td>  struct snd_rawmidi *rmidi;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6272>6272</a></td>\n' +
            '<td>  snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401, port, info_flags,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6273>6273</a></td>\n' +
            '<td>                      irq, &amp;rmidi);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6274>6274</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6275>6275</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6276>6276</a></td>\n' +
            '<td>The first argument is the card pointer, and the second is the index of this component. You can create up to 8 rawmidi devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6277>6277</a></td>\n' +
            '<td>The third argument is the type of the hardware, MPU401_HW_XXX. If it' + "'" + 's not a special one, you can use MPU401_HW_MPU401.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6278>6278</a></td>\n' +
            '<td>The 4th argument is the I/O port address. Many backward-compatible MPU401 have an I/O port such as 0x330. Or, it might be a part of its own PCI I/O region. It depends on the chip design.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6279>6279</a></td>\n' +
            '<td>The 5th argument is a bitflag for additional information. When the I/O port address above is part of the PCI I/O region, the MPU401 I/O port might have been already allocated (reserved) by the driver itself. In such a case, pass a bit flag MPU401_INFO_INTEGRATED, and the mpu401-uart layer will allocate the I/O ports by itself.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6280>6280</a></td>\n' +
            '<td>When the controller supports only the input or output MIDI stream, pass the MPU401_INFO_INPUT or MPU401_INFO_OUTPUT bitflag, respectively. Then the rawmidi instance is created as a single stream.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6281>6281</a></td>\n' +
            '<td>MPU401_INFO_MMIO bitflag is used to change the access method to MMIO (via readb and writeb) instead of iob and outb. In this case, you have to pass the iomapped address to snd_mpu401_uart_new().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6282>6282</a></td>\n' +
            '<td>When MPU401_INFO_TX_IRQ is set, the output stream isn' + "'" + 't checked in the default interrupt handler. The driver needs to call snd_mpu401_uart_interrupt_tx() by itself to start processing the output stream in the irq handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6283>6283</a></td>\n' +
            '<td>If the MPU-401 interface shares its interrupt with the other logical devices on the card, set MPU401_INFO_IRQ_HOOK (see below).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6284>6284</a></td>\n' +
            '<td>Usually, the port address corresponds to the command port and port + 1 corresponds to the data port. If not, you may change the cport field of struct snd_mpu401 manually afterward. However, snd_mpu401 pointer is not returned explicitly by snd_mpu401_uart_new(). You need to cast rmidi-&gt;private_data to snd_mpu401 explicitly,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6285>6285</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6286>6286</a></td>\n' +
            '<td>  struct snd_mpu401 *mpu;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6287>6287</a></td>\n' +
            '<td>  mpu = rmidi-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6288>6288</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6289>6289</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6290>6290</a></td>\n' +
            '<td>and reset the cport as you like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6291>6291</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6292>6292</a></td>\n' +
            '<td>  mpu-&gt;cport = my_own_control_port;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6293>6293</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6294>6294</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6295>6295</a></td>\n' +
            '<td>The 6th argument specifies the ISA irq number that will be allocated. If no interrupt is to be allocated (because your code is already allocating a shared interrupt, or because the device does not use interrupts), pass -1 instead. For a MPU-401 device without an interrupt, a polling timer will be used instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6296>6296</a></td>\n' +
            '<td>Interrupt Handler</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6297>6297</a></td>\n' +
            '<td>When the interrupt is allocated in snd_mpu401_uart_new(), an exclusive ISA interrupt handler is automatically used, hence you don' + "'" + 't have anything else to do than creating the mpu401 stuff. Otherwise, you have to set MPU401_INFO_IRQ_HOOK, and call snd_mpu401_uart_interrupt() explicitly from your own interrupt handler when it has determined that a UART interrupt has occurred.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6298>6298</a></td>\n' +
            '<td>In this case, you need to pass the private_data of the returned rawmidi object from snd_mpu401_uart_new() as the second argument of snd_mpu401_uart_interrupt().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6299>6299</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6300>6300</a></td>\n' +
            '<td>  snd_mpu401_uart_interrupt(irq, rmidi-&gt;private_data, regs);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6301>6301</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6302>6302</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6303>6303</a></td>\n' +
            '<td>RawMIDI Interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6304>6304</a></td>\n' +
            '<td>Overview</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6305>6305</a></td>\n' +
            '<td>The raw MIDI interface is used for hardware MIDI ports that can be accessed as a byte stream. It is not used for synthesizer chips that do not directly understand MIDI.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6306>6306</a></td>\n' +
            '<td>ALSA handles file and buffer management. All you have to do is to write some code to move data between the buffer and the hardware.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6307>6307</a></td>\n' +
            '<td>The rawmidi API is defined in &lt;sound/rawmidi.h&gt;.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6308>6308</a></td>\n' +
            '<td>Constructor</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6309>6309</a></td>\n' +
            '<td>To create a rawmidi device, call the snd_rawmidi_new function:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6310>6310</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6311>6311</a></td>\n' +
            '<td>  struct snd_rawmidi *rmidi;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6312>6312</a></td>\n' +
            '<td>  err = snd_rawmidi_new(chip-&gt;card, "MyMIDI", 0, outs, ins, &amp;rmidi);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6313>6313</a></td>\n' +
            '<td>  if (err &lt; 0)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6314>6314</a></td>\n' +
            '<td>          return err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6315>6315</a></td>\n' +
            '<td>  rmidi-&gt;private_data = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6316>6316</a></td>\n' +
            '<td>  strcpy(rmidi-&gt;name, "My MIDI");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6317>6317</a></td>\n' +
            '<td>  rmidi-&gt;info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6318>6318</a></td>\n' +
            '<td>                      SNDRV_RAWMIDI_INFO_INPUT |</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6319>6319</a></td>\n' +
            '<td>                      SNDRV_RAWMIDI_INFO_DUPLEX;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6320>6320</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6321>6321</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6322>6322</a></td>\n' +
            '<td>The first argument is the card pointer, the second argument is the ID string.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6323>6323</a></td>\n' +
            '<td>The third argument is the index of this component. You can create up to 8 rawmidi devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6324>6324</a></td>\n' +
            '<td>The fourth and fifth arguments are the number of output and input substreams, respectively, of this device (a substream is the equivalent of a MIDI port).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6325>6325</a></td>\n' +
            '<td>Set the info_flags field to specify the capabilities of the device. Set SNDRV_RAWMIDI_INFO_OUTPUT if there is at least one output port, SNDRV_RAWMIDI_INFO_INPUT if there is at least one input port, and SNDRV_RAWMIDI_INFO_DUPLEX if the device can handle output and input at the same time.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6326>6326</a></td>\n' +
            '<td>After the rawmidi device is created, you need to set the operators (callbacks) for each substream. There are helper functions to set the operators for all the substreams of a device:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6327>6327</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6328>6328</a></td>\n' +
            '<td>  snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &amp;snd_mymidi_output_ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6329>6329</a></td>\n' +
            '<td>  snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &amp;snd_mymidi_input_ops);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6330>6330</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6331>6331</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6332>6332</a></td>\n' +
            '<td>The operators are usually defined like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6333>6333</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6334>6334</a></td>\n' +
            '<td>  static struct snd_rawmidi_ops snd_mymidi_output_ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6335>6335</a></td>\n' +
            '<td>          .open =    snd_mymidi_output_open,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6336>6336</a></td>\n' +
            '<td>          .close =   snd_mymidi_output_close,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6337>6337</a></td>\n' +
            '<td>          .trigger = snd_mymidi_output_trigger,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6338>6338</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6339>6339</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6340>6340</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6341>6341</a></td>\n' +
            '<td>These callbacks are explained in the Callbacks section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6342>6342</a></td>\n' +
            '<td>If there are more than one substream, you should give a unique name to each of them:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6343>6343</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6344>6344</a></td>\n' +
            '<td>  struct snd_rawmidi_substream *substream;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6345>6345</a></td>\n' +
            '<td>  list_for_each_entry(substream,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6346>6346</a></td>\n' +
            '<td>                      &amp;rmidi-&gt;streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6347>6347</a></td>\n' +
            '<td>                      list {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6348>6348</a></td>\n' +
            '<td>          sprintf(substream-&gt;name, "My MIDI Port %d", substream-&gt;number + 1);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6349>6349</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6350>6350</a></td>\n' +
            '<td>  /* same for SNDRV_RAWMIDI_STREAM_INPUT */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6351>6351</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6352>6352</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6353>6353</a></td>\n' +
            '<td>Callbacks</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6354>6354</a></td>\n' +
            '<td>In all the callbacks, the private data that you' + "'" + 've set for the rawmidi device can be accessed as substream-&gt;rmidi-&gt;private_data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6355>6355</a></td>\n' +
            '<td>If there is more than one port, your callbacks can determine the port index from the struct snd_rawmidi_substream data passed to each callback:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6356>6356</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6357>6357</a></td>\n' +
            '<td>  struct snd_rawmidi_substream *substream;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6358>6358</a></td>\n' +
            '<td>  int index = substream-&gt;number;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6359>6359</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6360>6360</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6361>6361</a></td>\n' +
            '<td>open callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6362>6362</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6363>6363</a></td>\n' +
            '<td>  static int snd_xxx_open(struct snd_rawmidi_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6364>6364</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6365>6365</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6366>6366</a></td>\n' +
            '<td>This is called when a substream is opened. You can initialize the hardware here, but you shouldn' + "'" + 't start transmitting/receiving data yet.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6367>6367</a></td>\n' +
            '<td>close callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6368>6368</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6369>6369</a></td>\n' +
            '<td>  static int snd_xxx_close(struct snd_rawmidi_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6370>6370</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6371>6371</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6372>6372</a></td>\n' +
            '<td>Guess what.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6373>6373</a></td>\n' +
            '<td>The open and close callbacks of a rawmidi device are serialized with a mutex, and can sleep.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6374>6374</a></td>\n' +
            '<td>trigger callback for output substreams</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6375>6375</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6376>6376</a></td>\n' +
            '<td>  static void snd_xxx_output_trigger(struct snd_rawmidi_substream *substream, int up);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6377>6377</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6378>6378</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6379>6379</a></td>\n' +
            '<td>This is called with a nonzero up parameter when there is some data in the substream buffer that must be transmitted.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6380>6380</a></td>\n' +
            '<td>To read data from the buffer, call snd_rawmidi_transmit_peek. It will return the number of bytes that have been read; this will be less than the number of bytes requested when there are no more data in the buffer. After the data have been transmitted successfully, call snd_rawmidi_transmit_ack to remove the data from the substream buffer:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6381>6381</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6382>6382</a></td>\n' +
            '<td>  unsigned char data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6383>6383</a></td>\n' +
            '<td>  while (snd_rawmidi_transmit_peek(substream, &amp;data, 1) == 1) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6384>6384</a></td>\n' +
            '<td>          if (snd_mychip_try_to_transmit(data))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6385>6385</a></td>\n' +
            '<td>                  snd_rawmidi_transmit_ack(substream, 1);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6386>6386</a></td>\n' +
            '<td>          else</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6387>6387</a></td>\n' +
            '<td>                  break; /* hardware FIFO full */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6388>6388</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6389>6389</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6390>6390</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6391>6391</a></td>\n' +
            '<td>If you know beforehand that the hardware will accept data, you can use the snd_rawmidi_transmit function which reads some data and removes them from the buffer at once:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6392>6392</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6393>6393</a></td>\n' +
            '<td>  while (snd_mychip_transmit_possible()) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6394>6394</a></td>\n' +
            '<td>          unsigned char data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6395>6395</a></td>\n' +
            '<td>          if (snd_rawmidi_transmit(substream, &amp;data, 1) != 1)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6396>6396</a></td>\n' +
            '<td>                  break; /* no more data */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6397>6397</a></td>\n' +
            '<td>          snd_mychip_transmit(data);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6398>6398</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6399>6399</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6400>6400</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6401>6401</a></td>\n' +
            '<td>If you know beforehand how many bytes you can accept, you can use a buffer size greater than one with the snd_rawmidi_transmit* functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6402>6402</a></td>\n' +
            '<td>The trigger callback must not sleep. If the hardware FIFO is full before the substream buffer has been emptied, you have to continue transmitting data later, either in an interrupt handler, or with a timer if the hardware doesn' + "'" + 't have a MIDI transmit interrupt.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6403>6403</a></td>\n' +
            '<td>The trigger callback is called with a zero up parameter when the transmission of data should be aborted.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6404>6404</a></td>\n' +
            '<td>trigger callback for input substreams</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6405>6405</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6406>6406</a></td>\n' +
            '<td>  static void snd_xxx_input_trigger(struct snd_rawmidi_substream *substream, int up);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6407>6407</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6408>6408</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6409>6409</a></td>\n' +
            '<td>This is called with a nonzero up parameter to enable receiving data, or with a zero up parameter do disable receiving data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6410>6410</a></td>\n' +
            '<td>The trigger callback must not sleep; the actual reading of data from the device is usually done in an interrupt handler.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6411>6411</a></td>\n' +
            '<td>When data reception is enabled, your interrupt handler should call snd_rawmidi_receive for all received data:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6412>6412</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6413>6413</a></td>\n' +
            '<td>  void snd_mychip_midi_interrupt(...)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6414>6414</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6415>6415</a></td>\n' +
            '<td>          while (mychip_midi_available()) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6416>6416</a></td>\n' +
            '<td>                  unsigned char data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6417>6417</a></td>\n' +
            '<td>                  data = mychip_midi_read();</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6418>6418</a></td>\n' +
            '<td>                  snd_rawmidi_receive(substream, &amp;data, 1);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6419>6419</a></td>\n' +
            '<td>          }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6420>6420</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6421>6421</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6422>6422</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6423>6423</a></td>\n' +
            '<td>drain callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6424>6424</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6425>6425</a></td>\n' +
            '<td>  static void snd_xxx_drain(struct snd_rawmidi_substream *substream);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6426>6426</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6427>6427</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6428>6428</a></td>\n' +
            '<td>This is only used with output substreams. This function should wait until all data read from the substream buffer have been transmitted. This ensures that the device can be closed and the driver unloaded without losing data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6429>6429</a></td>\n' +
            '<td>This callback is optional. If you do not set drain in the struct snd_rawmidi_ops structure, ALSA will simply wait for 50 milliseconds instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6430>6430</a></td>\n' +
            '<td>Miscellaneous Devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6431>6431</a></td>\n' +
            '<td>FM OPL3</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6432>6432</a></td>\n' +
            '<td>The FM OPL3 is still used in many chips (mainly for backward compatibility). ALSA has a nice OPL3 FM control layer, too. The OPL3 API is defined in &lt;sound/opl3.h&gt;.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6433>6433</a></td>\n' +
            '<td>FM registers can be directly accessed through the direct-FM API, defined in &lt;sound/asound_fm.h&gt;. In ALSA native mode, FM registers are accessed through the Hardware-Dependent Device direct-FM extension API, whereas in OSS compatible mode, FM registers can be accessed with the OSS direct-FM compatible API in /dev/dmfmX device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6434>6434</a></td>\n' +
            '<td>To create the OPL3 component, you have two functions to call. The first one is a constructor for the opl3_t instance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6435>6435</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6436>6436</a></td>\n' +
            '<td>  struct snd_opl3 *opl3;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6437>6437</a></td>\n' +
            '<td>  snd_opl3_create(card, lport, rport, OPL3_HW_OPL3_XXX,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6438>6438</a></td>\n' +
            '<td>                  integrated, &amp;opl3);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6439>6439</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6440>6440</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6441>6441</a></td>\n' +
            '<td>The first argument is the card pointer, the second one is the left port address, and the third is the right port address. In most cases, the right port is placed at the left port + 2.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6442>6442</a></td>\n' +
            '<td>The fourth argument is the hardware type.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6443>6443</a></td>\n' +
            '<td>When the left and right ports have been already allocated by the card driver, pass non-zero to the fifth argument (integrated). Otherwise, the opl3 module will allocate the specified ports by itself.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6444>6444</a></td>\n' +
            '<td>When the accessing the hardware requires special method instead of the standard I/O access, you can create opl3 instance separately with snd_opl3_new().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6445>6445</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6446>6446</a></td>\n' +
            '<td>  struct snd_opl3 *opl3;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6447>6447</a></td>\n' +
            '<td>  snd_opl3_new(card, OPL3_HW_OPL3_XXX, &amp;opl3);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6448>6448</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6449>6449</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6450>6450</a></td>\n' +
            '<td>Then set command, private_data and private_free for the private access function, the private data and the destructor. The l_port and r_port are not necessarily set. Only the command must be set properly. You can retrieve the data from the opl3-&gt;private_data field.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6451>6451</a></td>\n' +
            '<td>After creating the opl3 instance via snd_opl3_new(), call snd_opl3_init() to initialize the chip to the proper state. Note that snd_opl3_create() always calls it internally.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6452>6452</a></td>\n' +
            '<td>If the opl3 instance is created successfully, then create a hwdep device for this opl3.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6453>6453</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6454>6454</a></td>\n' +
            '<td>  struct snd_hwdep *opl3hwdep;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6455>6455</a></td>\n' +
            '<td>  snd_opl3_hwdep_new(opl3, 0, 1, &amp;opl3hwdep);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6456>6456</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6457>6457</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6458>6458</a></td>\n' +
            '<td>The first argument is the opl3_t instance you created, and the second is the index number, usually 0.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6459>6459</a></td>\n' +
            '<td>The third argument is the index-offset for the sequencer client assigned to the OPL3 port. When there is an MPU401-UART, give 1 for here (UART always takes 0).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6460>6460</a></td>\n' +
            '<td>Hardware-Dependent Devices</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6461>6461</a></td>\n' +
            '<td>Some chips need user-space access for special controls or for loading the micro code. In such a case, you can create a hwdep (hardware-dependent) device. The hwdep API is defined in &lt;sound/hwdep.h&gt;. You can find examples in opl3 driver or isa/sb/sb16_csp.c.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6462>6462</a></td>\n' +
            '<td>The creation of the hwdep instance is done via snd_hwdep_new().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6463>6463</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6464>6464</a></td>\n' +
            '<td>  struct snd_hwdep *hw;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6465>6465</a></td>\n' +
            '<td>  snd_hwdep_new(card, "My HWDEP", 0, &amp;hw);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6466>6466</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6467>6467</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6468>6468</a></td>\n' +
            '<td>where the third argument is the index number.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6469>6469</a></td>\n' +
            '<td>You can then pass any pointer value to the private_data. If you assign a private data, you should define the destructor, too. The destructor function is set in the private_free field.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6470>6470</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6471>6471</a></td>\n' +
            '<td>  struct mydata *p = kmalloc(sizeof(*p), GFP_KERNEL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6472>6472</a></td>\n' +
            '<td>  hw-&gt;private_data = p;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6473>6473</a></td>\n' +
            '<td>  hw-&gt;private_free = mydata_free;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6474>6474</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6475>6475</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6476>6476</a></td>\n' +
            '<td>and the implementation of the destructor would be:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6477>6477</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6478>6478</a></td>\n' +
            '<td>  static void mydata_free(struct snd_hwdep *hw)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6479>6479</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6480>6480</a></td>\n' +
            '<td>          struct mydata *p = hw-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6481>6481</a></td>\n' +
            '<td>          kfree(p);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6482>6482</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6483>6483</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6484>6484</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6485>6485</a></td>\n' +
            '<td>The arbitrary file operations can be defined for this instance. The file operators are defined in the ops table. For example, assume that this chip needs an ioctl.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6486>6486</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6487>6487</a></td>\n' +
            '<td>  hw-&gt;ops.open = mydata_open;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6488>6488</a></td>\n' +
            '<td>  hw-&gt;ops.ioctl = mydata_ioctl;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6489>6489</a></td>\n' +
            '<td>  hw-&gt;ops.release = mydata_release;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6490>6490</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6491>6491</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6492>6492</a></td>\n' +
            '<td>And implement the callback functions as you like.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6493>6493</a></td>\n' +
            '<td>IEC958 (S/PDIF)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6494>6494</a></td>\n' +
            '<td>Usually the controls for IEC958 devices are implemented via the control interface. There is a macro to compose a name string for IEC958 controls, SNDRV_CTL_NAME_IEC958() defined in &lt;include/asound.h&gt;.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6495>6495</a></td>\n' +
            '<td>There are some standard controls for IEC958 status bits. These controls use the type SNDRV_CTL_ELEM_TYPE_IEC958, and the size of element is fixed as 4 bytes array (value.iec958.status[x]). For the info callback, you don' + "'" + 't specify the value field for this type (the count field must be set, though).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6496>6496</a></td>\n' +
            '<td>IEC958 Playback Con Mask is used to return the bit-mask for the IEC958 status bits of consumer mode. Similarly, IEC958 Playback Pro Mask returns the bitmask for professional mode. They are read-only controls, and are defined as MIXER controls (iface = SNDRV_CTL_ELEM_IFACE_MIXER).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6497>6497</a></td>\n' +
            '<td>Meanwhile, IEC958 Playback Default control is defined for getting and setting the current default IEC958 bits. Note that this one is usually defined as a PCM control (iface = SNDRV_CTL_ELEM_IFACE_PCM), although in some places it' + "'" + 's defined as a MIXER control.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6498>6498</a></td>\n' +
            '<td>In addition, you can define the control switches to enable/disable or to set the raw bit mode. The implementation will depend on the chip, but the control should be named as IEC958 xxx, preferably using the SNDRV_CTL_NAME_IEC958() macro.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6499>6499</a></td>\n' +
            '<td>You can find several cases, for example, pci/emu10k1, pci/ice1712, or pci/cmipci.c.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6500>6500</a></td>\n' +
            '<td>Buffer and Memory Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6501>6501</a></td>\n' +
            '<td>Buffer Types</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6502>6502</a></td>\n' +
            '<td>ALSA provides several different buffer allocation functions depending on the bus and the architecture. All these have a consistent API. The allocation of physically-contiguous pages is done via snd_malloc_xxx_pages() function, where xxx is the bus type.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6503>6503</a></td>\n' +
            '<td>The allocation of pages with fallback is snd_malloc_xxx_pages_fallback(). This function tries to allocate the specified pages but if the pages are not available, it tries to reduce the page sizes until enough space is found.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6504>6504</a></td>\n' +
            '<td>The release the pages, call snd_free_xxx_pages() function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6505>6505</a></td>\n' +
            '<td>Usually, ALSA drivers try to allocate and reserve a large contiguous physical space at the time the module is loaded for the later use. This is called pre-allocation. As already written, you can call the following function at pcm instance construction time (in the case of PCI bus).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6506>6506</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6507>6507</a></td>\n' +
            '<td>  snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6508>6508</a></td>\n' +
            '<td>                                        snd_dma_pci_data(pci), size, max);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6509>6509</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6510>6510</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6511>6511</a></td>\n' +
            '<td>where size is the byte size to be pre-allocated and the max is the maximum size to be changed via the prealloc proc file. The allocator will try to get an area as large as possible within the given size.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6512>6512</a></td>\n' +
            '<td>The second argument (type) and the third argument (device pointer) are dependent on the bus. In the case of the ISA bus, pass snd_dma_isa_data() as the third argument with SNDRV_DMA_TYPE_DEV type. For the continuous buffer unrelated to the bus can be pre-allocated with SNDRV_DMA_TYPE_CONTINUOUS type and the snd_dma_continuous_data(GFP_KERNEL) device pointer, where GFP_KERNEL is the kernel allocation flag to use. For the PCI scatter-gather buffers, use SNDRV_DMA_TYPE_DEV_SG with snd_dma_pci_data(pci) (see the Non-Contiguous Buffers section).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6513>6513</a></td>\n' +
            '<td>Once the buffer is pre-allocated, you can use the allocator in the hw_params callback:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6514>6514</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6515>6515</a></td>\n' +
            '<td>  snd_pcm_lib_malloc_pages(substream, size);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6516>6516</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6517>6517</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6518>6518</a></td>\n' +
            '<td>Note that you have to pre-allocate to use this function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6519>6519</a></td>\n' +
            '<td>External Hardware Buffers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6520>6520</a></td>\n' +
            '<td>Some chips have their own hardware buffers and the DMA transfer from the host memory is not available. In such a case, you need to either 1) copy/set the audio data directly to the external hardware buffer, or 2) make an intermediate buffer and copy/set the data from it to the external hardware buffer in interrupts (or in tasklets, preferably).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6521>6521</a></td>\n' +
            '<td>The first case works fine if the external hardware buffer is large enough. This method doesn' + "'" + 't need any extra buffers and thus is more effective. You need to define the copy and silence callbacks for the data transfer. However, there is a drawback: it cannot be mmapped. The examples are GUS' + "'" + 's GF1 PCM or emu8000' + "'" + 's wavetable PCM.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6522>6522</a></td>\n' +
            '<td>The second case allows for mmap on the buffer, although you have to handle an interrupt or a tasklet to transfer the data from the intermediate buffer to the hardware buffer. You can find an example in the vxpocket driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6523>6523</a></td>\n' +
            '<td>Another case is when the chip uses a PCI memory-map region for the buffer instead of the host memory. In this case, mmap is available only on certain architectures like the Intel one. In non-mmap mode, the data cannot be transferred as in the normal way. Thus you need to define the copy and silence callbacks as well, as in the cases above. The examples are found in rme32.c and rme96.c.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6524>6524</a></td>\n' +
            '<td>The implementation of the copy and silence callbacks depends upon whether the hardware supports interleaved or non-interleaved samples. The copy callback is defined like below, a bit differently depending whether the direction is playback or capture:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6525>6525</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6526>6526</a></td>\n' +
            '<td>  static int playback_copy(struct snd_pcm_substream *substream, int channel,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6527>6527</a></td>\n' +
            '<td>               snd_pcm_uframes_t pos, void *src, snd_pcm_uframes_t count);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6528>6528</a></td>\n' +
            '<td>  static int capture_copy(struct snd_pcm_substream *substream, int channel,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6529>6529</a></td>\n' +
            '<td>               snd_pcm_uframes_t pos, void *dst, snd_pcm_uframes_t count);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6530>6530</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6531>6531</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6532>6532</a></td>\n' +
            '<td>In the case of interleaved samples, the second argument (channel) is not used. The third argument (pos) points the current position offset in frames.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6533>6533</a></td>\n' +
            '<td>The meaning of the fourth argument is different between playback and capture. For playback, it holds the source data pointer, and for capture, it' + "'" + 's the destination data pointer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6534>6534</a></td>\n' +
            '<td>The last argument is the number of frames to be copied.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6535>6535</a></td>\n' +
            '<td>What you have to do in this callback is again different between playback and capture directions. In the playback case, you copy the given amount of data (count) at the specified pointer (src) to the specified offset (pos) on the hardware buffer. When coded like memcpy-like way, the copy would be like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6536>6536</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6537>6537</a></td>\n' +
            '<td>  my_memcpy(my_buffer + frames_to_bytes(runtime, pos), src,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6538>6538</a></td>\n' +
            '<td>            frames_to_bytes(runtime, count));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6539>6539</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6540>6540</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6541>6541</a></td>\n' +
            '<td>For the capture direction, you copy the given amount of data (count) at the specified offset (pos) on the hardware buffer to the specified pointer (dst).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6542>6542</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6543>6543</a></td>\n' +
            '<td>  my_memcpy(dst, my_buffer + frames_to_bytes(runtime, pos),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6544>6544</a></td>\n' +
            '<td>            frames_to_bytes(runtime, count));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6545>6545</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6546>6546</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6547>6547</a></td>\n' +
            '<td>Note that both the position and the amount of data are given in frames.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6548>6548</a></td>\n' +
            '<td>In the case of non-interleaved samples, the implementation will be a bit more complicated.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6549>6549</a></td>\n' +
            '<td>You need to check the channel argument, and if it' + "'" + 's -1, copy the whole channels. Otherwise, you have to copy only the specified channel. Please check isa/gus/gus_pcm.c as an example.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6550>6550</a></td>\n' +
            '<td>The silence callback is also implemented in a similar way.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6551>6551</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6552>6552</a></td>\n' +
            '<td>  static int silence(struct snd_pcm_substream *substream, int channel,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6553>6553</a></td>\n' +
            '<td>                     snd_pcm_uframes_t pos, snd_pcm_uframes_t count);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6554>6554</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6555>6555</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6556>6556</a></td>\n' +
            '<td>The meanings of arguments are the same as in the copy callback, although there is no src/dst argument. In the case of interleaved samples, the channel argument has no meaning, as well as on copy callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6557>6557</a></td>\n' +
            '<td>The role of silence callback is to set the given amount (count) of silence data at the specified offset (pos) on the hardware buffer. Suppose that the data format is signed (that is, the silent-data is 0), and the implementation using a memset-like function would be like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6558>6558</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6559>6559</a></td>\n' +
            '<td>  my_memcpy(my_buffer + frames_to_bytes(runtime, pos), 0,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6560>6560</a></td>\n' +
            '<td>            frames_to_bytes(runtime, count));</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6561>6561</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6562>6562</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6563>6563</a></td>\n' +
            '<td>In the case of non-interleaved samples, again, the implementation becomes a bit more complicated. See, for example, isa/gus/gus_pcm.c.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6564>6564</a></td>\n' +
            '<td>Non-Contiguous Buffers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6565>6565</a></td>\n' +
            '<td>If your hardware supports the page table as in emu10k1 or the buffer descriptors as in via82xx, you can use the scatter-gather (SG) DMA. ALSA provides an interface for handling SG-buffers. The API is provided in &lt;sound/pcm.h&gt;.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6566>6566</a></td>\n' +
            '<td>For creating the SG-buffer handler, call snd_pcm_lib_preallocate_pages() or snd_pcm_lib_preallocate_pages_for_all() with SNDRV_DMA_TYPE_DEV_SG in the PCM constructor like other PCI pre-allocator. You need to pass snd_dma_pci_data(pci), where pci is the struct pci_dev pointer of the chip as well. The struct snd_sg_buf instance is created as substream-&gt;dma_private. You can cast the pointer like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6567>6567</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6568>6568</a></td>\n' +
            '<td>  struct snd_sg_buf *sgbuf = (struct snd_sg_buf *)substream-&gt;dma_private;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6569>6569</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6570>6570</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6571>6571</a></td>\n' +
            '<td>Then call snd_pcm_lib_malloc_pages() in the hw_params callback as well as in the case of normal PCI buffer. The SG-buffer handler will allocate the non-contiguous kernel pages of the given size and map them onto the virtually contiguous memory. The virtual pointer is addressed in runtime-&gt;dma_area. The physical address (runtime-&gt;dma_addr) is set to zero, because the buffer is physically non-contiguous. The physical address table is set up in sgbuf-&gt;table. You can get the physical address at a certain offset via snd_pcm_sgbuf_get_addr().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6572>6572</a></td>\n' +
            '<td>When a SG-handler is used, you need to set snd_pcm_sgbuf_ops_page as the page callback. (See page callback section.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6573>6573</a></td>\n' +
            '<td>To release the data, call snd_pcm_lib_free_pages() in the hw_free callback as usual.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6574>6574</a></td>\n' +
            '<td>Vmalloc' + "'" + 'ed Buffers</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6575>6575</a></td>\n' +
            '<td>It' + "'" + 's possible to use a buffer allocated via vmalloc, for example, for an intermediate buffer. Since the allocated pages are not contiguous, you need to set the page callback to obtain the physical address at every offset.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6576>6576</a></td>\n' +
            '<td>The implementation of page callback would be like this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6577>6577</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6578>6578</a></td>\n' +
            '<td>  #include &lt;linux/vmalloc.h&gt;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6579>6579</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6580>6580</a></td>\n' +
            '<td>  /* get the physical page pointer on the given offset */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6581>6581</a></td>\n' +
            '<td>  static struct page *mychip_page(struct snd_pcm_substream *substream,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6582>6582</a></td>\n' +
            '<td>                                  unsigned long offset)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6583>6583</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6584>6584</a></td>\n' +
            '<td>          void *pageptr = substream-&gt;runtime-&gt;dma_area + offset;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6585>6585</a></td>\n' +
            '<td>          return vmalloc_to_page(pageptr);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6586>6586</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6587>6587</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6588>6588</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6589>6589</a></td>\n' +
            '<td>Proc Interface</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6590>6590</a></td>\n' +
            '<td>ALSA provides an easy interface for procfs. The proc files are very useful for debugging. I recommend you set up proc files if you write a driver and want to get a running status or register dumps. The API is found in &lt;sound/info.h&gt;.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6591>6591</a></td>\n' +
            '<td>To create a proc file, call snd_card_proc_new().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6592>6592</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6593>6593</a></td>\n' +
            '<td>  struct snd_info_entry *entry;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6594>6594</a></td>\n' +
            '<td>  int err = snd_card_proc_new(card, "my-file", &amp;entry);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6595>6595</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6596>6596</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6597>6597</a></td>\n' +
            '<td>where the second argument specifies the name of the proc file to be created. The above example will create a file my-file under the card directory, e.g. /proc/asound/card0/my-file.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6598>6598</a></td>\n' +
            '<td>Like other components, the proc entry created via snd_card_proc_new() will be registered and released automatically in the card registration and release functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6599>6599</a></td>\n' +
            '<td>When the creation is successful, the function stores a new instance in the pointer given in the third argument. It is initialized as a text proc file for read only. To use this proc file as a read-only text file as it is, set the read callback with a private data via snd_info_set_text_ops().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6600>6600</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6601>6601</a></td>\n' +
            '<td>  snd_info_set_text_ops(entry, chip, my_proc_read);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6602>6602</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6603>6603</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6604>6604</a></td>\n' +
            '<td>where the second argument (chip) is the private data to be used in the callbacks. The third parameter specifies the read buffer size and the fourth (my_proc_read) is the callback function, which is defined like</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6605>6605</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6606>6606</a></td>\n' +
            '<td>  static void my_proc_read(struct snd_info_entry *entry,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6607>6607</a></td>\n' +
            '<td>                           struct snd_info_buffer *buffer);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6608>6608</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6609>6609</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6610>6610</a></td>\n' +
            '<td>In the read callback, use snd_iprintf() for output strings, which works just like normal printf(). For example,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6611>6611</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6612>6612</a></td>\n' +
            '<td>  static void my_proc_read(struct snd_info_entry *entry,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6613>6613</a></td>\n' +
            '<td>                           struct snd_info_buffer *buffer)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6614>6614</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6615>6615</a></td>\n' +
            '<td>          struct my_chip *chip = entry-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6616>6616</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6617>6617</a></td>\n' +
            '<td>          snd_iprintf(buffer, "This is my chip!\\n");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6618>6618</a></td>\n' +
            '<td>          snd_iprintf(buffer, "Port = %ld\\n", chip-&gt;port);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6619>6619</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6620>6620</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6621>6621</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6622>6622</a></td>\n' +
            '<td>The file permissions can be changed afterwards. As default, it' + "'" + 's set as read only for all users. If you want to add write permission for the user (root as default), do as follows:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6623>6623</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6624>6624</a></td>\n' +
            '<td> entry-&gt;mode = S_IFREG | S_IRUGO | S_IWUSR;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6625>6625</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6626>6626</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6627>6627</a></td>\n' +
            '<td>and set the write buffer size and the callback</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6628>6628</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6629>6629</a></td>\n' +
            '<td>  entry-&gt;c.text.write = my_proc_write;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6630>6630</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6631>6631</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6632>6632</a></td>\n' +
            '<td>For the write callback, you can use snd_info_get_line() to get a text line, and snd_info_get_str() to retrieve a string from the line. Some examples are found in core/oss/mixer_oss.c, core/oss/and pcm_oss.c.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6633>6633</a></td>\n' +
            '<td>For a raw-data proc-file, set the attributes as follows:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6634>6634</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6635>6635</a></td>\n' +
            '<td>  static struct snd_info_entry_ops my_file_io_ops = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6636>6636</a></td>\n' +
            '<td>          .read = my_file_io_read,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6637>6637</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6638>6638</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6639>6639</a></td>\n' +
            '<td>  entry-&gt;content = SNDRV_INFO_CONTENT_DATA;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6640>6640</a></td>\n' +
            '<td>  entry-&gt;private_data = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6641>6641</a></td>\n' +
            '<td>  entry-&gt;c.ops = &amp;my_file_io_ops;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6642>6642</a></td>\n' +
            '<td>  entry-&gt;size = 4096;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6643>6643</a></td>\n' +
            '<td>  entry-&gt;mode = S_IFREG | S_IRUGO;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6644>6644</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6645>6645</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6646>6646</a></td>\n' +
            '<td>For the raw data, size field must be set properly. This specifies the maximum size of the proc file access.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6647>6647</a></td>\n' +
            '<td>The read/write callbacks of raw mode are more direct than the text mode. You need to use a low-level I/O functions such as copy_from/to_user() to transfer the data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6648>6648</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6649>6649</a></td>\n' +
            '<td>  static ssize_t my_file_io_read(struct snd_info_entry *entry,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6650>6650</a></td>\n' +
            '<td>                              void *file_private_data,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6651>6651</a></td>\n' +
            '<td>                              struct file *file,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6652>6652</a></td>\n' +
            '<td>                              char *buf,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6653>6653</a></td>\n' +
            '<td>                              size_t count,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6654>6654</a></td>\n' +
            '<td>                              loff_t pos)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6655>6655</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6656>6656</a></td>\n' +
            '<td>          if (copy_to_user(buf, local_data + pos, count))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6657>6657</a></td>\n' +
            '<td>                  return -EFAULT;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6658>6658</a></td>\n' +
            '<td>          return count;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6659>6659</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6660>6660</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6661>6661</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6662>6662</a></td>\n' +
            '<td>If the size of the info entry has been set up properly, count and pos are guaranteed to fit within 0 and the given size. You don' + "'" + 't have to check the range in the callbacks unless any other condition is required.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6663>6663</a></td>\n' +
            '<td>Power Management</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6664>6664</a></td>\n' +
            '<td>If the chip is supposed to work with suspend/resume functions, you need to add power-management code to the driver. The additional code for power-management should be ifdef' + "'" + 'ed with CONFIG_PM.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6665>6665</a></td>\n' +
            '<td>If the driver fully supports suspend/resume that is, the device can be properly resumed to its state when suspend was called, you can set the SNDRV_PCM_INFO_RESUME flag in the pcm info field. Usually, this is possible when the registers of the chip can be safely saved and restored to RAM. If this is set, the trigger callback is called with SNDRV_PCM_TRIGGER_RESUME after the resume callback completes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6666>6666</a></td>\n' +
            '<td>Even if the driver doesn' + "'" + 't support PM fully but partial suspend/resume is still possible, it' + "'" + 's still worthy to implement suspend/resume callbacks. In such a case, applications would reset the status by calling snd_pcm_prepare() and restart the stream appropriately. Hence, you can define suspend/resume callbacks below but don' + "'" + 't set SNDRV_PCM_INFO_RESUME info flag to the PCM.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6667>6667</a></td>\n' +
            '<td>Note that the trigger with SUSPEND can always be called when snd_pcm_suspend_all is called, regardless of the SNDRV_PCM_INFO_RESUME flag. The RESUME flag affects only the behavior of snd_pcm_resume(). (Thus, in theory, SNDRV_PCM_TRIGGER_RESUME isn' + "'" + 't needed to be handled in the trigger callback when no SNDRV_PCM_INFO_RESUME flag is set. But, it' + "'" + 's better to keep it for compatibility reasons.)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6668>6668</a></td>\n' +
            '<td>In the earlier version of ALSA drivers, a common power-management layer was provided, but it has been removed. The driver needs to define the suspend/resume hooks according to the bus the device is connected to. In the case of PCI drivers, the callbacks look like below:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6669>6669</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6670>6670</a></td>\n' +
            '<td>  #ifdef CONFIG_PM</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6671>6671</a></td>\n' +
            '<td>  static int snd_my_suspend(struct pci_dev *pci, pm_message_t state)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6672>6672</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6673>6673</a></td>\n' +
            '<td>          .... /* do things for suspend */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6674>6674</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6675>6675</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6676>6676</a></td>\n' +
            '<td>  static int snd_my_resume(struct pci_dev *pci)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6677>6677</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6678>6678</a></td>\n' +
            '<td>          .... /* do things for suspend */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6679>6679</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6680>6680</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6681>6681</a></td>\n' +
            '<td>  #endif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6682>6682</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6683>6683</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6684>6684</a></td>\n' +
            '<td>The scheme of the real suspend job is as follows.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6685>6685</a></td>\n' +
            '<td>1.    Retrieve the card and the chip data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6686>6686</a></td>\n' +
            '<td>2.    Call snd_power_change_state() with SNDRV_CTL_POWER_D3hot to change the power status.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6687>6687</a></td>\n' +
            '<td>3.    Call snd_pcm_suspend_all() to suspend the running PCM streams.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6688>6688</a></td>\n' +
            '<td>4.    If AC97 codecs are used, call snd_ac97_suspend() for each codec.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6689>6689</a></td>\n' +
            '<td>5.    Save the register values if necessary.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6690>6690</a></td>\n' +
            '<td>6.    Stop the hardware if necessary.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6691>6691</a></td>\n' +
            '<td>7.    Disable the PCI device by calling pci_disable_device(). Then, call pci_save_state() at last.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6692>6692</a></td>\n' +
            '<td>A typical code would be like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6693>6693</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6694>6694</a></td>\n' +
            '<td>  static int mychip_suspend(struct pci_dev *pci, pm_message_t state)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6695>6695</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6696>6696</a></td>\n' +
            '<td>          /* (1) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6697>6697</a></td>\n' +
            '<td>          struct snd_card *card = pci_get_drvdata(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6698>6698</a></td>\n' +
            '<td>          struct mychip *chip = card-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6699>6699</a></td>\n' +
            '<td>          /* (2) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6700>6700</a></td>\n' +
            '<td>          snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6701>6701</a></td>\n' +
            '<td>          /* (3) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6702>6702</a></td>\n' +
            '<td>          snd_pcm_suspend_all(chip-&gt;pcm);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6703>6703</a></td>\n' +
            '<td>          /* (4) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6704>6704</a></td>\n' +
            '<td>          snd_ac97_suspend(chip-&gt;ac97);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6705>6705</a></td>\n' +
            '<td>          /* (5) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6706>6706</a></td>\n' +
            '<td>          snd_mychip_save_registers(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6707>6707</a></td>\n' +
            '<td>          /* (6) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6708>6708</a></td>\n' +
            '<td>          snd_mychip_stop_hardware(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6709>6709</a></td>\n' +
            '<td>          /* (7) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6710>6710</a></td>\n' +
            '<td>          pci_disable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6711>6711</a></td>\n' +
            '<td>          pci_save_state(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6712>6712</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6713>6713</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6714>6714</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6715>6715</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6716>6716</a></td>\n' +
            '<td>The scheme of the real resume job is as follows.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6717>6717</a></td>\n' +
            '<td>1.    Retrieve the card and the chip data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6718>6718</a></td>\n' +
            '<td>2.    Set up PCI. First, call pci_restore_state(). Then enable the pci device again by calling pci_enable_device(). Call pci_set_master() if necessary, too.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6719>6719</a></td>\n' +
            '<td>3.    Re-initialize the chip.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6720>6720</a></td>\n' +
            '<td>4.    Restore the saved registers if necessary.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6721>6721</a></td>\n' +
            '<td>5.    Resume the mixer, e.g. calling snd_ac97_resume().</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6722>6722</a></td>\n' +
            '<td>6.    Restart the hardware (if any).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6723>6723</a></td>\n' +
            '<td>7.    Call snd_power_change_state() with SNDRV_CTL_POWER_D0 to notify the processes.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6724>6724</a></td>\n' +
            '<td>A typical code would be like:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6725>6725</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6726>6726</a></td>\n' +
            '<td>  static int mychip_resume(struct pci_dev *pci)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6727>6727</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6728>6728</a></td>\n' +
            '<td>          /* (1) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6729>6729</a></td>\n' +
            '<td>          struct snd_card *card = pci_get_drvdata(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6730>6730</a></td>\n' +
            '<td>          struct mychip *chip = card-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6731>6731</a></td>\n' +
            '<td>          /* (2) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6732>6732</a></td>\n' +
            '<td>          pci_restore_state(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6733>6733</a></td>\n' +
            '<td>          pci_enable_device(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6734>6734</a></td>\n' +
            '<td>          pci_set_master(pci);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6735>6735</a></td>\n' +
            '<td>          /* (3) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6736>6736</a></td>\n' +
            '<td>          snd_mychip_reinit_chip(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6737>6737</a></td>\n' +
            '<td>          /* (4) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6738>6738</a></td>\n' +
            '<td>          snd_mychip_restore_registers(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6739>6739</a></td>\n' +
            '<td>          /* (5) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6740>6740</a></td>\n' +
            '<td>          snd_ac97_resume(chip-&gt;ac97);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6741>6741</a></td>\n' +
            '<td>          /* (6) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6742>6742</a></td>\n' +
            '<td>          snd_mychip_restart_chip(chip);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6743>6743</a></td>\n' +
            '<td>          /* (7) */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6744>6744</a></td>\n' +
            '<td>          snd_power_change_state(card, SNDRV_CTL_POWER_D0);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6745>6745</a></td>\n' +
            '<td>          return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6746>6746</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6747>6747</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6748>6748</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6749>6749</a></td>\n' +
            '<td>As shown in the above, it' + "'" + 's better to save registers after suspending the PCM operations via snd_pcm_suspend_all() or snd_pcm_suspend(). It means that the PCM streams are already stoppped when the register snapshot is taken. But, remember that you don' + "'" + 't have to restart the PCM stream in the resume callback. It' + "'" + 'll be restarted via trigger call with SNDRV_PCM_TRIGGER_RESUME when necessary.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6750>6750</a></td>\n' +
            '<td>OK, we have all callbacks now. Let' + "'" + 's set them up. In the initialization of the card, make sure that you can get the chip data from the card instance, typically via private_data field, in case you created the chip data individually.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6751>6751</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6752>6752</a></td>\n' +
            '<td>  static int snd_mychip_probe(struct pci_dev *pci,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6753>6753</a></td>\n' +
            '<td>                              const struct pci_device_id *pci_id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6754>6754</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6755>6755</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6756>6756</a></td>\n' +
            '<td>          struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6757>6757</a></td>\n' +
            '<td>          struct mychip *chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6758>6758</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6759>6759</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6760>6760</a></td>\n' +
            '<td>          err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &amp;card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6761>6761</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6762>6762</a></td>\n' +
            '<td>          chip = kzalloc(sizeof(*chip), GFP_KERNEL);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6763>6763</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6764>6764</a></td>\n' +
            '<td>          card-&gt;private_data = chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6765>6765</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6766>6766</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6767>6767</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6768>6768</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6769>6769</a></td>\n' +
            '<td>When you created the chip data with snd_card_create(), it' + "'" + 's anyway accessible via private_data field.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6770>6770</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6771>6771</a></td>\n' +
            '<td>  static int snd_mychip_probe(struct pci_dev *pci,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6772>6772</a></td>\n' +
            '<td>                              const struct pci_device_id *pci_id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6773>6773</a></td>\n' +
            '<td>  {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6774>6774</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6775>6775</a></td>\n' +
            '<td>          struct snd_card *card;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6776>6776</a></td>\n' +
            '<td>          struct mychip *chip;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6777>6777</a></td>\n' +
            '<td>          int err;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6778>6778</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6779>6779</a></td>\n' +
            '<td>          err = snd_card_create(index[dev], id[dev], THIS_MODULE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6780>6780</a></td>\n' +
            '<td>                                sizeof(struct mychip), &amp;card);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6781>6781</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6782>6782</a></td>\n' +
            '<td>          chip = card-&gt;private_data;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6783>6783</a></td>\n' +
            '<td>          ....</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6784>6784</a></td>\n' +
            '<td>  }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6785>6785</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6786>6786</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6787>6787</a></td>\n' +
            '<td>If you need a space to save the registers, allocate the buffer for it here, too, since it would be fatal if you cannot allocate a memory in the suspend phase. The allocated buffer should be released in the corresponding destructor.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6788>6788</a></td>\n' +
            '<td>And next, set suspend/resume callbacks to the pci_driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6789>6789</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6790>6790</a></td>\n' +
            '<td>  static struct pci_driver driver = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6791>6791</a></td>\n' +
            '<td>          .name = KBUILD_MODNAME,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6792>6792</a></td>\n' +
            '<td>          .id_table = snd_my_ids,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6793>6793</a></td>\n' +
            '<td>          .probe = snd_my_probe,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6794>6794</a></td>\n' +
            '<td>          .remove = snd_my_remove,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6795>6795</a></td>\n' +
            '<td>  #ifdef CONFIG_PM</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6796>6796</a></td>\n' +
            '<td>          .suspend = snd_my_suspend,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6797>6797</a></td>\n' +
            '<td>          .resume = snd_my_resume,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6798>6798</a></td>\n' +
            '<td>  #endif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6799>6799</a></td>\n' +
            '<td>  };</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6800>6800</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6801>6801</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6802>6802</a></td>\n' +
            '<td>Module Parameters</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6803>6803</a></td>\n' +
            '<td>There are standard module options for ALSA. At least, each module should have the index, id and enable options.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6804>6804</a></td>\n' +
            '<td>If the module supports multiple cards (usually up to 8 = SNDRV_CARDS cards), they should be arrays. The default initial values are defined already as constants for easier programming:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6805>6805</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6806>6806</a></td>\n' +
            '<td>  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6807>6807</a></td>\n' +
            '<td>  static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6808>6808</a></td>\n' +
            '<td>  static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6809>6809</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6810>6810</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6811>6811</a></td>\n' +
            '<td>If the module supports only a single card, they could be single variables, instead. enable option is not always necessary in this case, but it would be better to have a dummy option for compatibility.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6812>6812</a></td>\n' +
            '<td>The module parameters must be declared with the standard module_param()(), module_param_array()() and MODULE_PARM_DESC() macros.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6813>6813</a></td>\n' +
            '<td>The typical coding would be like below:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6814>6814</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6815>6815</a></td>\n' +
            '<td>  #define CARD_NAME "My Chip"</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6816>6816</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6817>6817</a></td>\n' +
            '<td>  module_param_array(index, int, NULL, 0444);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6818>6818</a></td>\n' +
            '<td>  MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6819>6819</a></td>\n' +
            '<td>  module_param_array(id, charp, NULL, 0444);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6820>6820</a></td>\n' +
            '<td>  MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6821>6821</a></td>\n' +
            '<td>  module_param_array(enable, bool, NULL, 0444);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6822>6822</a></td>\n' +
            '<td>  MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6823>6823</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6824>6824</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6825>6825</a></td>\n' +
            '<td>Also, don' + "'" + 't forget to define the module description, classes, license and devices. Especially, the recent modprobe requires to define the module license as GPL, etc., otherwise the system is shown as tainted.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6826>6826</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6827>6827</a></td>\n' +
            '<td>  MODULE_DESCRIPTION("My Chip");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6828>6828</a></td>\n' +
            '<td>  MODULE_LICENSE("GPL");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6829>6829</a></td>\n' +
            '<td>  MODULE_SUPPORTED_DEVICE("{{Vendor,My Chip Name}}");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6830>6830</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6831>6831</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6832>6832</a></td>\n' +
            '<td>How To Put Your Driver Into ALSA Tree</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6833>6833</a></td>\n' +
            '<td>General</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6834>6834</a></td>\n' +
            '<td>So far, you' + "'" + 've learned how to write the driver codes. And you might have a question now: how to put my own driver into the ALSA driver tree? Here (finally :) the standard procedure is described briefly.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6835>6835</a></td>\n' +
            '<td>Suppose that you create a new PCI driver for the card xyz. The card module name would be snd-xyz. The new driver is usually put into the alsa-driver tree, alsa-driver/pci directory in the case of PCI cards. Then the driver is evaluated, audited and tested by developers and users. After a certain time, the driver will go to the alsa-kernel tree (to the corresponding directory, such as alsa-kernel/pci) and eventually will be integrated into the Linux 2.6 tree (the directory would be linux/sound/pci).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6836>6836</a></td>\n' +
            '<td>In the following sections, the driver code is supposed to be put into alsa-driver tree. The two cases are covered: a driver consisting of a single source file and one consisting of several source files.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6837>6837</a></td>\n' +
            '<td>Driver with A Single Source File</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6838>6838</a></td>\n' +
            '<td>1.    Modify alsa-driver/pci/Makefile</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6839>6839</a></td>\n' +
            '<td>     Suppose you have a file xyz.c. Add the following two lines</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6840>6840</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6841>6841</a></td>\n' +
            '<td>  snd-xyz-objs := xyz.o</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6842>6842</a></td>\n' +
            '<td>  obj-$(CONFIG_SND_XYZ) += snd-xyz.o</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6843>6843</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6844>6844</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6845>6845</a></td>\n' +
            '<td>2.    Create the Kconfig entry</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6846>6846</a></td>\n' +
            '<td>     Add the new entry of Kconfig for your xyz driver.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6847>6847</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6848>6848</a></td>\n' +
            '<td>  config SND_XYZ</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6849>6849</a></td>\n' +
            '<td>          tristate "Foobar XYZ"</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6850>6850</a></td>\n' +
            '<td>          depends on SND</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6851>6851</a></td>\n' +
            '<td>          select SND_PCM</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6852>6852</a></td>\n' +
            '<td>          help</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6853>6853</a></td>\n' +
            '<td>            Say Y here to include support for Foobar XYZ soundcard.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6854>6854</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6855>6855</a></td>\n' +
            '<td>            To compile this driver as a module, choose M here: the module</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6856>6856</a></td>\n' +
            '<td>            will be called snd-xyz.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6857>6857</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6858>6858</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6859>6859</a></td>\n' +
            '<td>     the line, select SND_PCM, specifies that the driver xyz supports PCM. In addition to SND_PCM, the following components are supported for select command: SND_RAWMIDI, SND_TIMER, SND_HWDEP, SND_MPU401_UART, SND_OPL3_LIB, SND_OPL4_LIB, SND_VX_LIB, SND_AC97_CODEC. Add the select command for each supported component.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6860>6860</a></td>\n' +
            '<td>     Note that some selections imply the lowlevel selections. For example, PCM includes TIMER, MPU401_UART includes RAWMIDI, AC97_CODEC includes PCM, and OPL3_LIB includes HWDEP. You don' + "'" + 't need to give the lowlevel selections again.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6861>6861</a></td>\n' +
            '<td>     For the details of Kconfig script, refer to the kbuild documentation.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6862>6862</a></td>\n' +
            '<td>3.    Run cvscompile script to re-generate the configure script and build the whole stuff again.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6863>6863</a></td>\n' +
            '<td>Drivers with Several Source Files</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6864>6864</a></td>\n' +
            '<td>Suppose that the driver snd-xyz have several source files. They are located in the new subdirectory, pci/xyz.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6865>6865</a></td>\n' +
            '<td>1.    Add a new directory (xyz) in alsa-driver/pci/Makefile as below</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6866>6866</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6867>6867</a></td>\n' +
            '<td>  obj-$(CONFIG_SND) += xyz/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6868>6868</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6869>6869</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6870>6870</a></td>\n' +
            '<td>2.    Under the directory xyz, create a Makefile</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6871>6871</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6872>6872</a></td>\n' +
            '<td>  ifndef SND_TOPDIR</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6873>6873</a></td>\n' +
            '<td>  SND_TOPDIR=../..</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6874>6874</a></td>\n' +
            '<td>  endif</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6875>6875</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6876>6876</a></td>\n' +
            '<td>  include $(SND_TOPDIR)/toplevel.config</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6877>6877</a></td>\n' +
            '<td>  include $(SND_TOPDIR)/Makefile.conf</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6878>6878</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6879>6879</a></td>\n' +
            '<td>  snd-xyz-objs := xyz.o abc.o def.o</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6880>6880</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6881>6881</a></td>\n' +
            '<td>  obj-$(CONFIG_SND_XYZ) += snd-xyz.o</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6882>6882</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6883>6883</a></td>\n' +
            '<td>  include $(SND_TOPDIR)/Rules.make</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6884>6884</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6885>6885</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6886>6886</a></td>\n' +
            '<td>3.    Create the Kconfig entry</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6887>6887</a></td>\n' +
            '<td>     This procedure is as same as in the last section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6888>6888</a></td>\n' +
            '<td>4.    Run cvscompile script to re-generate the configure script and build the whole stuff again.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6889>6889</a></td>\n' +
            '<td>Useful Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6890>6890</a></td>\n' +
            '<td>snd_printk() and friends</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6891>6891</a></td>\n' +
            '<td>ALSA provides a verbose version of the printk() function. If a kernel config CONFIG_SND_VERBOSE_PRINTK is set, this function prints the given message together with the file name and the line of the caller. The KERN_XXX prefix is processed as well as the original printk() does, so it' + "'" + 's recommended to add this prefix, e.g.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6892>6892</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6893>6893</a></td>\n' +
            '<td>  snd_printk(KERN_ERR "Oh my, sorry, it' + "'" + 's extremely bad!\\n");</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6894>6894</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6895>6895</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6896>6896</a></td>\n' +
            '<td>There are also printk()' + "'" + 's for debugging. snd_printd() can be used for general debugging purposes. If CONFIG_SND_DEBUG is set, this function is compiled, and works just like snd_printk(). If the ALSA is compiled without the debugging flag, it' + "'" + 's ignored.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6897>6897</a></td>\n' +
            '<td>snd_printdd() is compiled in only when CONFIG_SND_DEBUG_VERBOSE is set. Please note that CONFIG_SND_DEBUG_VERBOSE is not set as default even if you configure the alsa-driver with --with-debug=full option. You need to give explicitly --with-debug=detect option instead.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6898>6898</a></td>\n' +
            '<td>snd_BUG()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6899>6899</a></td>\n' +
            '<td>It shows the BUG? message and stack trace as well as snd_BUG_ON at the point. It' + "'" + 's useful to show that a fatal error happens there.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6900>6900</a></td>\n' +
            '<td>When no debug flag is set, this macro is ignored.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6901>6901</a></td>\n' +
            '<td>snd_BUG_ON()</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6902>6902</a></td>\n' +
            '<td>snd_BUG_ON() macro is similar with WARN_ON() macro. For example,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6903>6903</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6904>6904</a></td>\n' +
            '<td>  snd_BUG_ON(!pointer);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6905>6905</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6906>6906</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6907>6907</a></td>\n' +
            '<td>or it can be used as the condition,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6908>6908</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6909>6909</a></td>\n' +
            '<td>  if (snd_BUG_ON(non_zero_is_bug))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6910>6910</a></td>\n' +
            '<td>          return -EINVAL;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6911>6911</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6912>6912</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6913>6913</a></td>\n' +
            '<td>The macro takes an conditional expression to evaluate. When CONFIG_SND_DEBUG, is set, if the expression is non-zero, it shows the warning message such as BUG? (xxx) normally followed by stack trace. In both cases it returns the evaluated value.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6914>6914</a></td>\n' +
            '<td>Acknowledgments</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6915>6915</a></td>\n' +
            '<td>I would like to thank Phil Kerr for his help for improvement and corrections of this document.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6916>6916</a></td>\n' +
            '<td>Kevin Conder reformatted the original plain-text to the DocBook format.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6917>6917</a></td>\n' +
            '<td>Giuliano Pochini corrected typos and contributed the example codes in the hardware constraints section.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6918>6918</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6919>6919</a></td>\n' +
            '<td>The Linux USB subsystem has grown from supporting only two different types of devices in the 2.2.7 kernel (mice and keyboards), to over 20 different types of devices in the 2.4 kernel. Linux currently supports almost all USB class devices (standard types of devices like keyboards, mice, modems, printers and speakers) and an ever-growing number of vendor-specific devices (such as USB to serial converters, digital cameras, Ethernet devices and MP3 players). For a full list of the different USB devices currently supported, see Resources.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6920>6920</a></td>\n' +
            '<td>The remaining kinds of USB devices that do not have support on Linux are almost all vendor-specific devices. Each vendor decides to implement a custom protocol to talk to their device, so a custom driver usually needs to be created. Some vendors are open with their USB protocols and help with the creation of Linux drivers, while others do not publish them, and developers are forced to reverse-engineer. See Resources for some links to handy reverse-engineering tools.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6921>6921</a></td>\n' +
            '<td>Because each different protocol causes a new driver to be created, I have written a generic USB driver skeleton, modelled after the pci-skeleton.c file in the kernel source tree upon which many PCI network drivers have been based. This USB skeleton can be found at drivers/usb/usb-skeleton.c in the kernel source tree. In this article I will walk through the basics of the skeleton driver, explaining the different pieces and what needs to be done to customize it to your specific device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6922>6922</a></td>\n' +
            '<td>Linux USB Basics</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6923>6923</a></td>\n' +
            '<td>If you are going to write a Linux USB driver, please become familiar with the USB protocol specification. It can be found, along with many other useful documents, at the USB home page (see Resources). An excellent introduction to the Linux USB subsystem can be found at the USB Working Devices List (see Resources). It explains how the Linux USB subsystem is structured and introduces the reader to the concept of USB urbs (USB Request Blocks), which are essential to USB drivers.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6924>6924</a></td>\n' +
            '<td>The first thing a Linux USB driver needs to do is register itself with the Linux USB subsystem, giving it some information about which devices the driver supports and which functions to call when a device supported by the driver is inserted or removed from the system. All of this information is passed to the USB subsystem in the usb_driver structure. The skeleton driver declares a usb_driver as:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6925>6925</a></td>\n' +
            '<td>static struct usb_driver skel_driver = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6926>6926</a></td>\n' +
            '<td>        .name        = "skeleton",</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6927>6927</a></td>\n' +
            '<td>        .probe       = skel_probe,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6928>6928</a></td>\n' +
            '<td>        .disconnect  = skel_disconnect,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6929>6929</a></td>\n' +
            '<td>        .fops        = &amp;skel_fops,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6930>6930</a></td>\n' +
            '<td>        .minor       = USB_SKEL_MINOR_BASE,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6931>6931</a></td>\n' +
            '<td>        .id_table    = skel_table,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6932>6932</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6933>6933</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6934>6934</a></td>\n' +
            '<td>The variable name is a string that describes the driver. It is used in informational messages printed to the system log. The probe and disconnect function pointers are called when a device that matches the information provided in the id_table variable is either seen or removed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6935>6935</a></td>\n' +
            '<td>The fops and minor variables are optional. Most USB drivers hook into another kernel subsystem, such as the SCSI, network or TTY subsystem. These types of drivers register themselves with the other kernel subsystem, and any user-space interactions are provided through that interface. But for drivers that do not have a matching kernel subsystem, such as MP3 players or scanners, a method of interacting with user space is needed. The USB subsystem provides a way to register a minor device number and a set of file_operations function pointers that enable this user-space interaction. The skeleton driver needs this kind of interface, so it provides a minor starting number and a pointer to its file_operations functions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6936>6936</a></td>\n' +
            '<td>The USB driver is then registered with a call to usb_register, usually in the driver' + "'" + 's init function, as shown here:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6937>6937</a></td>\n' +
            '<td>static int __init usb_skel_init(void)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6938>6938</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6939>6939</a></td>\n' +
            '<td>        int result;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6940>6940</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6941>6941</a></td>\n' +
            '<td>        /* register this driver with the USB subsystem */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6942>6942</a></td>\n' +
            '<td>        result = usb_register(&amp;skel_driver);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6943>6943</a></td>\n' +
            '<td>        if (result &lt; 0) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6944>6944</a></td>\n' +
            '<td>                err("usb_register failed for the "__FILE__ "driver."</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6945>6945</a></td>\n' +
            '<td>                    "Error number %d", result);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6946>6946</a></td>\n' +
            '<td>                return -1;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6947>6947</a></td>\n' +
            '<td>        }</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6948>6948</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6949>6949</a></td>\n' +
            '<td>        return 0;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6950>6950</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6951>6951</a></td>\n' +
            '<td>module_init(usb_skel_init);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6952>6952</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6953>6953</a></td>\n' +
            '<td>When the driver is unloaded from the system, it needs to deregister itself with the USB subsystem. This is done with the usb_deregister function:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6954>6954</a></td>\n' +
            '<td>static void __exit usb_skel_exit(void)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6955>6955</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6956>6956</a></td>\n' +
            '<td>        /* deregister this driver with the USB subsystem */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6957>6957</a></td>\n' +
            '<td>        usb_deregister(&amp;skel_driver);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6958>6958</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6959>6959</a></td>\n' +
            '<td>module_exit(usb_skel_exit);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6960>6960</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6961>6961</a></td>\n' +
            '<td>To enable the linux-hotplug system to load the driver automatically when the device is plugged in, you need to create a MODULE_DEVICE_TABLE. The following code tells the hotplug scripts that this module supports a single device with a specific vendor and product ID:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6962>6962</a></td>\n' +
            '<td>/* table of devices that work with this driver */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6963>6963</a></td>\n' +
            '<td>static struct usb_device_id skel_table [] = {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6964>6964</a></td>\n' +
            '<td>        { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6965>6965</a></td>\n' +
            '<td>        { }                      /* Terminating entry */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6966>6966</a></td>\n' +
            '<td>};</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6967>6967</a></td>\n' +
            '<td>MODULE_DEVICE_TABLE (usb, skel_table);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6968>6968</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6969>6969</a></td>\n' +
            '<td>There are other macros that can be used in describing a usb_device_id for drivers that support a whole class of USB drivers. See usb.h for more information on this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6970>6970</a></td>\n' +
            '<td>Device operation</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6971>6971</a></td>\n' +
            '<td>When a device is plugged into the USB bus that matches the device ID pattern that your driver registered with the USB core, the probe function is called. The usb_device structure, interface number and the interface ID are passed to the function:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6972>6972</a></td>\n' +
            '<td>static int skel_probe(struct usb_interface *interface,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6973>6973</a></td>\n' +
            '<td>    const struct usb_device_id *id)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6974>6974</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6975>6975</a></td>\n' +
            '<td>The driver now needs to verify that this device is actually one that it can accept. If so, it returns 0. If not, or if any error occurs during initialization, an errorcode (such as -ENOMEM or -ENODEV) is returned from the probe function.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6976>6976</a></td>\n' +
            '<td>In the skeleton driver, we determine what end points are marked as bulk-in and bulk-out. We create buffers to hold the data that will be sent and received from the device, and a USB urb to write data to the device is initialized.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6977>6977</a></td>\n' +
            '<td>Conversely, when the device is removed from the USB bus, the disconnect function is called with the device pointer. The driver needs to clean any private data that has been allocated at this time and to shut down any pending urbs that are in the USB system.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6978>6978</a></td>\n' +
            '<td>Now that the device is plugged into the system and the driver is bound to the device, any of the functions in the file_operations structure that were passed to the USB subsystem will be called from a user program trying to talk to the device. The first function called will be open, as the program tries to open the device for I/O. We increment our private usage count and save a pointer to our internal structure in the file structure. This is done so that future calls to file operations will enable the driver to determine which device the user is addressing. All of this is done with the following code:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6979>6979</a></td>\n' +
            '<td>/* increment our usage count for the module */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6980>6980</a></td>\n' +
            '<td>++skel-&gt;open_count;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6981>6981</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6982>6982</a></td>\n' +
            '<td>/* save our object in the file' + "'" + 's private structure */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6983>6983</a></td>\n' +
            '<td>file-&gt;private_data = dev;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6984>6984</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6985>6985</a></td>\n' +
            '<td>After the open function is called, the read and write functions are called to receive and send data to the device. In the skel_write function, we receive a pointer to some data that the user wants to send to the device and the size of the data. The function determines how much data it can send to the device based on the size of the write urb it has created (this size depends on the size of the bulk out end point that the device has). Then it copies the data from user space to kernel space, points the urb to the data and submits the urb to the USB subsystem. This can be seen in the following code:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6986>6986</a></td>\n' +
            '<td>/* we can only write as much as 1 urb will hold */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6987>6987</a></td>\n' +
            '<td>bytes_written = (count &gt; skel-&gt;bulk_out_size) ? skel-&gt;bulk_out_size : count;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6988>6988</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6989>6989</a></td>\n' +
            '<td>/* copy the data from user space into our urb */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6990>6990</a></td>\n' +
            '<td>copy_from_user(skel-&gt;write_urb-&gt;transfer_buffer, buffer, bytes_written);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6991>6991</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6992>6992</a></td>\n' +
            '<td>/* set up our urb */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6993>6993</a></td>\n' +
            '<td>usb_fill_bulk_urb(skel-&gt;write_urb,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6994>6994</a></td>\n' +
            '<td>                  skel-&gt;dev,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6995>6995</a></td>\n' +
            '<td>                  usb_sndbulkpipe(skel-&gt;dev, skel-&gt;bulk_out_endpointAddr),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6996>6996</a></td>\n' +
            '<td>                  skel-&gt;write_urb-&gt;transfer_buffer,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6997>6997</a></td>\n' +
            '<td>                  bytes_written,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6998>6998</a></td>\n' +
            '<td>                  skel_write_bulk_callback,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=6999>6999</a></td>\n' +
            '<td>                  skel);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7000>7000</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7001>7001</a></td>\n' +
            '<td>/* send the data out the bulk port */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7002>7002</a></td>\n' +
            '<td>result = usb_submit_urb(skel-&gt;write_urb);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7003>7003</a></td>\n' +
            '<td>if (result) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7004>7004</a></td>\n' +
            '<td>        err("Failed submitting write urb, error %d", result);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7005>7005</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7006>7006</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7007>7007</a></td>\n' +
            '<td>When the write urb is filled up with the proper information using the usb_fill_bulk_urb function, we point the urb' + "'" + 's completion callback to call our own skel_write_bulk_callback function. This function is called when the urb is finished by the USB subsystem. The callback function is called in interrupt context, so caution must be taken not to do very much processing at that time. Our implementation of skel_write_bulk_callback merely reports if the urb was completed successfully or not and then returns.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7008>7008</a></td>\n' +
            '<td>The read function works a bit differently from the write function in that we do not use an urb to transfer data from the device to the driver. Instead we call the usb_bulk_msg function, which can be used to send or receive data from a device without having to create urbs and handle urb completion callback functions. We call the usb_bulk_msg function, giving it a buffer into which to place any data received from the device and a timeout value. If the timeout period expires without receiving any data from the device, the function will fail and return an error message. This can be shown with the following code:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7009>7009</a></td>\n' +
            '<td>/* do an immediate bulk read to get data from the device */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7010>7010</a></td>\n' +
            '<td>retval = usb_bulk_msg (skel-&gt;dev,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7011>7011</a></td>\n' +
            '<td>                       usb_rcvbulkpipe (skel-&gt;dev,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7012>7012</a></td>\n' +
            '<td>                       skel-&gt;bulk_in_endpointAddr),</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7013>7013</a></td>\n' +
            '<td>                       skel-&gt;bulk_in_buffer,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7014>7014</a></td>\n' +
            '<td>                       skel-&gt;bulk_in_size,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7015>7015</a></td>\n' +
            '<td>                       &amp;count, HZ*10);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7016>7016</a></td>\n' +
            '<td>/* if the read was successful, copy the data to user space */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7017>7017</a></td>\n' +
            '<td>if (!retval) {</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7018>7018</a></td>\n' +
            '<td>        if (copy_to_user (buffer, skel-&gt;bulk_in_buffer, count))</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7019>7019</a></td>\n' +
            '<td>                retval = -EFAULT;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7020>7020</a></td>\n' +
            '<td>        else</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7021>7021</a></td>\n' +
            '<td>                retval = count;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7022>7022</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7023>7023</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7024>7024</a></td>\n' +
            '<td>The usb_bulk_msg function can be very useful for doing single reads or writes to a device; however, if you need to read or write constantly to a device, it is recommended to set up your own urbs and submit them to the USB subsystem.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7025>7025</a></td>\n' +
            '<td>When the user program releases the file handle that it has been using to talk to the device, the release function in the driver is called. In this function we decrement our private usage count and wait for possible pending writes:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7026>7026</a></td>\n' +
            '<td>/* decrement our usage count for the device */</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7027>7027</a></td>\n' +
            '<td>--skel-&gt;open_count;</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7028>7028</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7029>7029</a></td>\n' +
            '<td>One of the more difficult problems that USB drivers must be able to handle smoothly is the fact that the USB device may be removed from the system at any point in time, even if a program is currently talking to it. It needs to be able to shut down any current reads and writes and notify the user-space programs that the device is no longer there. The following code (function skel_delete) is an example of how to do this:</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7030>7030</a></td>\n' +
            '<td>static inline void skel_delete (struct usb_skel *dev)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7031>7031</a></td>\n' +
            '<td>{</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7032>7032</a></td>\n' +
            '<td>    kfree (dev-&gt;bulk_in_buffer);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7033>7033</a></td>\n' +
            '<td>    if (dev-&gt;bulk_out_buffer != NULL)</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7034>7034</a></td>\n' +
            '<td>        usb_free_coherent (dev-&gt;udev, dev-&gt;bulk_out_size,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7035>7035</a></td>\n' +
            '<td>            dev-&gt;bulk_out_buffer,</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7036>7036</a></td>\n' +
            '<td>            dev-&gt;write_urb-&gt;transfer_dma);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7037>7037</a></td>\n' +
            '<td>    usb_free_urb (dev-&gt;write_urb);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7038>7038</a></td>\n' +
            '<td>    kfree (dev);</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7039>7039</a></td>\n' +
            '<td>}</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7040>7040</a></td>\n' +
            '<td></td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7041>7041</a></td>\n' +
            '<td>If a program currently has an open handle to the device, we reset the flag device_present. For every read, write, release and other functions that expect a device to be present, the driver first checks this flag to see if the device is still present. If not, it releases that the device has disappeared, and a -ENODEV error is returned to the user-space program. When the release function is eventually called, it determines if there is no device and if not, it does the cleanup that the skel_disconnect function normally does if there are no open files on the device (see Listing 5).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7042>7042</a></td>\n' +
            '<td>Isochronous Data</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7043>7043</a></td>\n' +
            '<td>This usb-skeleton driver does not have any examples of interrupt or isochronous data being sent to or from the device. Interrupt data is sent almost exactly as bulk data is, with a few minor exceptions. Isochronous data works differently with continuous streams of data being sent to or from the device. The audio and video camera drivers are very good examples of drivers that handle isochronous data and will be useful if you also need to do this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7044>7044</a></td>\n' +
            '<td>Conclusion</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7045>7045</a></td>\n' +
            '<td>Writing Linux USB device drivers is not a difficult task as the usb-skeleton driver shows. This driver, combined with the other current USB drivers, should provide enough examples to help a beginning author create a working driver in a minimal amount of time. The linux-usb-devel mailing list archives also contain a lot of helpful information.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7046>7046</a></td>\n' +
            '<td>Resources</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7047>7047</a></td>\n' +
            '<td>The Linux USB Project: http://www.linux-usb.org/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7048>7048</a></td>\n' +
            '<td>Linux Hotplug Project: http://linux-hotplug.sourceforge.net/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7049>7049</a></td>\n' +
            '<td>Linux USB Working Devices List: http://www.qbik.ch/usb/devices/</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7050>7050</a></td>\n' +
            '<td>linux-usb-devel Mailing List Archives: http://marc.theaimsgroup.com/?l=linux-usb-devel</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7051>7051</a></td>\n' +
            '<td>Programming Guide for Linux USB Device Drivers: http://usb.cs.tum.edu/usbdoc</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7052>7052</a></td>\n' +
            '<td>USB Home Page: http://www.usb.org</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7053>7053</a></td>\n' +
            '<td>Introduction</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7054>7054</a></td>\n' +
            '<td>The Z85x30 family synchronous/asynchronous controller chips are used on a large number of cheap network interface cards. The kernel provides a core interface layer that is designed to make it easy to provide WAN services using this chip.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7055>7055</a></td>\n' +
            '<td>The current driver only support synchronous operation. Merging the asynchronous driver support into this code to allow any Z85x30 device to be used as both a tty interface and as a synchronous controller is a project for Linux post the 2.4 release</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7056>7056</a></td>\n' +
            '<td>Driver Modes</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7057>7057</a></td>\n' +
            '<td>The Z85230 driver layer can drive Z8530, Z85C30 and Z85230 devices in three different modes. Each mode can be applied to an individual channel on the chip (each chip has two channels).</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7058>7058</a></td>\n' +
            '<td>The PIO synchronous mode supports the most common Z8530 wiring. Here the chip is interface to the I/O and interrupt facilities of the host machine but not to the DMA subsystem. When running PIO the Z8530 has extremely tight timing requirements. Doing high speeds, even with a Z85230 will be tricky. Typically you should expect to achieve at best 9600 baud with a Z8C530 and 64Kbits with a Z85230.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7059>7059</a></td>\n' +
            '<td>The DMA mode supports the chip when it is configured to use dual DMA channels on an ISA bus. The better cards tend to support this mode of operation for a single channel. With DMA running the Z85230 tops out when it starts to hit ISA DMA constraints at about 512Kbits. It is worth noting here that many PC machines hang or crash when the chip is driven fast enough to hold the ISA bus solid.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7060>7060</a></td>\n' +
            '<td>Transmit DMA mode uses a single DMA channel. The DMA channel is used for transmission as the transmit FIFO is smaller than the receive FIFO. it gives better performance than pure PIO mode but is nowhere near as ideal as pure DMA mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7061>7061</a></td>\n' +
            '<td>Using the Z85230 driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7062>7062</a></td>\n' +
            '<td>The Z85230 driver provides the back end interface to your board. To configure a Z8530 interface you need to detect the board and to identify its ports and interrupt resources. It is also your problem to verify the resources are available.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7063>7063</a></td>\n' +
            '<td>Having identified the chip you need to fill in a struct z8530_dev, which describes each chip. This object must exist until you finally shutdown the board. Firstly zero the active field. This ensures nothing goes off without you intending it. The irq field should be set to the interrupt number of the chip. (Each chip has a single interrupt source rather than each channel). You are responsible for allocating the interrupt line. The interrupt handler should be set to z8530_interrupt. The device id should be set to the z8530_dev structure pointer. Whether the interrupt can be shared or not is board dependent, and up to you to initialise.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7064>7064</a></td>\n' +
            '<td>The structure holds two channel structures. Initialise chanA.ctrlio and chanA.dataio with the address of the control and data ports. You can or this with Z8530_PORT_SLEEP to indicate your interface needs the 5uS delay for chip settling done in software. The PORT_SLEEP option is architecture specific. Other flags may become available on future platforms, eg for MMIO. Initialise the chanA.irqs to &amp;z8530_nop to start the chip up as disabled and discarding interrupt events. This ensures that stray interrupts will be mopped up and not hang the bus. Set chanA.dev to point to the device structure itself. The private and name field you may use as you wish. The private field is unused by the Z85230 layer. The name is used for error reporting and it may thus make sense to make it match the network name.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7065>7065</a></td>\n' +
            '<td>Repeat the same operation with the B channel if your chip has both channels wired to something useful. This isn' + "'" + 't always the case. If it is not wired then the I/O values do not matter, but you must initialise chanB.dev.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7066>7066</a></td>\n' +
            '<td>If your board has DMA facilities then initialise the txdma and rxdma fields for the relevant channels. You must also allocate the ISA DMA channels and do any necessary board level initialisation to configure them. The low level driver will do the Z8530 and DMA controller programming but not board specific magic.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7067>7067</a></td>\n' +
            '<td>Having initialised the device you can then call z8530_init. This will probe the chip and reset it into a known state. An identification sequence is then run to identify the chip type. If the checks fail to pass the function returns a non zero error code. Typically this indicates that the port given is not valid. After this call the type field of the z8530_dev structure is initialised to either Z8530, Z85C30 or Z85230 according to the chip found.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7068>7068</a></td>\n' +
            '<td>Once you have called z8530_init you can also make use of the utility function z8530_describe. This provides a consistent reporting format for the Z8530 devices, and allows all the drivers to provide consistent reporting.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7069>7069</a></td>\n' +
            '<td>Attaching Network Interfaces</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7070>7070</a></td>\n' +
            '<td>If you wish to use the network interface facilities of the driver, then you need to attach a network device to each channel that is present and in use. In addition to use the generic HDLC you need to follow some additional plumbing rules. They may seem complex but a look at the example hostess_sv11 driver should reassure you.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7071>7071</a></td>\n' +
            '<td>The network device used for each channel should be pointed to by the netdevice field of each channel. The hdlc-&gt; priv field of the network device points to your private data - you will need to be able to find your private data from this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7072>7072</a></td>\n' +
            '<td>The way most drivers approach this particular problem is to create a structure holding the Z8530 device definition and put that into the private field of the network device. The network device fields of the channels then point back to the network devices.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7073>7073</a></td>\n' +
            '<td>If you wish to use the generic HDLC then you need to register the HDLC device.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7074>7074</a></td>\n' +
            '<td>Before you register your network device you will also need to provide suitable handlers for most of the network device callbacks. See the network device documentation for more details on this.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7075>7075</a></td>\n' +
            '<td>Configuring And Activating The Port</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7076>7076</a></td>\n' +
            '<td>The Z85230 driver provides helper functions and tables to load the port registers on the Z8530 chips. When programming the register settings for a channel be aware that the documentation recommends initialisation orders. Strange things happen when these are not followed.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7077>7077</a></td>\n' +
            '<td>z8530_channel_load takes an array of pairs of initialisation values in an array of u8 type. The first value is the Z8530 register number. Add 16 to indicate the alternate register bank on the later chips. The array is terminated by a 255.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7078>7078</a></td>\n' +
            '<td>The driver provides a pair of public tables. The z8530_hdlc_kilostream table is for the UK ' + "'" + 'Kilostream' + "'" + ' service and also happens to cover most other end host configurations. The z8530_hdlc_kilostream_85230 table is the same configuration using the enhancements of the 85230 chip. The configuration loaded is standard NRZ encoded synchronous data with HDLC bitstuffing. All of the timing is taken from the other end of the link.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7079>7079</a></td>\n' +
            '<td>When writing your own tables be aware that the driver internally tracks register values. It may need to reload values. You should therefore be sure to set registers 1-7, 9-11, 14 and 15 in all configurations. Where the register settings depend on DMA selection the driver will update the bits itself when you open or close. Loading a new table with the interface open is not recommended.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7080>7080</a></td>\n' +
            '<td>There are three standard configurations supported by the core code. In PIO mode the interface is programmed up to use interrupt driven PIO. This places high demands on the host processor to avoid latency. The driver is written to take account of latency issues but it cannot avoid latencies caused by other drivers, notably IDE in PIO mode. Because the drivers allocate buffers you must also prevent MTU changes while the port is open.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7081>7081</a></td>\n' +
            '<td>Once the port is open it will call the rx_function of each channel whenever a completed packet arrived. This is invoked from interrupt context and passes you the channel and a network buffer (struct sk_buff) holding the data. The data includes the CRC bytes so most users will want to trim the last two bytes before processing the data. This function is very timing critical. When you wish to simply discard data the support code provides the function z8530_null_rx to discard the data.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7082>7082</a></td>\n' +
            '<td>To active PIO mode sending and receiving the</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7083>7083</a></td>\n' +
            '<td>    z8530_sync_open is called. This expects to be passed the network device and the channel. Typically this is called from your network device open callback. On a failure a non zero error status is returned. The z8530_sync_close function shuts down a PIO channel. This must be done before the channel is opened again and before the driver shuts down and unloads.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7084>7084</a></td>\n' +
            '<td>The ideal mode of operation is dual channel DMA mode. Here the kernel driver will configure the board for DMA in both directions. The driver also handles ISA DMA issues such as controller programming and the memory range limit for you. This mode is activated by calling the z8530_sync_dma_open function. On failure a non zero error value is returned. Once this mode is activated it can be shut down by calling the z8530_sync_dma_close. You must call the close function matching the open mode you used.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7085>7085</a></td>\n' +
            '<td>The final supported mode uses a single DMA channel to drive the transmit side. As the Z85C30 has a larger FIFO on the receive channel this tends to increase the maximum speed a little. This is activated by calling the z8530_sync_txdma_open</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7086>7086</a></td>\n' +
            '<td>    . This returns a non zero error code on failure. The z8530_sync_txdma_close function closes down the Z8530 interface from this mode.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7087>7087</a></td>\n' +
            '<td>Network Layer Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7088>7088</a></td>\n' +
            '<td>The Z8530 layer provides functions to queue packets for transmission. The driver internally buffers the frame currently being transmitted and one further frame (in order to keep back to back transmission running). Any further buffering is up to the caller.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7089>7089</a></td>\n' +
            '<td>The function z8530_queue_xmit takes a network buffer in sk_buff format and queues it for transmission. The caller must provide the entire packet with the exception of the bitstuffing and CRC. This is normally done by the caller via the generic HDLC interface layer. It returns 0 if the buffer has been queued and non zero values for queue full. If the function accepts the buffer it becomes property of the Z8530 layer and the caller should not free it.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7090>7090</a></td>\n' +
            '<td>The function z8530_get_stats returns a pointer to an internally maintained per interface statistics block. This provides most of the interface code needed to implement the network layer get_stats callback.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7091>7091</a></td>\n' +
            '<td>Porting The Z8530 Driver</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7092>7092</a></td>\n' +
            '<td>The Z8530 driver is written to be portable. In DMA mode it makes assumptions about the use of ISA DMA. These are probably warranted in most cases as the Z85230 in particular was designed to glue to PC type machines. The PIO mode makes no real assumptions.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7093>7093</a></td>\n' +
            '<td>Should you need to retarget the Z8530 driver to another architecture the only code that should need changing are the port I/O functions. At the moment these assume PC I/O port accesses. This may not be appropriate for all platforms. Replacing z8530_read_port and z8530_write_port</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7094>7094</a></td>\n' +
            '<td>     is intended to be all that is required to port this driver layer.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7095>7095</a></td>\n' +
            '<td>Known Bugs And Assumptions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7096>7096</a></td>\n' +
            '<td>Interrupt Locking</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7097>7097</a></td>\n' +
            '<td>The locking in the driver is done via the global cli/sti lock. This makes for relatively poor SMP performance. Switching this to use a per device spin lock would probably materially improve performance.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7098>7098</a></td>\n' +
            '<td>Occasional Failures</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7099>7099</a></td>\n' +
            '<td>We have reports of occasional failures when run for very long periods of time and the driver starts to receive junk frames. At the moment the cause of this is not clear.</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7100>7100</a></td>\n' +
            '<td>Public Functions Provided</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7101>7101</a></td>\n' +
            '<td>!Edrivers/net/wan/z85230.c</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7102>7102</a></td>\n' +
            '<td>Internal Functions</td>\n' +
        '</tr>\n' +
        '<tr>\n' +
            '<td><a name=7103>7103</a></td>\n' +
            '<td>!Idrivers/net/wan/z85230.c</td>\n' +
        '</tr>\n' +
    '</tbody></table>';
}
