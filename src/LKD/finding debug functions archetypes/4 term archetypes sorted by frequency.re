When the real object is (already )?tracked by debugobjects it is checked, whether the object can be
The fixup function can correct the problem
E\.g\. it can deactivate an active object in order to prevent damage to the subsystem\.
When debugobjects detects an error, then it calls the fixup_.*? function of the object type description structure if provided by the caller\.
The fixup function can correct the problem before the real .*? of the object happens\.
This function is called whenever the .*? function of a real object.*? is called\.
is not allowed for (active|untracked) and destroyed objects\.
When the real object is already tracked by debugobjects it is
When the real object is not (yet )?tracked by debugobjects
When the .*? is legitimate, then the state of the associated tracker object is set to ODEBUG_STATE_
When the real object is tracked by debugobjects it is checked, whether the object can be
This function is called (to|before).*? an object
Initializing is not allowed for active and destroyed objects\.
It verifies that the object is (not )?on the callers stack\.
When the real object is not yet tracked by debugobjects,? debugobjects allocates a tracker object for the real object and sets the tracker object state to ODEBUG_STATE_INIT\.

# по столбцам видны сильные связи
# выстроим подмножетсва по убыванию частоты встреч в строках и массы в следующей строке
# 12 123 56 12356


# но так рассчитывать всё равно не хорошо, потому как несколько
# архетипов относятся к одному и тому же предложению
# нужно либо каждому архетипу задать массу
# либо оставлять строго один архетип из группы предложений, что неоднозначно, возможно придётся брать сильно общий
